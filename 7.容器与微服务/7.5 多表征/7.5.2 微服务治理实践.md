# 微服务治理实践 / Microservice Governance Practice


<!-- TOC START -->

- [微服务治理实践 / Microservice Governance Practice](#微服务治理实践-microservice-governance-practice)
  - [概述 / Overview](#概述-overview)
  - [1. 服务注册与发现 / Service Registration and Discovery](#1-服务注册与发现-service-registration-and-discovery)
    - [1.1 服务注册中心 / Service Registry](#11-服务注册中心-service-registry)
      - [1.1.1 Consul服务注册 / Consul Service Registration](#111-consul服务注册-consul-service-registration)
- [Consul服务注册配置](#consul服务注册配置)
      - [1.1.2 Eureka服务注册 / Eureka Service Registration](#112-eureka服务注册-eureka-service-registration)
- [Eureka客户端配置](#eureka客户端配置)
- [Eureka服务端配置](#eureka服务端配置)
    - [1.2 服务发现机制 / Service Discovery Mechanism](#12-服务发现机制-service-discovery-mechanism)
      - [1.2.1 客户端负载均衡 / Client-Side Load Balancing](#121-客户端负载均衡-client-side-load-balancing)
- [Ribbon负载均衡配置](#ribbon负载均衡配置)
      - [1.2.2 服务健康检查 / Service Health Check](#122-服务健康检查-service-health-check)
  - [2. 配置管理 / Configuration Management](#2-配置管理-configuration-management)
    - [2.1 配置中心 / Configuration Center](#21-配置中心-configuration-center)
      - [2.1.1 Apollo配置中心 / Apollo Configuration Center](#211-apollo配置中心-apollo-configuration-center)
- [Apollo客户端配置](#apollo客户端配置)
      - [2.1.2 Nacos配置中心 / Nacos Configuration Center](#212-nacos配置中心-nacos-configuration-center)
- [Nacos配置](#nacos配置)
    - [2.2 配置加密与安全 / Configuration Encryption and Security](#22-配置加密与安全-configuration-encryption-and-security)
      - [2.2.1 敏感配置加密 / Sensitive Configuration Encryption](#221-敏感配置加密-sensitive-configuration-encryption)
- [Jasypt加密配置](#jasypt加密配置)
  - [3. 熔断降级 / Circuit Breaker and Degradation](#3-熔断降级-circuit-breaker-and-degradation)
    - [3.1 Hystrix熔断器 / Hystrix Circuit Breaker](#31-hystrix熔断器-hystrix-circuit-breaker)
      - [3.1.1 Hystrix配置 / Hystrix Configuration](#311-hystrix配置-hystrix-configuration)
- [Hystrix配置](#hystrix配置)
      - [3.1.2 熔断器监控 / Circuit Breaker Monitoring](#312-熔断器监控-circuit-breaker-monitoring)
    - [3.2 Sentinel熔断器 / Sentinel Circuit Breaker](#32-sentinel熔断器-sentinel-circuit-breaker)
      - [3.2.1 Sentinel配置 / Sentinel Configuration](#321-sentinel配置-sentinel-configuration)
- [Sentinel配置](#sentinel配置)
      - [3.2.2 熔断降级实现 / Circuit Breaker Implementation](#322-熔断降级实现-circuit-breaker-implementation)
  - [4. 链路追踪 / Distributed Tracing](#4-链路追踪-distributed-tracing)
    - [4.1 Zipkin链路追踪 / Zipkin Distributed Tracing](#41-zipkin链路追踪-zipkin-distributed-tracing)
      - [4.1.1 Zipkin配置 / Zipkin Configuration](#411-zipkin配置-zipkin-configuration)
- [Zipkin配置](#zipkin配置)
      - [4.1.2 链路追踪拦截器 / Tracing Interceptor](#412-链路追踪拦截器-tracing-interceptor)
    - [4.2 Jaeger链路追踪 / Jaeger Distributed Tracing](#42-jaeger链路追踪-jaeger-distributed-tracing)
      - [4.2.1 Jaeger配置 / Jaeger Configuration](#421-jaeger配置-jaeger-configuration)
- [Jaeger配置](#jaeger配置)
  - [5. 服务监控 / Service Monitoring](#5-服务监控-service-monitoring)
    - [5.1 指标监控 / Metrics Monitoring](#51-指标监控-metrics-monitoring)
      - [5.1.1 Micrometer指标收集 / Micrometer Metrics Collection](#511-micrometer指标收集-micrometer-metrics-collection)
- [Micrometer配置](#micrometer配置)
      - [5.1.2 业务指标监控 / Business Metrics Monitoring](#512-业务指标监控-business-metrics-monitoring)
    - [5.2 告警配置 / Alert Configuration](#52-告警配置-alert-configuration)
      - [5.2.1 Prometheus告警规则 / Prometheus Alert Rules](#521-prometheus告警规则-prometheus-alert-rules)
- [Prometheus告警规则](#prometheus告警规则)
      - [5.2.2 告警通知配置 / Alert Notification Configuration](#522-告警通知配置-alert-notification-configuration)
  - [6. 服务安全 / Service Security](#6-服务安全-service-security)
    - [6.1 认证授权 / Authentication and Authorization](#61-认证授权-authentication-and-authorization)
      - [6.1.1 JWT认证 / JWT Authentication](#611-jwt认证-jwt-authentication)
- [JWT配置](#jwt配置)
      - [6.1.2 OAuth2授权 / OAuth2 Authorization](#612-oauth2授权-oauth2-authorization)
    - [6.2 服务间安全通信 / Inter-Service Security Communication](#62-服务间安全通信-inter-service-security-communication)
      - [6.2.1 mTLS配置 / mTLS Configuration](#621-mtls配置-mtls-configuration)
- [mTLS配置](#mtls配置)
  - [7. 最佳实践总结 / Best Practices Summary](#7-最佳实践总结-best-practices-summary)
    - [7.1 服务治理最佳实践 / Service Governance Best Practices](#71-服务治理最佳实践-service-governance-best-practices)
    - [7.2 安全最佳实践 / Security Best Practices](#72-安全最佳实践-security-best-practices)
    - [7.3 运维最佳实践 / Operations Best Practices](#73-运维最佳实践-operations-best-practices)
  - [参考文献 / References](#参考文献-references)

<!-- TOC END -->

## 概述 / Overview

微服务治理是确保微服务架构稳定运行、高效协作的关键技术。本章节将深入探讨微服务治理的核心实践，包括服务注册发现、配置管理、熔断降级、链路追踪等关键领域。

Microservice governance is a key technology to ensure stable operation and efficient collaboration of microservice architecture. This chapter will explore core practices of microservice governance, including service registration and discovery, configuration management, circuit breaker and degradation, distributed tracing, and other critical areas.

## 1. 服务注册与发现 / Service Registration and Discovery

### 1.1 服务注册中心 / Service Registry

#### 1.1.1 Consul服务注册 / Consul Service Registration

**服务注册配置：**

```yaml
# Consul服务注册配置
spring:
  cloud:
    consul:
      host: consul-server
      port: 8500
      discovery:
        service-name: user-service
        instance-id: ${spring.application.name}:${server.port}
        health-check-path: /actuator/health
        health-check-interval: 15s
        prefer-ip-address: true
        tags:
          - version=v1.0.0
          - environment=production
```

**服务注册实现：**

```java
@Service
public class ServiceRegistrationService {
    
    @Autowired
    private ConsulClient consulClient;
    
    public void registerService(String serviceName, String serviceId, 
                               String address, int port) {
        NewService service = new NewService();
        service.setId(serviceId);
        service.setName(serviceName);
        service.setAddress(address);
        service.setPort(port);
        
        // 健康检查配置
        NewService.Check check = new NewService.Check();
        check.setHttp("http://" + address + ":" + port + "/health");
        check.setInterval("15s");
        check.setTimeout("5s");
        service.setCheck(check);
        
        // 元数据
        service.setTags(Arrays.asList("version=v1.0.0", "env=prod"));
        
        consulClient.agentServiceRegister(service);
    }
    
    public void deregisterService(String serviceId) {
        consulClient.agentServiceDeregister(serviceId);
    }
}
```

#### 1.1.2 Eureka服务注册 / Eureka Service Registration

**Eureka客户端配置：**

```yaml
# Eureka客户端配置
eureka:
  client:
    service-url:
      defaultZone: http://eureka-server:8761/eureka/
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
    health-check-url-path: /actuator/health
    status-page-url-path: /actuator/info
    metadata-map:
      version: v1.0.0
      environment: production
```

**Eureka服务端配置：**

```yaml
# Eureka服务端配置
eureka:
  server:
    enable-self-preservation: true
    eviction-interval-timer-in-ms: 60000
    response-cache-update-interval-ms: 3000
  instance:
    hostname: eureka-server
    appname: eureka-server
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://eureka-server:8761/eureka/
```

### 1.2 服务发现机制 / Service Discovery Mechanism

#### 1.2.1 客户端负载均衡 / Client-Side Load Balancing

**Ribbon负载均衡配置：**

```yaml
# Ribbon负载均衡配置
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 5000
  MaxAutoRetries: 1
  MaxAutoRetriesNextServer: 1
  OkToRetryOnAllOperations: false
  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule

user-service:
  ribbon:
    listOfServers: user-service-1:8080,user-service-2:8080,user-service-3:8080
    ConnectTimeout: 2000
    ReadTimeout: 3000
```

**负载均衡策略实现：**

```java
@Component
public class CustomLoadBalancerRule extends AbstractLoadBalancerRule {
    
    @Override
    public Server choose(Object key) {
        ILoadBalancer lb = getLoadBalancer();
        
        // 获取可用服务器列表
        List<Server> reachableServers = lb.getReachableServers();
        List<Server> allServers = lb.getAllServers();
        
        if (reachableServers.isEmpty()) {
            return null;
        }
        
        // 自定义负载均衡逻辑
        return chooseServer(reachableServers, key);
    }
    
    private Server chooseServer(List<Server> servers, Object key) {
        // 加权轮询算法
        int totalWeight = 0;
        for (Server server : servers) {
            totalWeight += getServerWeight(server);
        }
        
        int random = new Random().nextInt(totalWeight);
        int currentWeight = 0;
        
        for (Server server : servers) {
            currentWeight += getServerWeight(server);
            if (random < currentWeight) {
                return server;
            }
        }
        
        return servers.get(0);
    }
    
    private int getServerWeight(Server server) {
        // 根据服务器性能指标计算权重
        return 1;
    }
}
```

#### 1.2.2 服务健康检查 / Service Health Check

**健康检查实现：**

```java
@Component
public class HealthCheckService {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    public List<ServiceInstance> getHealthyInstances(String serviceName) {
        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);
        List<ServiceInstance> healthyInstances = new ArrayList<>();
        
        for (ServiceInstance instance : instances) {
            if (isHealthy(instance)) {
                healthyInstances.add(instance);
            }
        }
        
        return healthyInstances;
    }
    
    private boolean isHealthy(ServiceInstance instance) {
        try {
            String healthUrl = "http://" + instance.getHost() + ":" + 
                              instance.getPort() + "/actuator/health";
            
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.getForEntity(healthUrl, String.class);
            
            return response.getStatusCode() == HttpStatus.OK;
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 2. 配置管理 / Configuration Management

### 2.1 配置中心 / Configuration Center

#### 2.1.1 Apollo配置中心 / Apollo Configuration Center

**Apollo客户端配置：**

```yaml
# Apollo客户端配置
app:
  id: user-service
apollo:
  meta: http://apollo-config-server:8080
  bootstrap:
    enabled: true
    eagerLoad:
      enabled: true
  property:
    order:
      enabled: true
```

**配置监听实现：**

```java
@Component
public class ConfigurationChangeListener {
    
    @ApolloConfigChangeListener
    public void onChange(ConfigChangeEvent changeEvent) {
        for (String key : changeEvent.changedKeys()) {
            ConfigChange change = changeEvent.getChange(key);
            String oldValue = change.getOldValue();
            String newValue = change.getNewValue();
            
            logger.info("Configuration changed - key: {}, oldValue: {}, newValue: {}", 
                       key, oldValue, newValue);
            
            // 处理配置变更
            handleConfigChange(key, oldValue, newValue);
        }
    }
    
    private void handleConfigChange(String key, String oldValue, String newValue) {
        switch (key) {
            case "database.url":
                updateDatabaseConnection(newValue);
                break;
            case "redis.url":
                updateRedisConnection(newValue);
                break;
            case "feature.flags":
                updateFeatureFlags(newValue);
                break;
            default:
                logger.warn("Unknown configuration key: {}", key);
        }
    }
}
```

#### 2.1.2 Nacos配置中心 / Nacos Configuration Center

**Nacos配置管理：**

```yaml
# Nacos配置
spring:
  cloud:
    nacos:
      config:
        server-addr: nacos-server:8848
        namespace: production
        group: DEFAULT_GROUP
        file-extension: yaml
        shared-configs:
          - data-id: common-config.yaml
            group: DEFAULT_GROUP
            refresh: true
          - data-id: database-config.yaml
            group: DEFAULT_GROUP
            refresh: true
```

**配置刷新实现：**

```java
@RefreshScope
@Configuration
public class DatabaseConfig {
    
    @Value("${database.url}")
    private String databaseUrl;
    
    @Value("${database.username}")
    private String username;
    
    @Value("${database.password}")
    private String password;
    
    @Bean
    @RefreshScope
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(databaseUrl);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        
        return new HikariDataSource(config);
    }
}
```

### 2.2 配置加密与安全 / Configuration Encryption and Security

#### 2.2.1 敏感配置加密 / Sensitive Configuration Encryption

**Jasypt加密配置：**

```yaml
# Jasypt加密配置
jasypt:
  encryptor:
    password: ${JASYPT_PASSWORD:defaultPassword}
    algorithm: PBEWithMD5AndDES
    iv-generator-classname: org.jasypt.iv.RandomIvGenerator

spring:
  datasource:
    url: ENC(encrypted_database_url)
    username: ENC(encrypted_username)
    password: ENC(encrypted_password)
```

**加密工具类：**

```java
@Component
public class ConfigurationEncryptor {
    
    @Autowired
    private StringEncryptor encryptor;
    
    public String encrypt(String value) {
        return encryptor.encrypt(value);
    }
    
    public String decrypt(String encryptedValue) {
        return encryptor.decrypt(encryptedValue);
    }
    
    public boolean isEncrypted(String value) {
        return value.startsWith("ENC(") && value.endsWith(")");
    }
    
    public String decryptIfNeeded(String value) {
        if (isEncrypted(value)) {
            String encryptedContent = value.substring(4, value.length() - 1);
            return decrypt(encryptedContent);
        }
        return value;
    }
}
```

## 3. 熔断降级 / Circuit Breaker and Degradation

### 3.1 Hystrix熔断器 / Hystrix Circuit Breaker

#### 3.1.1 Hystrix配置 / Hystrix Configuration

**Hystrix配置：**

```yaml
# Hystrix配置
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 3000
        timeout:
          enabled: true
      circuitBreaker:
        enabled: true
        requestVolumeThreshold: 20
        errorThresholdPercentage: 50
        sleepWindowInMilliseconds: 5000
      fallback:
        enabled: true
    UserServiceCommand:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000
      circuitBreaker:
        requestVolumeThreshold: 10
        errorThresholdPercentage: 30
```

**熔断器实现：**

```java
@Component
public class UserServiceClient {
    
    @HystrixCommand(
        fallbackMethod = "getUserFallback",
        commandKey = "UserServiceCommand",
        groupKey = "UserService",
        threadPoolKey = "UserServiceThreadPool"
    )
    public User getUser(Long userId) {
        // 调用用户服务
        return restTemplate.getForObject("/users/" + userId, User.class);
    }
    
    public User getUserFallback(Long userId, Throwable throwable) {
        logger.warn("User service call failed for userId: {}, fallback triggered", userId);
        
        // 降级逻辑：返回默认用户信息
        User fallbackUser = new User();
        fallbackUser.setId(userId);
        fallbackUser.setName("Default User");
        fallbackUser.setEmail("default@example.com");
        
        return fallbackUser;
    }
    
    @HystrixCommand(
        fallbackMethod = "createUserFallback",
        commandKey = "CreateUserCommand"
    )
    public User createUser(User user) {
        return restTemplate.postForObject("/users", user, User.class);
    }
    
    public User createUserFallback(User user, Throwable throwable) {
        logger.error("Create user failed, fallback triggered", throwable);
        throw new ServiceException("User service unavailable");
    }
}
```

#### 3.1.2 熔断器监控 / Circuit Breaker Monitoring

**Hystrix监控配置：**

```java
@Configuration
public class HystrixConfig {
    
    @Bean
    public HystrixMetricsPoller hystrixMetricsPoller() {
        return new HystrixMetricsPoller();
    }
    
    @Bean
    public HystrixMetricsPollerListener hystrixMetricsPollerListener() {
        return new HystrixMetricsPollerListener();
    }
}
```

**监控指标收集：**

```java
@Component
public class HystrixMetricsCollector {
    
    public Map<String, Object> collectMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // 收集熔断器状态
        Map<String, HystrixCommandMetrics> commandMetrics = 
            HystrixCommandMetrics.getInstances();
        
        for (Map.Entry<String, HystrixCommandMetrics> entry : commandMetrics.entrySet()) {
            String commandKey = entry.getKey();
            HystrixCommandMetrics metrics = entry.getValue();
            
            Map<String, Object> commandData = new HashMap<>();
            commandData.put("successCount", metrics.getCumulativeCount(HystrixEventType.SUCCESS));
            commandData.put("failureCount", metrics.getCumulativeCount(HystrixEventType.FAILURE));
            commandData.put("timeoutCount", metrics.getCumulativeCount(HystrixEventType.TIMEOUT));
            commandData.put("circuitOpen", metrics.getCircuitBreaker().isOpen());
            commandData.put("errorPercentage", metrics.getHealthCounts().getErrorPercentage());
            
            metrics.put(commandKey, commandData);
        }
        
        return metrics;
    }
}
```

### 3.2 Sentinel熔断器 / Sentinel Circuit Breaker

#### 3.2.1 Sentinel配置 / Sentinel Configuration

**Sentinel配置：**

```yaml
# Sentinel配置
spring:
  cloud:
    sentinel:
      transport:
        dashboard: sentinel-dashboard:8080
        port: 8719
      datasource:
        ds:
          nacos:
            server-addr: nacos-server:8848
            dataId: sentinel-rules
            groupId: DEFAULT_GROUP
            rule-type: flow
```

**流量控制规则：**

```java
@Component
public class SentinelRuleManager {
    
    public void initFlowRules() {
        List<FlowRule> rules = new ArrayList<>();
        
        // 用户服务流量控制
        FlowRule userServiceRule = new FlowRule();
        userServiceRule.setResource("getUser");
        userServiceRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        userServiceRule.setCount(100); // 每秒100个请求
        rules.add(userServiceRule);
        
        // 订单服务流量控制
        FlowRule orderServiceRule = new FlowRule();
        orderServiceRule.setResource("createOrder");
        orderServiceRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        orderServiceRule.setCount(50);
        rules.add(orderServiceRule);
        
        FlowRuleManager.loadRules(rules);
    }
    
    public void initDegradeRules() {
        List<DegradeRule> rules = new ArrayList<>();
        
        // 用户服务降级规则
        DegradeRule userServiceRule = new DegradeRule();
        userServiceRule.setResource("getUser");
        userServiceRule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);
        userServiceRule.setCount(5); // 5个异常后降级
        userServiceRule.setTimeWindow(10); // 10秒时间窗口
        rules.add(userServiceRule);
        
        DegradeRuleManager.loadRules(rules);
    }
}
```

#### 3.2.2 熔断降级实现 / Circuit Breaker Implementation

**Sentinel注解使用：**

```java
@Service
public class UserService {
    
    @SentinelResource(
        value = "getUser",
        blockHandler = "getUserBlockHandler",
        fallback = "getUserFallback"
    )
    public User getUser(Long userId) {
        // 业务逻辑
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User not found"));
    }
    
    // 限流处理
    public User getUserBlockHandler(Long userId, BlockException ex) {
        logger.warn("User service blocked for userId: {}", userId);
        throw new ServiceException("Service temporarily unavailable");
    }
    
    // 降级处理
    public User getUserFallback(Long userId, Throwable throwable) {
        logger.warn("User service fallback for userId: {}", userId);
        
        User fallbackUser = new User();
        fallbackUser.setId(userId);
        fallbackUser.setName("Default User");
        fallbackUser.setEmail("default@example.com");
        
        return fallbackUser;
    }
}
```

## 4. 链路追踪 / Distributed Tracing

### 4.1 Zipkin链路追踪 / Zipkin Distributed Tracing

#### 4.1.1 Zipkin配置 / Zipkin Configuration

**Zipkin客户端配置：**

```yaml
# Zipkin配置
spring:
  zipkin:
    base-url: http://zipkin-server:9411
    sender:
      type: web
  sleuth:
    sampler:
      probability: 1.0
    propagation:
      type: B3
    baggage-keys: x-request-id,x-session-id
```

**链路追踪实现：**

```java
@Component
public class TracingService {
    
    @Autowired
    private Tracer tracer;
    
    public void addCustomSpan(String operationName, String tagKey, String tagValue) {
        Span span = tracer.nextSpan().name(operationName);
        
        try (SpanInScope ws = tracer.withSpanInScope(span.start())) {
            span.tag(tagKey, tagValue);
            
            // 执行业务逻辑
            performOperation();
            
        } finally {
            span.finish();
        }
    }
    
    public void addBaggage(String key, String value) {
        tracer.createBaggage(key, value);
    }
    
    public String getBaggage(String key) {
        return tracer.getBaggage(key);
    }
    
    private void performOperation() {
        // 业务逻辑实现
    }
}
```

#### 4.1.2 链路追踪拦截器 / Tracing Interceptor

**HTTP请求追踪：**

```java
@Component
public class TracingInterceptor implements HandlerInterceptor {
    
    @Autowired
    private Tracer tracer;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) throws Exception {
        
        // 创建新的Span
        Span span = tracer.nextSpan().name("http-request");
        span.tag("http.method", request.getMethod());
        span.tag("http.url", request.getRequestURL().toString());
        span.tag("http.user-agent", request.getHeader("User-Agent"));
        
        // 将Span存储到请求属性中
        request.setAttribute("currentSpan", span);
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                          Object handler, ModelAndView modelAndView) throws Exception {
        
        Span span = (Span) request.getAttribute("currentSpan");
        if (span != null) {
            span.tag("http.status_code", String.valueOf(response.getStatus()));
        }
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                               Object handler, Exception ex) throws Exception {
        
        Span span = (Span) request.getAttribute("currentSpan");
        if (span != null) {
            if (ex != null) {
                span.tag("error", ex.getMessage());
            }
            span.finish();
        }
    }
}
```

### 4.2 Jaeger链路追踪 / Jaeger Distributed Tracing

#### 4.2.1 Jaeger配置 / Jaeger Configuration

**Jaeger客户端配置：**

```yaml
# Jaeger配置
opentracing:
  jaeger:
    http-sender:
      url: http://jaeger-collector:14268/api/traces
    probabilistic-sampler:
      sampling-rate: 1.0
    log-spans: true
```

**Jaeger追踪实现：**

```java
@Component
public class JaegerTracingService {
    
    @Autowired
    private Tracer tracer;
    
    public void traceDatabaseOperation(String operation, String query) {
        Span span = tracer.buildSpan("database-operation")
            .withTag("operation", operation)
            .withTag("query", query)
            .start();
        
        try (Scope scope = tracer.activateSpan(span)) {
            // 执行数据库操作
            executeDatabaseQuery(query);
            
        } catch (Exception e) {
            span.setTag("error", true);
            span.log(Map.of("error.message", e.getMessage()));
            throw e;
        } finally {
            span.finish();
        }
    }
    
    public void traceExternalServiceCall(String serviceName, String endpoint) {
        Span span = tracer.buildSpan("external-service-call")
            .withTag("service.name", serviceName)
            .withTag("endpoint", endpoint)
            .start();
        
        try (Scope scope = tracer.activateSpan(span)) {
            // 调用外部服务
            callExternalService(serviceName, endpoint);
            
        } catch (Exception e) {
            span.setTag("error", true);
            span.log(Map.of("error.message", e.getMessage()));
            throw e;
        } finally {
            span.finish();
        }
    }
    
    private void executeDatabaseQuery(String query) {
        // 数据库操作实现
    }
    
    private void callExternalService(String serviceName, String endpoint) {
        // 外部服务调用实现
    }
}
```

## 5. 服务监控 / Service Monitoring

### 5.1 指标监控 / Metrics Monitoring

#### 5.1.1 Micrometer指标收集 / Micrometer Metrics Collection

**Micrometer配置：**

```yaml
# Micrometer配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: user-service
      environment: production
```

**自定义指标：**

```java
@Component
public class CustomMetrics {
    
    private final Counter requestCounter;
    private final Timer requestTimer;
    private final Gauge activeUsers;
    private final DistributionSummary responseSize;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.requestCounter = Counter.builder("app.requests.total")
            .description("Total number of requests")
            .tag("service", "user-service")
            .register(meterRegistry);
            
        this.requestTimer = Timer.builder("app.requests.duration")
            .description("Request duration")
            .tag("service", "user-service")
            .register(meterRegistry);
            
        this.activeUsers = Gauge.builder("app.users.active")
            .description("Number of active users")
            .tag("service", "user-service")
            .register(meterRegistry, this, CustomMetrics::getActiveUserCount);
            
        this.responseSize = DistributionSummary.builder("app.response.size")
            .description("Response size distribution")
            .tag("service", "user-service")
            .register(meterRegistry);
    }
    
    public void incrementRequestCount() {
        requestCounter.increment();
    }
    
    public Timer.Sample startTimer() {
        return Timer.start();
    }
    
    public void stopTimer(Timer.Sample sample) {
        sample.stop(requestTimer);
    }
    
    public void recordResponseSize(long size) {
        responseSize.record(size);
    }
    
    private double getActiveUserCount() {
        // 获取活跃用户数的逻辑
        return 100.0;
    }
}
```

#### 5.1.2 业务指标监控 / Business Metrics Monitoring

**业务指标实现：**

```java
@Component
public class BusinessMetricsService {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, Counter> businessCounters = new ConcurrentHashMap<>();
    private final Map<String, Timer> businessTimers = new ConcurrentHashMap<>();
    
    public BusinessMetricsService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordUserRegistration(String source) {
        Counter counter = businessCounters.computeIfAbsent(
            "user.registration",
            k -> Counter.builder(k)
                .tag("source", source)
                .register(meterRegistry)
        );
        counter.increment();
    }
    
    public void recordOrderCreation(String orderType, double amount) {
        Counter counter = businessCounters.computeIfAbsent(
            "order.created",
            k -> Counter.builder(k)
                .tag("type", orderType)
                .register(meterRegistry)
        );
        counter.increment();
        
        // 记录订单金额
        meterRegistry.gauge("order.amount", 
            Tags.of("type", orderType), amount);
    }
    
    public Timer.Sample startPaymentTimer(String paymentMethod) {
        Timer timer = businessTimers.computeIfAbsent(
            "payment.duration",
            k -> Timer.builder(k)
                .tag("method", paymentMethod)
                .register(meterRegistry)
        );
        return Timer.start(timer);
    }
    
    public void recordApiCall(String endpoint, int statusCode, long duration) {
        Timer timer = businessTimers.computeIfAbsent(
            "api.call.duration",
            k -> Timer.builder(k)
                .tag("endpoint", endpoint)
                .tag("status", String.valueOf(statusCode))
                .register(meterRegistry)
        );
        timer.record(duration, TimeUnit.MILLISECONDS);
    }
}
```

### 5.2 告警配置 / Alert Configuration

#### 5.2.1 Prometheus告警规则 / Prometheus Alert Rules

**告警规则配置：**

```yaml
# Prometheus告警规则
groups:
  - name: microservice-alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }}"
          
      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "95th percentile latency is {{ $value }}s"
          
      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "Service {{ $labels.instance }} is down"
          
      - alert: HighMemoryUsage
        expr: (container_memory_usage_bytes / container_spec_memory_limit_bytes) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage"
          description: "Memory usage is {{ $value | humanizePercentage }}"
```

#### 5.2.2 告警通知配置 / Alert Notification Configuration

**告警通知实现：**

```java
@Component
public class AlertNotificationService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public void sendSlackNotification(String message, String channel) {
        SlackMessage slackMessage = new SlackMessage();
        slackMessage.setText(message);
        slackMessage.setChannel(channel);
        
        restTemplate.postForObject(
            "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK",
            slackMessage,
            String.class
        );
    }
    
    public void sendEmailNotification(String subject, String content, String recipient) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(recipient);
        message.setSubject(subject);
        message.setText(content);
        
        // 发送邮件
        mailSender.send(message);
    }
    
    public void sendSMSNotification(String phoneNumber, String message) {
        // SMS发送实现
        smsService.send(phoneNumber, message);
    }
    
    @EventListener
    public void handleAlertEvent(AlertEvent event) {
        switch (event.getSeverity()) {
            case CRITICAL:
                sendSlackNotification(event.getMessage(), "#alerts-critical");
                sendEmailNotification("Critical Alert", event.getMessage(), "admin@company.com");
                sendSMSNotification("+1234567890", event.getMessage());
                break;
            case WARNING:
                sendSlackNotification(event.getMessage(), "#alerts-warning");
                break;
            case INFO:
                sendSlackNotification(event.getMessage(), "#alerts-info");
                break;
        }
    }
}
```

## 6. 服务安全 / Service Security

### 6.1 认证授权 / Authentication and Authorization

#### 6.1.1 JWT认证 / JWT Authentication

**JWT配置：**

```yaml
# JWT配置
jwt:
  secret: your-secret-key
  expiration: 86400000  # 24小时
  header: Authorization
  prefix: Bearer
```

**JWT服务实现：**

```java
@Service
public class JwtService {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private long expiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", userDetails.getUsername());
        claims.put("created", new Date());
        claims.put("authorities", userDetails.getAuthorities());
        
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }
    
    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }
    
    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }
}
```

#### 6.1.2 OAuth2授权 / OAuth2 Authorization

**OAuth2配置：**

```java
@Configuration
@EnableAuthorizationServer
public class OAuth2Config extends AuthorizationServerConfigurerAdapter {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
            .withClient("web-client")
            .secret(passwordEncoder.encode("secret"))
            .authorizedGrantTypes("password", "refresh_token")
            .authorities("ROLE_CLIENT")
            .scopes("read", "write")
            .accessTokenValiditySeconds(3600)
            .refreshTokenValiditySeconds(86400);
    }
    
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager)
            .tokenStore(tokenStore())
            .accessTokenConverter(accessTokenConverter());
    }
    
    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }
    
    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("your-signing-key");
        return converter;
    }
}
```

### 6.2 服务间安全通信 / Inter-Service Security Communication

#### 6.2.1 mTLS配置 / mTLS Configuration

**mTLS客户端配置：**

```yaml
# mTLS配置
server:
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: password
    key-store-type: PKCS12
    key-alias: client
    trust-store: classpath:truststore.p12
    trust-store-password: password
    trust-store-type: PKCS12
    client-auth: need
```

**mTLS服务端配置：**

```java
@Configuration
public class MTLSConfig {
    
    @Bean
    public TomcatServletWebServerFactory tomcatServletWebServerFactory() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.addConnectorCustomizers(connector -> {
            connector.setProperty("SSLEnabled", "true");
            connector.setProperty("keystoreFile", "keystore.p12");
            connector.setProperty("keystorePass", "password");
            connector.setProperty("keystoreType", "PKCS12");
            connector.setProperty("truststoreFile", "truststore.p12");
            connector.setProperty("truststorePass", "password");
            connector.setProperty("truststoreType", "PKCS12");
            connector.setProperty("clientAuth", "true");
        });
        return factory;
    }
}
```

## 7. 最佳实践总结 / Best Practices Summary

### 7.1 服务治理最佳实践 / Service Governance Best Practices

1. **服务注册发现**：使用可靠的服务注册中心，实现自动服务发现
2. **配置管理**：集中化配置管理，支持动态配置更新
3. **熔断降级**：实现熔断器模式，防止服务雪崩
4. **链路追踪**：完整的分布式链路追踪，便于问题定位
5. **监控告警**：全面的监控指标和告警机制

### 7.2 安全最佳实践 / Security Best Practices

1. **认证授权**：实现统一的认证授权机制
2. **安全通信**：使用TLS/mTLS确保服务间通信安全
3. **配置加密**：敏感配置信息加密存储
4. **访问控制**：实施最小权限原则
5. **安全审计**：记录安全相关操作日志

### 7.3 运维最佳实践 / Operations Best Practices

1. **自动化部署**：实现CI/CD自动化部署流程
2. **健康检查**：完善的服务健康检查机制
3. **故障恢复**：快速故障检测和自动恢复
4. **性能优化**：持续的性能监控和优化
5. **容量规划**：合理的资源规划和扩容策略

## 参考文献 / References

1. Spring Cloud Documentation. "Service Discovery". <https://spring.io/projects/spring-cloud>
2. Netflix Hystrix Documentation. "Circuit Breaker Pattern". <https://github.com/Netflix/Hystrix>
3. Alibaba Sentinel Documentation. "Flow Control". <https://sentinelguard.io/>
4. Zipkin Documentation. "Distributed Tracing". <https://zipkin.io/>
5. Jaeger Documentation. "Distributed Tracing". <https://www.jaegertracing.io/>
6. Micrometer Documentation. "Metrics Collection". <https://micrometer.io/>
7. Prometheus Documentation. "Alerting". <https://prometheus.io/docs/alerting/>
8. JWT Documentation. "JSON Web Tokens". <https://jwt.io/>
9. OAuth2 Documentation. "Authorization Framework". <https://oauth.net/2/>
10. mTLS Documentation. "Mutual TLS". <https://en.wikipedia.org/wiki/Mutual_authentication>

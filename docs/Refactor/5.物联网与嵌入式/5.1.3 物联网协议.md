# 5.1.3 物联网协议 / IoT Protocols


<!-- TOC START -->

- [5.1.3 物联网协议 / IoT Protocols](#513-物联网协议-iot-protocols)
  - [5.1.3.1 协议概述 / Protocol Overview](#5131-协议概述-protocol-overview)
    - [5.1.3.1.1 物联网协议栈 / IoT Protocol Stack](#51311-物联网协议栈-iot-protocol-stack)
    - [5.1.3.1.2 协议性能建模 / Protocol Performance Modeling](#51312-协议性能建模-protocol-performance-modeling)
  - [5.1.3.2 MQTT协议 / MQTT Protocol](#5132-mqtt协议-mqtt-protocol)
    - [5.1.3.2.1 MQTT基础 / MQTT Fundamentals](#51321-mqtt基础-mqtt-fundamentals)
    - [5.1.3.2.2 MQTT QoS实现 / MQTT QoS Implementation](#51322-mqtt-qos实现-mqtt-qos-implementation)
  - [5.1.3.3 CoAP协议 / CoAP Protocol](#5133-coap协议-coap-protocol)
    - [5.1.3.3.1 CoAP基础 / CoAP Fundamentals](#51331-coap基础-coap-fundamentals)
  - [5.1.3.4 LoRaWAN协议 / LoRaWAN Protocol](#5134-lorawan协议-lorawan-protocol)
    - [5.1.3.4.1 LoRaWAN架构 / LoRaWAN Architecture](#51341-lorawan架构-lorawan-architecture)
  - [5.1.3.5 协议互操作性 / Protocol Interoperability](#5135-协议互操作性-protocol-interoperability)
    - [5.1.3.5.1 协议桥接 / Protocol Bridging](#51351-协议桥接-protocol-bridging)
    - [5.1.3.5.2 协议性能比较 / Protocol Performance Comparison](#51352-协议性能比较-protocol-performance-comparison)
  - [总结 / Summary](#总结-summary)

<!-- TOC END -->

## 5.1.3.1 协议概述 / Protocol Overview

### 5.1.3.1.1 物联网协议栈 / IoT Protocol Stack

**协议分层架构：**

```text
应用层 (Application Layer)
    ├── HTTP/HTTPS, CoAP, MQTT, AMQP
    ├── WebSocket, LWM2M, XMPP
    └── 自定义应用协议

会话层 (Session Layer)  
    ├── TLS/DTLS (安全传输)
    ├── TCP/UDP (传输控制)
    └── SCTP (流控制传输)

网络层 (Network Layer)
    ├── IPv6/IPv4 (网络协议)
    ├── 6LoWPAN (IPv6 over Low power WPAN)
    └── RPL (IPv6路由协议)

链路层 (Link Layer)
    ├── IEEE 802.15.4 (低功耗无线)
    ├── WiFi, Bluetooth, ZigBee
    ├── LoRa, Sigfox, NB-IoT
    └── Ethernet, CAN Bus

物理层 (Physical Layer)
    ├── 无线电频段 (ISM, Licensed)
    ├── 调制技术 (FSK, OFDM, CSS)
    └── 天线设计与传播特性
```

**协议选择矩阵：**

| 协议 | 功耗 | 带宽 | 延迟 | 安全性 | 适用场景 |
|------|------|------|------|--------|----------|
| MQTT | 低 | 中等 | 低 | 中等 | 实时消息传递 |
| CoAP | 极低 | 低 | 极低 | 高 | 资源受限设备 |
| LoRaWAN | 极低 | 极低 | 高 | 中等 | 远距离传感 |
| HTTP/HTTPS | 高 | 高 | 中等 | 高 | Web集成 |
| WebSocket | 中等 | 高 | 低 | 高 | 实时双向通信 |

### 5.1.3.1.2 协议性能建模 / Protocol Performance Modeling

**性能指标定义：**

```rust
use std::time::{Duration, Instant};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtocolMetrics {
    pub latency: Duration,
    pub throughput: f64,         // bytes per second
    pub packet_loss_rate: f64,   // 0.0 to 1.0
    pub energy_consumption: f64, // mJ per message
    pub reliability: f64,        // 0.0 to 1.0
    pub scalability: usize,      // max concurrent connections
}

#[derive(Debug, Clone)]
pub struct ProtocolPerformanceModel {
    pub name: String,
    pub overhead_bytes: usize,
    pub connection_setup_time: Duration,
    pub message_processing_time: Duration,
    pub power_consumption_idle: f64,    // mW
    pub power_consumption_active: f64,  // mW
}

impl ProtocolPerformanceModel {
    pub fn calculate_metrics(&self, 
                           message_size: usize, 
                           message_rate: f64,
                           duration: Duration) -> ProtocolMetrics {
        let total_message_size = message_size + self.overhead_bytes;
        let latency = self.connection_setup_time + self.message_processing_time;
        let throughput = total_message_size as f64 * message_rate;
        
        // 能耗计算 (简化模型)
        let active_time_ratio = message_rate * self.message_processing_time.as_secs_f64();
        let average_power = self.power_consumption_idle * (1.0 - active_time_ratio) +
                           self.power_consumption_active * active_time_ratio;
        let energy_per_message = average_power / message_rate / 1000.0; // mJ
        
        ProtocolMetrics {
            latency,
            throughput,
            packet_loss_rate: self.estimate_packet_loss(message_rate),
            energy_consumption: energy_per_message,
            reliability: self.calculate_reliability(message_rate),
            scalability: self.estimate_max_connections(),
        }
    }
    
    fn estimate_packet_loss(&self, message_rate: f64) -> f64 {
        // 简化的丢包率模型
        (message_rate / 1000.0).min(0.1)
    }
    
    fn calculate_reliability(&self, message_rate: f64) -> f64 {
        // 简化的可靠性模型
        (1.0 - self.estimate_packet_loss(message_rate)).max(0.9)
    }
    
    fn estimate_max_connections(&self) -> usize {
        // 基于协议开销估算最大连接数
        match self.name.as_str() {
            "MQTT" => 10000,
            "CoAP" => 100000,
            "HTTP" => 1000,
            "LoRaWAN" => 1000000,
            _ => 1000,
        }
    }
}
```

## 5.1.3.2 MQTT协议 / MQTT Protocol

### 5.1.3.2.1 MQTT基础 / MQTT Fundamentals

**MQTT v5.0 协议架构：**

```rust
use std::collections::HashMap;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{mpsc, RwLock};
use bytes::{Buf, BufMut, Bytes, BytesMut};

#[derive(Debug, Clone, PartialEq)]
pub enum QoS {
    AtMostOnce = 0,   // 最多一次
    AtLeastOnce = 1,  // 至少一次  
    ExactlyOnce = 2,  // 恰好一次
}

#[derive(Debug, Clone)]
pub struct MqttMessage {
    pub topic: String,
    pub payload: Bytes,
    pub qos: QoS,
    pub retain: bool,
    pub duplicate: bool,
    pub packet_id: Option<u16>,
    pub properties: HashMap<u8, Bytes>, // MQTT v5.0 properties
}

#[derive(Debug, Clone)]
pub struct MqttClient {
    pub client_id: String,
    pub username: Option<String>,
    pub password: Option<Bytes>,
    pub keep_alive: u16,
    pub clean_session: bool,
    pub will_message: Option<MqttMessage>,
    pub subscriptions: HashMap<String, QoS>,
}

#[derive(Debug)]
pub struct MqttBroker {
    clients: RwLock<HashMap<String, MqttClient>>,
    subscriptions: RwLock<HashMap<String, Vec<String>>>, // topic -> client_ids
    retained_messages: RwLock<HashMap<String, MqttMessage>>,
    message_sender: mpsc::UnboundedSender<(String, MqttMessage)>,
}

impl MqttBroker {
    pub fn new() -> Self {
        let (sender, mut receiver) = mpsc::unbounded_channel();
        
        // 消息分发任务
        tokio::spawn(async move {
            while let Some((client_id, message)) = receiver.recv().await {
                // 处理消息分发逻辑
                println!("Distributing message from {} to topic {}", 
                        client_id, message.topic);
            }
        });
        
        Self {
            clients: RwLock::new(HashMap::new()),
            subscriptions: RwLock::new(HashMap::new()),
            retained_messages: RwLock::new(HashMap::new()),
            message_sender: sender,
        }
    }
    
    pub async fn handle_connect(&self, client: MqttClient) -> Result<(), &'static str> {
        let mut clients = self.clients.write().await;
        
        // 检查客户端ID冲突
        if clients.contains_key(&client.client_id) && !client.clean_session {
            return Err("Client ID already in use");
        }
        
        clients.insert(client.client_id.clone(), client);
        Ok(())
    }
    
    pub async fn handle_subscribe(&self, 
                                client_id: &str, 
                                topic_filter: &str, 
                                qos: QoS) -> Result<(), &'static str> {
        let mut subscriptions = self.subscriptions.write().await;
        let mut clients = self.clients.write().await;
        
        // 更新客户端订阅
        if let Some(client) = clients.get_mut(client_id) {
            client.subscriptions.insert(topic_filter.to_string(), qos);
        }
        
        // 更新主题订阅者列表
        subscriptions.entry(topic_filter.to_string())
                    .or_insert_with(Vec::new)
                    .push(client_id.to_string());
        
        // 发送保留消息
        self.send_retained_messages(client_id, topic_filter).await;
        
        Ok(())
    }
    
    pub async fn handle_publish(&self, 
                              client_id: &str, 
                              message: MqttMessage) -> Result<(), &'static str> {
        // 处理保留消息
        if message.retain {
            let mut retained = self.retained_messages.write().await;
            if message.payload.is_empty() {
                retained.remove(&message.topic);
            } else {
                retained.insert(message.topic.clone(), message.clone());
            }
        }
        
        // 发送给订阅者
        self.distribute_message(client_id, message).await
    }
    
    async fn distribute_message(&self, 
                              from_client: &str, 
                              message: MqttMessage) -> Result<(), &'static str> {
        let subscriptions = self.subscriptions.read().await;
        
        // 查找匹配的订阅者
        for (topic_filter, subscribers) in subscriptions.iter() {
            if self.topic_matches(topic_filter, &message.topic) {
                for subscriber in subscribers {
                    if subscriber != from_client { // 不发送给发送者
                        if let Err(_) = self.message_sender.send((subscriber.clone(), message.clone())) {
                            eprintln!("Failed to send message to {}", subscriber);
                        }
                    }
                }
            }
        }
        
        Ok(())
    }
    
    fn topic_matches(&self, filter: &str, topic: &str) -> bool {
        // MQTT主题匹配实现
        if filter == topic {
            return true;
        }
        
        // 处理通配符
        if filter.contains('#') || filter.contains('+') {
            self.wildcard_match(filter, topic)
        } else {
            false
        }
    }
    
    fn wildcard_match(&self, filter: &str, topic: &str) -> bool {
        // 简化的通配符匹配实现
        let filter_parts: Vec<&str> = filter.split('/').collect();
        let topic_parts: Vec<&str> = topic.split('/').collect();
        
        self.match_parts(&filter_parts, &topic_parts, 0, 0)
    }
    
    fn match_parts(&self, filter: &[&str], topic: &[&str], fi: usize, ti: usize) -> bool {
        if fi >= filter.len() {
            return ti >= topic.len();
        }
        
        match filter[fi] {
            "#" => true, // 多级通配符匹配剩余所有级别
            "+" => {     // 单级通配符
                if ti >= topic.len() {
                    false
                } else {
                    self.match_parts(filter, topic, fi + 1, ti + 1)
                }
            }
            exact => {
                if ti >= topic.len() || topic[ti] != exact {
                    false
                } else {
                    self.match_parts(filter, topic, fi + 1, ti + 1)
                }
            }
        }
    }
    
    async fn send_retained_messages(&self, client_id: &str, topic_filter: &str) {
        let retained = self.retained_messages.read().await;
        
        for (topic, message) in retained.iter() {
            if self.topic_matches(topic_filter, topic) {
                if let Err(_) = self.message_sender.send((client_id.to_string(), message.clone())) {
                    eprintln!("Failed to send retained message to {}", client_id);
                }
            }
        }
    }
}
```

### 5.1.3.2.2 MQTT QoS实现 / MQTT QoS Implementation

**QoS消息传递保证：**

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::time::{interval, timeout};

#[derive(Debug, Clone)]
pub struct PendingMessage {
    pub message: MqttMessage,
    pub timestamp: Instant,
    pub retry_count: u8,
    pub max_retries: u8,
}

#[derive(Debug)]
pub struct QoSManager {
    // QoS 1: 等待PUBACK的消息
    pending_puback: HashMap<u16, PendingMessage>,
    // QoS 2: 等待PUBREC的消息  
    pending_pubrec: HashMap<u16, PendingMessage>,
    // QoS 2: 等待PUBCOMP的消息
    pending_pubcomp: HashMap<u16, PendingMessage>,
    next_packet_id: u16,
    retry_interval: Duration,
}

impl QoSManager {
    pub fn new() -> Self {
        Self {
            pending_puback: HashMap::new(),
            pending_pubrec: HashMap::new(), 
            pending_pubcomp: HashMap::new(),
            next_packet_id: 1,
            retry_interval: Duration::from_secs(5),
        }
    }
    
    pub fn next_packet_id(&mut self) -> u16 {
        let id = self.next_packet_id;
        self.next_packet_id = if self.next_packet_id == 65535 { 1 } else { self.next_packet_id + 1 };
        id
    }
    
    // QoS 1: 发送消息并等待确认
    pub async fn publish_qos1(&mut self, 
                             mut message: MqttMessage,
                             sender: &mpsc::UnboundedSender<MqttMessage>) -> Result<(), &'static str> {
        let packet_id = self.next_packet_id();
        message.packet_id = Some(packet_id);
        
        // 发送消息
        sender.send(message.clone()).map_err(|_| "Failed to send message")?;
        
        // 记录待确认消息
        self.pending_puback.insert(packet_id, PendingMessage {
            message,
            timestamp: Instant::now(),
            retry_count: 0,
            max_retries: 3,
        });
        
        Ok(())
    }
    
    // QoS 2: 四步握手协议
    pub async fn publish_qos2(&mut self,
                             mut message: MqttMessage,
                             sender: &mpsc::UnboundedSender<MqttMessage>) -> Result<(), &'static str> {
        let packet_id = self.next_packet_id();
        message.packet_id = Some(packet_id);
        
        // 步骤1: 发送PUBLISH消息
        sender.send(message.clone()).map_err(|_| "Failed to send PUBLISH")?;
        
        // 记录等待PUBREC的消息
        self.pending_pubrec.insert(packet_id, PendingMessage {
            message,
            timestamp: Instant::now(),
            retry_count: 0,
            max_retries: 3,
        });
        
        Ok(())
    }
    
    // 处理PUBACK确认 (QoS 1)
    pub fn handle_puback(&mut self, packet_id: u16) -> Result<(), &'static str> {
        if self.pending_puback.remove(&packet_id).is_some() {
            println!("QoS 1 message {} acknowledged", packet_id);
            Ok(())
        } else {
            Err("Unexpected PUBACK")
        }
    }
    
    // 处理PUBREC确认 (QoS 2 步骤2)
    pub fn handle_pubrec(&mut self, 
                        packet_id: u16,
                        sender: &mpsc::UnboundedSender<MqttMessage>) -> Result<(), &'static str> {
        if self.pending_pubrec.remove(&packet_id).is_some() {
            // 发送PUBREL (步骤3)
            let pubrel = MqttMessage {
                topic: String::new(),
                payload: Bytes::new(),
                qos: QoS::AtLeastOnce,
                retain: false,
                duplicate: false,
                packet_id: Some(packet_id),
                properties: HashMap::new(),
            };
            
            sender.send(pubrel).map_err(|_| "Failed to send PUBREL")?;
            
            // 等待PUBCOMP
            self.pending_pubcomp.insert(packet_id, PendingMessage {
                message: MqttMessage {
                    topic: String::new(),
                    payload: Bytes::new(),
                    qos: QoS::ExactlyOnce,
                    retain: false,
                    duplicate: false,
                    packet_id: Some(packet_id),
                    properties: HashMap::new(),
                },
                timestamp: Instant::now(),
                retry_count: 0,
                max_retries: 3,
            });
            
            Ok(())
        } else {
            Err("Unexpected PUBREC")
        }
    }
    
    // 处理PUBCOMP确认 (QoS 2 步骤4)
    pub fn handle_pubcomp(&mut self, packet_id: u16) -> Result<(), &'static str> {
        if self.pending_pubcomp.remove(&packet_id).is_some() {
            println!("QoS 2 message {} completed", packet_id);
            Ok(())
        } else {
            Err("Unexpected PUBCOMP")
        }
    }
    
    // 重传超时消息
    pub async fn retry_pending_messages(&mut self, 
                                      sender: &mpsc::UnboundedSender<MqttMessage>) {
        let now = Instant::now();
        let mut to_retry = Vec::new();
        
        // 检查QoS 1消息
        for (packet_id, pending) in &mut self.pending_puback {
            if now.duration_since(pending.timestamp) >= self.retry_interval {
                if pending.retry_count < pending.max_retries {
                    pending.retry_count += 1;
                    pending.timestamp = now;
                    to_retry.push((pending.message.clone(), QoS::AtLeastOnce));
                } else {
                    to_retry.push((*packet_id, QoS::AtMostOnce)); // 标记为删除
                }
            }
        }
        
        // 检查QoS 2消息
        for (packet_id, pending) in &mut self.pending_pubrec {
            if now.duration_since(pending.timestamp) >= self.retry_interval {
                if pending.retry_count < pending.max_retries {
                    pending.retry_count += 1;
                    pending.timestamp = now;
                    to_retry.push((pending.message.clone(), QoS::ExactlyOnce));
                } else {
                    to_retry.push((*packet_id, QoS::AtMostOnce)); // 标记为删除
                }
            }
        }
        
        // 执行重传
        for (item, qos) in to_retry {
            match qos {
                QoS::AtLeastOnce => {
                    if let (message, _) = item {
                        let mut retry_msg = message;
                        retry_msg.duplicate = true;
                        let _ = sender.send(retry_msg);
                    }
                }
                QoS::ExactlyOnce => {
                    if let (message, _) = item {
                        let mut retry_msg = message;
                        retry_msg.duplicate = true;
                        let _ = sender.send(retry_msg);
                    }
                }
                QoS::AtMostOnce => {
                    // 删除超时的消息
                    if let (packet_id, _) = item {
                        self.pending_puback.remove(&packet_id);
                        self.pending_pubrec.remove(&packet_id);
                        println!("Message {} dropped after max retries", packet_id);
                    }
                }
            }
        }
    }
}
```

## 5.1.3.3 CoAP协议 / CoAP Protocol

### 5.1.3.3.1 CoAP基础 / CoAP Fundamentals

**CoAP (Constrained Application Protocol) 实现：**

```rust
use std::collections::HashMap;
use std::net::SocketAddr;
use tokio::net::UdpSocket;
use bytes::{Buf, BufMut, Bytes, BytesMut};

#[derive(Debug, Clone, PartialEq)]
pub enum CoapType {
    Confirmable = 0,    // CON
    NonConfirmable = 1, // NON  
    Acknowledgment = 2, // ACK
    Reset = 3,          // RST
}

#[derive(Debug, Clone, PartialEq)]
pub enum CoapCode {
    // Request Methods
    Get = 1,
    Post = 2,
    Put = 3,
    Delete = 4,
    
    // Response Codes  
    Created = 65,        // 2.01
    Deleted = 66,        // 2.02
    Valid = 67,          // 2.03
    Changed = 68,        // 2.04
    Content = 69,        // 2.05
    
    BadRequest = 128,    // 4.00
    Unauthorized = 129,  // 4.01
    BadOption = 130,     // 4.02
    Forbidden = 131,     // 4.03
    NotFound = 132,      // 4.04
    
    InternalServerError = 160, // 5.00
    NotImplemented = 161,      // 5.01
    BadGateway = 162,          // 5.02
    ServiceUnavailable = 163,  // 5.03
    GatewayTimeout = 164,      // 5.04
}

#[derive(Debug, Clone)]
pub struct CoapOption {
    pub number: u16,
    pub value: Bytes,
}

#[derive(Debug, Clone)]
pub struct CoapMessage {
    pub version: u8,        // 固定为1
    pub msg_type: CoapType,
    pub token_length: u8,   // 0-8字节
    pub code: CoapCode,
    pub message_id: u16,
    pub token: Bytes,
    pub options: Vec<CoapOption>,
    pub payload: Bytes,
}

impl CoapMessage {
    pub fn new(msg_type: CoapType, code: CoapCode) -> Self {
        Self {
            version: 1,
            msg_type,
            token_length: 0,
            code,
            message_id: 0,
            token: Bytes::new(),
            options: Vec::new(),
            payload: Bytes::new(),
        }
    }
    
    pub fn encode(&self) -> Result<Bytes, &'static str> {
        let mut buf = BytesMut::new();
        
        // Header (4 bytes)
        let header = (self.version << 6) | 
                    ((self.msg_type as u8) << 4) |
                    (self.token_length & 0x0F);
        buf.put_u8(header);
        buf.put_u8(self.code as u8);
        buf.put_u16(self.message_id);
        
        // Token
        buf.put(self.token.clone());
        
        // Options (按number排序)
        let mut sorted_options = self.options.clone();
        sorted_options.sort_by_key(|opt| opt.number);
        
        let mut prev_number = 0u16;
        for option in sorted_options {
            let delta = option.number - prev_number;
            self.encode_option(&mut buf, delta, &option.value)?;
            prev_number = option.number;
        }
        
        // Payload Marker and Payload
        if !self.payload.is_empty() {
            buf.put_u8(0xFF); // Payload marker
            buf.put(self.payload.clone());
        }
        
        Ok(buf.freeze())
    }
    
    fn encode_option(&self, buf: &mut BytesMut, delta: u16, value: &Bytes) -> Result<(), &'static str> {
        let length = value.len();
        
        // 编码Option Delta和Length
        let (delta_nibble, delta_extended) = self.encode_option_value(delta)?;
        let (length_nibble, length_extended) = self.encode_option_value(length as u16)?;
        
        // Option header
        buf.put_u8((delta_nibble << 4) | length_nibble);
        
        // Extended fields
        buf.put(delta_extended);
        buf.put(length_extended);
        
        // Option value
        buf.put(value.clone());
        
        Ok(())
    }
    
    fn encode_option_value(&self, value: u16) -> Result<(u8, Bytes), &'static str> {
        let mut extended = BytesMut::new();
        let nibble = if value < 13 {
            value as u8
        } else if value < 269 {
            extended.put_u8((value - 13) as u8);
            13
        } else if value < 65804 {
            extended.put_u16(value - 269);
            14
        } else {
            return Err("Option value too large");
        };
        
        Ok((nibble, extended.freeze()))
    }
    
    pub fn decode(data: &[u8]) -> Result<Self, &'static str> {
        if data.len() < 4 {
            return Err("Message too short");
        }
        
        let mut buf = &data[..];
        
        // Header
        let header = buf.get_u8();
        let version = (header >> 6) & 0x03;
        let msg_type = match (header >> 4) & 0x03 {
            0 => CoapType::Confirmable,
            1 => CoapType::NonConfirmable,
            2 => CoapType::Acknowledgment,
            3 => CoapType::Reset,
            _ => return Err("Invalid message type"),
        };
        let token_length = header & 0x0F;
        
        if version != 1 {
            return Err("Unsupported version");
        }
        
        let code = match buf.get_u8() {
            1 => CoapCode::Get,
            2 => CoapCode::Post,
            3 => CoapCode::Put,
            4 => CoapCode::Delete,
            69 => CoapCode::Content,
            132 => CoapCode::NotFound,
            _ => return Err("Unknown code"),
        };
        
        let message_id = buf.get_u16();
        
        // Token
        if buf.remaining() < token_length as usize {
            return Err("Invalid token length");
        }
        let token = Bytes::copy_from_slice(&buf[..token_length as usize]);
        buf.advance(token_length as usize);
        
        // Options and Payload
        let mut options = Vec::new();
        let mut option_number = 0u16;
        
        while buf.remaining() > 0 {
            let first_byte = buf[0];
            
            // Payload marker
            if first_byte == 0xFF {
                buf.advance(1);
                break;
            }
            
            // Parse option
            let (delta, length) = self.decode_option_header(&mut buf)?;
            option_number += delta;
            
            if buf.remaining() < length as usize {
                return Err("Invalid option length");
            }
            
            let value = Bytes::copy_from_slice(&buf[..length as usize]);
            buf.advance(length as usize);
            
            options.push(CoapOption {
                number: option_number,
                value,
            });
        }
        
        // Remaining data is payload
        let payload = Bytes::copy_from_slice(buf);
        
        Ok(CoapMessage {
            version,
            msg_type,
            token_length,
            code,
            message_id,
            token,
            options,
            payload,
        })
    }
    
    fn decode_option_header(&self, buf: &mut &[u8]) -> Result<(u16, u16), &'static str> {
        if buf.is_empty() {
            return Err("Empty buffer");
        }
        
        let header = buf.get_u8();
        let delta_nibble = (header >> 4) & 0x0F;
        let length_nibble = header & 0x0F;
        
        let delta = self.decode_option_value(delta_nibble, buf)?;
        let length = self.decode_option_value(length_nibble, buf)?;
        
        Ok((delta, length))
    }
    
    fn decode_option_value(&self, nibble: u8, buf: &mut &[u8]) -> Result<u16, &'static str> {
        match nibble {
            0..=12 => Ok(nibble as u16),
            13 => {
                if buf.is_empty() {
                    return Err("Buffer underflow");
                }
                Ok(buf.get_u8() as u16 + 13)
            }
            14 => {
                if buf.remaining() < 2 {
                    return Err("Buffer underflow");
                }
                Ok(buf.get_u16() + 269)
            }
            15 => Err("Reserved option value"),
            _ => Err("Invalid option value"),
        }
    }
}

#[derive(Debug)]
pub struct CoapServer {
    socket: UdpSocket,
    resources: HashMap<String, Box<dyn CoapResource + Send + Sync>>,
}

pub trait CoapResource {
    fn handle_get(&self, request: &CoapMessage) -> Result<CoapMessage, CoapCode>;
    fn handle_post(&self, request: &CoapMessage) -> Result<CoapMessage, CoapCode>;
    fn handle_put(&self, request: &CoapMessage) -> Result<CoapMessage, CoapCode>;
    fn handle_delete(&self, request: &CoapMessage) -> Result<CoapMessage, CoapCode>;
}

impl CoapServer {
    pub async fn new(addr: SocketAddr) -> Result<Self, Box<dyn std::error::Error>> {
        let socket = UdpSocket::bind(addr).await?;
        
        Ok(Self {
            socket,
            resources: HashMap::new(),
        })
    }
    
    pub fn register_resource(&mut self, path: String, resource: Box<dyn CoapResource + Send + Sync>) {
        self.resources.insert(path, resource);
    }
    
    pub async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut buf = [0u8; 1024];
        
        loop {
            let (len, addr) = self.socket.recv_from(&mut buf).await?;
            let data = &buf[..len];
            
            if let Ok(request) = CoapMessage::decode(data) {
                let response = self.handle_request(&request).await;
                
                if let Ok(response_data) = response.encode() {
                    let _ = self.socket.send_to(&response_data, addr).await;
                }
            }
        }
    }
    
    async fn handle_request(&self, request: &CoapMessage) -> CoapMessage {
        // 提取URI-Path选项
        let mut path = String::new();
        for option in &request.options {
            if option.number == 11 { // URI-Path
                if !path.is_empty() {
                    path.push('/');
                }
                path.push_str(&String::from_utf8_lossy(&option.value));
            }
        }
        
        if let Some(resource) = self.resources.get(&path) {
            let result = match request.code {
                CoapCode::Get => resource.handle_get(request),
                CoapCode::Post => resource.handle_post(request),
                CoapCode::Put => resource.handle_put(request),
                CoapCode::Delete => resource.handle_delete(request),
                _ => Err(CoapCode::BadRequest),
            };
            
            match result {
                Ok(mut response) => {
                    response.message_id = request.message_id;
                    response.token = request.token.clone();
                    response.msg_type = if request.msg_type == CoapType::Confirmable {
                        CoapType::Acknowledgment
                    } else {
                        CoapType::NonConfirmable
                    };
                    response
                }
                Err(error_code) => {
                    let mut error_response = CoapMessage::new(CoapType::Acknowledgment, error_code);
                    error_response.message_id = request.message_id;
                    error_response.token = request.token.clone();
                    error_response
                }
            }
        } else {
            let mut not_found = CoapMessage::new(CoapType::Acknowledgment, CoapCode::NotFound);
            not_found.message_id = request.message_id;
            not_found.token = request.token.clone();
            not_found
        }
    }
}
```

## 5.1.3.4 LoRaWAN协议 / LoRaWAN Protocol

### 5.1.3.4.1 LoRaWAN架构 / LoRaWAN Architecture

**LoRaWAN网络架构：**

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LoRaWANClass {
    ClassA,  // 最低功耗，双向通信
    ClassB,  // 中等功耗，定时接收窗口
    ClassC,  // 高功耗，持续接收
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LoRaWANMessageType {
    JoinRequest,
    JoinAccept,
    UnconfirmedDataUp,
    UnconfirmedDataDown,
    ConfirmedDataUp,
    ConfirmedDataDown,
    RejoinRequest,
    Proprietary,
}

#[derive(Debug, Clone)]
pub struct LoRaWANDevice {
    pub dev_eui: [u8; 8],      // 设备唯一标识符
    pub app_eui: [u8; 8],      // 应用唯一标识符
    pub app_key: [u8; 16],     // 应用密钥
    pub dev_addr: Option<[u8; 4]>, // 设备地址 (入网后分配)
    pub nwk_s_key: Option<[u8; 16]>, // 网络会话密钥
    pub app_s_key: Option<[u8; 16]>, // 应用会话密钥
    pub device_class: LoRaWANClass,
    pub fcnt_up: u32,          // 上行帧计数器
    pub fcnt_down: u32,        // 下行帧计数器
    pub joined: bool,
}

#[derive(Debug, Clone)]
pub struct LoRaWANMessage {
    pub mhdr: u8,              // MAC Header
    pub payload: Vec<u8>,      // MAC Payload
    pub mic: [u8; 4],          // Message Integrity Code
}

#[derive(Debug, Clone)]
pub struct LoRaWANFrameHeader {
    pub dev_addr: [u8; 4],
    pub fctrl: u8,             // Frame Control
    pub fcnt: u16,             // Frame Counter
    pub fopts: Vec<u8>,        // Frame Options
}

#[derive(Debug)]
pub struct LoRaWANNetworkServer {
    devices: HashMap<[u8; 8], LoRaWANDevice>, // dev_eui -> device
    gateways: HashMap<[u8; 8], LoRaWANGateway>, // gateway_id -> gateway
    applications: HashMap<[u8; 8], LoRaWANApplication>, // app_eui -> application
}

#[derive(Debug, Clone)]
pub struct LoRaWANGateway {
    pub gateway_id: [u8; 8],
    pub location: (f64, f64),  // (latitude, longitude)
    pub frequency_plan: String,
    pub last_seen: SystemTime,
}

#[derive(Debug, Clone)]
pub struct LoRaWANApplication {
    pub app_eui: [u8; 8],
    pub app_key: [u8; 16],
    pub payload_decoder: String, // JavaScript decoder function
}

impl LoRaWANNetworkServer {
    pub fn new() -> Self {
        Self {
            devices: HashMap::new(),
            gateways: HashMap::new(),
            applications: HashMap::new(),
        }
    }
    
    pub fn register_device(&mut self, device: LoRaWANDevice) {
        self.devices.insert(device.dev_eui, device);
    }
    
    pub fn register_gateway(&mut self, gateway: LoRaWANGateway) {
        self.gateways.insert(gateway.gateway_id, gateway);
    }
    
    pub fn register_application(&mut self, application: LoRaWANApplication) {
        self.applications.insert(application.app_eui, application);
    }
    
    pub fn handle_uplink(&mut self, 
                        gateway_id: [u8; 8], 
                        message: LoRaWANMessage) -> Result<Option<LoRaWANMessage>, &'static str> {
        // 解析消息类型
        let msg_type = self.parse_message_type(message.mhdr)?;
        
        match msg_type {
            LoRaWANMessageType::JoinRequest => {
                self.handle_join_request(gateway_id, message)
            }
            LoRaWANMessageType::UnconfirmedDataUp | 
            LoRaWANMessageType::ConfirmedDataUp => {
                self.handle_data_uplink(gateway_id, message)
            }
            _ => Err("Invalid uplink message type"),
        }
    }
    
    fn handle_join_request(&mut self, 
                          gateway_id: [u8; 8], 
                          message: LoRaWANMessage) -> Result<Option<LoRaWANMessage>, &'static str> {
        // 解析Join Request
        if message.payload.len() < 18 {
            return Err("Invalid join request payload length");
        }
        
        let app_eui = &message.payload[0..8];
        let dev_eui = &message.payload[8..16];
        let dev_nonce = &message.payload[16..18];
        
        // 查找设备
        let mut dev_eui_array = [0u8; 8];
        dev_eui_array.copy_from_slice(dev_eui);
        
        if let Some(device) = self.devices.get_mut(&dev_eui_array) {
            // 验证MIC
            if !self.verify_join_request_mic(device, &message) {
                return Err("Invalid MIC");
            }
            
            // 生成会话密钥
            let join_nonce = self.generate_join_nonce();
            let net_id = [0x00, 0x00, 0x00]; // Network ID
            let dev_addr = self.generate_dev_addr();
            
            device.dev_addr = Some(dev_addr);
            device.nwk_s_key = Some(self.derive_nwk_s_key(&device.app_key, &join_nonce, &net_id, dev_nonce));
            device.app_s_key = Some(self.derive_app_s_key(&device.app_key, &join_nonce, &net_id, dev_nonce));
            device.joined = true;
            device.fcnt_up = 0;
            device.fcnt_down = 0;
            
            // 构造Join Accept
            let join_accept = self.build_join_accept(join_nonce, net_id, dev_addr, device)?;
            Ok(Some(join_accept))
        } else {
            Err("Unknown device")
        }
    }
    
    fn handle_data_uplink(&mut self, 
                         gateway_id: [u8; 8], 
                         message: LoRaWANMessage) -> Result<Option<LoRaWANMessage>, &'static str> {
        // 解析Frame Header
        let fhdr = self.parse_frame_header(&message.payload)?;
        
        // 查找设备
        if let Some(device) = self.find_device_by_addr(fhdr.dev_addr) {
            // 验证MIC
            if !self.verify_data_mic(device, &message) {
                return Err("Invalid MIC");
            }
            
            // 验证Frame Counter (防重放攻击)
            if fhdr.fcnt <= device.fcnt_up as u16 {
                return Err("Invalid frame counter");
            }
            
            device.fcnt_up = fhdr.fcnt as u32;
            
            // 解密载荷
            let decrypted_payload = self.decrypt_payload(device, &message.payload)?;
            
            // 处理MAC命令 (如果存在)
            if !fhdr.fopts.is_empty() {
                self.process_mac_commands(device, &fhdr.fopts)?;
            }
            
            // 转发给应用服务器
            self.forward_to_application_server(device, &decrypted_payload);
            
            // 如果是Confirmed消息，需要发送ACK
            let msg_type = self.parse_message_type(message.mhdr)?;
            if msg_type == LoRaWANMessageType::ConfirmedDataUp {
                let ack = self.build_ack_message(device)?;
                Ok(Some(ack))
            } else {
                Ok(None)
            }
        } else {
            Err("Unknown device address")
        }
    }
    
    fn parse_message_type(&self, mhdr: u8) -> Result<LoRaWANMessageType, &'static str> {
        match (mhdr >> 5) & 0x07 {
            0 => Ok(LoRaWANMessageType::JoinRequest),
            1 => Ok(LoRaWANMessageType::JoinAccept),
            2 => Ok(LoRaWANMessageType::UnconfirmedDataUp),
            3 => Ok(LoRaWANMessageType::UnconfirmedDataDown),
            4 => Ok(LoRaWANMessageType::ConfirmedDataUp),
            5 => Ok(LoRaWANMessageType::ConfirmedDataDown),
            6 => Ok(LoRaWANMessageType::RejoinRequest),
            7 => Ok(LoRaWANMessageType::Proprietary),
            _ => Err("Invalid message type"),
        }
    }
    
    fn parse_frame_header(&self, payload: &[u8]) -> Result<LoRaWANFrameHeader, &'static str> {
        if payload.len() < 7 {
            return Err("Payload too short for frame header");
        }
        
        let mut dev_addr = [0u8; 4];
        dev_addr.copy_from_slice(&payload[0..4]);
        
        let fctrl = payload[4];
        let fcnt = u16::from_le_bytes([payload[5], payload[6]]);
        
        let fopts_len = (fctrl & 0x0F) as usize;
        if payload.len() < 7 + fopts_len {
            return Err("Invalid frame options length");
        }
        
        let fopts = payload[7..7+fopts_len].to_vec();
        
        Ok(LoRaWANFrameHeader {
            dev_addr,
            fctrl,
            fcnt,
            fopts,
        })
    }
    
    fn find_device_by_addr(&mut self, dev_addr: [u8; 4]) -> Option<&mut LoRaWANDevice> {
        self.devices.values_mut()
            .find(|device| device.dev_addr == Some(dev_addr))
    }
    
    fn verify_join_request_mic(&self, device: &LoRaWANDevice, message: &LoRaWANMessage) -> bool {
        // 使用AES-128 CMAC计算MIC
        // 这是简化实现，实际需要使用专门的密码学库
        true // 假设验证通过
    }
    
    fn verify_data_mic(&self, device: &LoRaWANDevice, message: &LoRaWANMessage) -> bool {
        // 使用网络会话密钥验证MIC
        true // 假设验证通过
    }
    
    fn generate_join_nonce(&self) -> [u8; 3] {
        // 生成随机的3字节Join Nonce
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let nonce = now.as_secs() as u32;
        [
            (nonce & 0xFF) as u8,
            ((nonce >> 8) & 0xFF) as u8,
            ((nonce >> 16) & 0xFF) as u8,
        ]
    }
    
    fn generate_dev_addr(&self) -> [u8; 4] {
        // 生成设备地址 (网络ID + 设备地址)
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let addr = now.as_secs() as u32;
        addr.to_le_bytes()
    }
    
    fn derive_nwk_s_key(&self, app_key: &[u8; 16], join_nonce: &[u8; 3], 
                       net_id: &[u8; 3], dev_nonce: &[u8; 2]) -> [u8; 16] {
        // 使用AES-128加密派生网络会话密钥
        // 这是简化实现
        *app_key // 实际应该使用密钥派生函数
    }
    
    fn derive_app_s_key(&self, app_key: &[u8; 16], join_nonce: &[u8; 3], 
                       net_id: &[u8; 3], dev_nonce: &[u8; 2]) -> [u8; 16] {
        // 使用AES-128加密派生应用会话密钥
        *app_key // 实际应该使用密钥派生函数
    }
    
    fn build_join_accept(&self, join_nonce: [u8; 3], net_id: [u8; 3], 
                        dev_addr: [u8; 4], device: &LoRaWANDevice) -> Result<LoRaWANMessage, &'static str> {
        let mut payload = Vec::new();
        
        // Join Accept Payload
        payload.extend_from_slice(&join_nonce);
        payload.extend_from_slice(&net_id);
        payload.extend_from_slice(&dev_addr);
        
        // DL Settings
        payload.push(0x00); // RX1DRoffset=0, RX2DR=0
        
        // RX Delay
        payload.push(0x01); // 1 second
        
        // CFList (可选)
        // ... 频率列表
        
        // 使用应用密钥加密
        let encrypted_payload = self.encrypt_join_accept(&device.app_key, &payload);
        
        // 计算MIC
        let mic = self.calculate_join_accept_mic(&device.app_key, &encrypted_payload);
        
        Ok(LoRaWANMessage {
            mhdr: (LoRaWANMessageType::JoinAccept as u8) << 5,
            payload: encrypted_payload,
            mic,
        })
    }
    
    fn encrypt_join_accept(&self, app_key: &[u8; 16], payload: &[u8]) -> Vec<u8> {
        // 使用AES-128 ECB模式加密
        payload.to_vec() // 简化实现
    }
    
    fn calculate_join_accept_mic(&self, app_key: &[u8; 16], payload: &[u8]) -> [u8; 4] {
        // 使用AES-128 CMAC计算MIC
        [0, 0, 0, 0] // 简化实现
    }
    
    fn decrypt_payload(&self, device: &LoRaWANDevice, payload: &[u8]) -> Result<Vec<u8>, &'static str> {
        // 使用应用会话密钥解密载荷
        Ok(payload.to_vec()) // 简化实现
    }
    
    fn process_mac_commands(&self, device: &mut LoRaWANDevice, fopts: &[u8]) -> Result<(), &'static str> {
        // 处理MAC命令 (LinkCheckReq, LinkADRReq, etc.)
        Ok(())
    }
    
    fn forward_to_application_server(&self, device: &LoRaWANDevice, payload: &[u8]) {
        // 转发解密后的载荷给应用服务器
        println!("Forwarding payload to application server: {:?}", payload);
    }
    
    fn build_ack_message(&self, device: &LoRaWANDevice) -> Result<LoRaWANMessage, &'static str> {
        // 构造确认消息
        let mut payload = Vec::new();
        
        // Frame Header
        payload.extend_from_slice(&device.dev_addr.unwrap());
        payload.push(0x20); // FCtrl: ACK=1
        payload.extend_from_slice(&(device.fcnt_down as u16).to_le_bytes());
        
        // 计算MIC
        let mic = [0, 0, 0, 0]; // 简化实现
        
        Ok(LoRaWANMessage {
            mhdr: (LoRaWANMessageType::UnconfirmedDataDown as u8) << 5,
            payload,
            mic,
        })
    }
}
```

## 5.1.3.5 协议互操作性 / Protocol Interoperability

### 5.1.3.5.1 协议桥接 / Protocol Bridging

**多协议网关实现：**

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, mpsc};
use serde_json::Value;

#[derive(Debug, Clone)]
pub enum ProtocolType {
    MQTT,
    CoAP,
    HTTP,
    LoRaWAN,
    WebSocket,
    Modbus,
    OPCUA,
}

#[derive(Debug, Clone)]
pub struct UniversalMessage {
    pub source_protocol: ProtocolType,
    pub target_protocol: ProtocolType,
    pub device_id: String,
    pub topic: String,
    pub payload: Value,
    pub timestamp: u64,
    pub qos: u8,
    pub metadata: HashMap<String, Value>,
}

pub trait ProtocolAdapter: Send + Sync {
    fn protocol_type(&self) -> ProtocolType;
    fn parse_message(&self, data: &[u8]) -> Result<UniversalMessage, Box<dyn std::error::Error>>;
    fn encode_message(&self, message: &UniversalMessage) -> Result<Vec<u8>, Box<dyn std::error::Error>>;
    fn get_addressing(&self, message: &UniversalMessage) -> String;
}

#[derive(Debug)]
pub struct ProtocolBridge {
    adapters: HashMap<ProtocolType, Arc<dyn ProtocolAdapter>>,
    routing_rules: Vec<RoutingRule>,
    message_sender: mpsc::UnboundedSender<UniversalMessage>,
}

#[derive(Debug, Clone)]
pub struct RoutingRule {
    pub source_protocol: ProtocolType,
    pub target_protocol: ProtocolType,
    pub source_pattern: String,
    pub target_pattern: String,
    pub transformation: Option<String>, // JavaScript transformation function
}

impl ProtocolBridge {
    pub fn new() -> Self {
        let (sender, mut receiver) = mpsc::unbounded_channel();
        
        // 消息处理任务
        tokio::spawn(async move {
            while let Some(message) = receiver.recv().await {
                println!("Processing bridged message: {:?}", message);
                // 实际处理消息路由和转发
            }
        });
        
        Self {
            adapters: HashMap::new(),
            routing_rules: Vec::new(),
            message_sender: sender,
        }
    }
    
    pub fn register_adapter(&mut self, adapter: Arc<dyn ProtocolAdapter>) {
        let protocol_type = adapter.protocol_type();
        self.adapters.insert(protocol_type, adapter);
    }
    
    pub fn add_routing_rule(&mut self, rule: RoutingRule) {
        self.routing_rules.push(rule);
    }
    
    pub async fn bridge_message(&self, 
                               source_protocol: ProtocolType, 
                               data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
        // 解析源协议消息
        let source_adapter = self.adapters.get(&source_protocol)
            .ok_or("Source protocol adapter not found")?;
        
        let mut message = source_adapter.parse_message(data)?;
        
        // 查找匹配的路由规则
        for rule in &self.routing_rules {
            if rule.source_protocol == source_protocol && 
               self.pattern_matches(&rule.source_pattern, &message.topic) {
                
                // 应用转换规则
                if let Some(transformation) = &rule.transformation {
                    message = self.apply_transformation(&message, transformation)?;
                }
                
                // 设置目标协议
                message.target_protocol = rule.target_protocol.clone();
                message.topic = self.apply_pattern_substitution(&rule.target_pattern, &message.topic);
                
                // 编码为目标协议格式
                let target_adapter = self.adapters.get(&rule.target_protocol)
                    .ok_or("Target protocol adapter not found")?;
                
                let encoded_data = target_adapter.encode_message(&message)?;
                
                // 发送消息
                self.send_to_target_protocol(rule.target_protocol.clone(), encoded_data).await?;
                
                // 记录转发的消息
                if let Err(_) = self.message_sender.send(message.clone()) {
                    eprintln!("Failed to log bridged message");
                }
            }
        }
        
        Ok(())
    }
    
    fn pattern_matches(&self, pattern: &str, topic: &str) -> bool {
        // 简化的模式匹配实现
        if pattern.contains('*') {
            // 通配符匹配
            let pattern_parts: Vec<&str> = pattern.split('*').collect();
            if pattern_parts.len() == 2 {
                topic.starts_with(pattern_parts[0]) && topic.ends_with(pattern_parts[1])
            } else {
                false
            }
        } else {
            pattern == topic
        }
    }
    
    fn apply_pattern_substitution(&self, pattern: &str, source_topic: &str) -> String {
        // 简化的模式替换实现
        pattern.replace("{topic}", source_topic)
    }
    
    fn apply_transformation(&self, 
                          message: &UniversalMessage, 
                          transformation: &str) -> Result<UniversalMessage, Box<dyn std::error::Error>> {
        // 简化的JavaScript转换实现
        // 实际应该使用JavaScript引擎如QuickJS
        let mut transformed = message.clone();
        
        // 示例转换：温度单位转换
        if transformation.contains("celsius_to_fahrenheit") {
            if let Some(temp) = message.payload.get("temperature") {
                if let Some(celsius) = temp.as_f64() {
                    let fahrenheit = celsius * 9.0 / 5.0 + 32.0;
                    transformed.payload = serde_json::json!({
                        "temperature": fahrenheit,
                        "unit": "fahrenheit"
                    });
                }
            }
        }
        
        Ok(transformed)
    }
    
    async fn send_to_target_protocol(&self, 
                                   protocol: ProtocolType, 
                                   data: Vec<u8>) -> Result<(), Box<dyn std::error::Error>> {
        match protocol {
            ProtocolType::MQTT => {
                // 发送到MQTT Broker
                println!("Sending to MQTT: {:?}", data);
            }
            ProtocolType::CoAP => {
                // 发送CoAP请求
                println!("Sending to CoAP: {:?}", data);
            }
            ProtocolType::HTTP => {
                // 发送HTTP请求
                println!("Sending to HTTP: {:?}", data);
            }
            ProtocolType::LoRaWAN => {
                // 发送到LoRaWAN网关
                println!("Sending to LoRaWAN: {:?}", data);
            }
            _ => {
                return Err("Unsupported target protocol".into());
            }
        }
        
        Ok(())
    }
}

// MQTT适配器实现
pub struct MQTTAdapter;

impl ProtocolAdapter for MQTTAdapter {
    fn protocol_type(&self) -> ProtocolType {
        ProtocolType::MQTT
    }
    
    fn parse_message(&self, data: &[u8]) -> Result<UniversalMessage, Box<dyn std::error::Error>> {
        // 解析MQTT消息 (简化实现)
        let message_str = String::from_utf8(data.to_vec())?;
        let parts: Vec<&str> = message_str.splitn(2, ':').collect();
        
        if parts.len() != 2 {
            return Err("Invalid MQTT message format".into());
        }
        
        Ok(UniversalMessage {
            source_protocol: ProtocolType::MQTT,
            target_protocol: ProtocolType::MQTT,
            device_id: "mqtt_device".to_string(),
            topic: parts[0].to_string(),
            payload: serde_json::from_str(parts[1])?,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
            qos: 1,
            metadata: HashMap::new(),
        })
    }
    
    fn encode_message(&self, message: &UniversalMessage) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let encoded = format!("{}:{}", message.topic, message.payload);
        Ok(encoded.into_bytes())
    }
    
    fn get_addressing(&self, message: &UniversalMessage) -> String {
        message.topic.clone()
    }
}

// CoAP适配器实现
pub struct CoapAdapter;

impl ProtocolAdapter for CoapAdapter {
    fn protocol_type(&self) -> ProtocolType {
        ProtocolType::CoAP
    }
    
    fn parse_message(&self, data: &[u8]) -> Result<UniversalMessage, Box<dyn std::error::Error>> {
        // 解析CoAP消息
        let coap_message = CoapMessage::decode(data)
            .map_err(|e| format!("CoAP decode error: {}", e))?;
        
        let payload = if coap_message.payload.is_empty() {
            serde_json::Value::Null
        } else {
            serde_json::from_slice(&coap_message.payload)?
        };
        
        // 从CoAP选项提取URI路径
        let mut topic = String::new();
        for option in &coap_message.options {
            if option.number == 11 { // URI-Path
                if !topic.is_empty() {
                    topic.push('/');
                }
                topic.push_str(&String::from_utf8_lossy(&option.value));
            }
        }
        
        Ok(UniversalMessage {
            source_protocol: ProtocolType::CoAP,
            target_protocol: ProtocolType::CoAP,
            device_id: "coap_device".to_string(),
            topic,
            payload,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
            qos: match coap_message.msg_type {
                CoapType::Confirmable => 1,
                _ => 0,
            },
            metadata: HashMap::new(),
        })
    }
    
    fn encode_message(&self, message: &UniversalMessage) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let mut coap_message = CoapMessage::new(CoapType::NonConfirmable, CoapCode::Content);
        
        // 设置URI路径选项
        let path_parts: Vec<&str> = message.topic.split('/').collect();
        for part in path_parts {
            if !part.is_empty() {
                coap_message.options.push(CoapOption {
                    number: 11, // URI-Path
                    value: Bytes::from(part.as_bytes().to_vec()),
                });
            }
        }
        
        // 设置载荷
        if message.payload != serde_json::Value::Null {
            let payload_bytes = serde_json::to_vec(&message.payload)?;
            coap_message.payload = Bytes::from(payload_bytes);
        }
        
        coap_message.encode()
            .map(|bytes| bytes.to_vec())
            .map_err(|e| format!("CoAP encode error: {}", e).into())
    }
    
    fn get_addressing(&self, message: &UniversalMessage) -> String {
        format!("coap://localhost/{}", message.topic)
    }
}
```

### 5.1.3.5.2 协议性能比较 / Protocol Performance Comparison

**性能基准测试框架：**

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;
use tokio::time::sleep;

#[derive(Debug, Clone)]
pub struct PerformanceTestConfig {
    pub message_count: usize,
    pub message_size: usize,
    pub concurrent_connections: usize,
    pub test_duration: Duration,
    pub qos_level: u8,
}

#[derive(Debug, Clone)]
pub struct PerformanceMetrics {
    pub total_messages: usize,
    pub successful_messages: usize,
    pub failed_messages: usize,
    pub average_latency: Duration,
    pub min_latency: Duration,
    pub max_latency: Duration,
    pub p95_latency: Duration,
    pub p99_latency: Duration,
    pub throughput: f64,           // messages per second
    pub bandwidth: f64,            // bytes per second
    pub error_rate: f64,           // percentage
    pub cpu_usage: f64,            // percentage
    pub memory_usage: f64,         // MB
}

pub struct ProtocolBenchmark {
    results: HashMap<ProtocolType, PerformanceMetrics>,
}

impl ProtocolBenchmark {
    pub fn new() -> Self {
        Self {
            results: HashMap::new(),
        }
    }
    
    pub async fn run_benchmark(&mut self, 
                              protocol: ProtocolType, 
                              config: PerformanceTestConfig) -> Result<PerformanceMetrics, Box<dyn std::error::Error>> {
        println!("Running benchmark for {:?}", protocol);
        
        let start_time = Instant::now();
        let mut latencies = Vec::new();
        let mut successful = 0;
        let mut failed = 0;
        
        // 并发连接测试
        let mut handles = Vec::new();
        
        for connection_id in 0..config.concurrent_connections {
            let config_clone = config.clone();
            let protocol_clone = protocol.clone();
            
            let handle = tokio::spawn(async move {
                Self::run_connection_test(connection_id, protocol_clone, config_clone).await
            });
            
            handles.push(handle);
        }
        
        // 等待所有连接完成
        for handle in handles {
            if let Ok(result) = handle.await {
                if let Ok(metrics) = result {
                    latencies.extend(metrics.0);
                    successful += metrics.1;
                    failed += metrics.2;
                }
            }
        }
        
        let total_duration = start_time.elapsed();
        
        // 计算性能指标
        let metrics = self.calculate_metrics(
            config.message_count * config.concurrent_connections,
            successful,
            failed,
            latencies,
            total_duration,
            config.message_size,
        );
        
        self.results.insert(protocol, metrics.clone());
        Ok(metrics)
    }
    
    async fn run_connection_test(
        connection_id: usize,
        protocol: ProtocolType,
        config: PerformanceTestConfig,
    ) -> Result<(Vec<Duration>, usize, usize), Box<dyn std::error::Error + Send + Sync>> {
        let mut latencies = Vec::new();
        let mut successful = 0;
        let mut failed = 0;
        
        match protocol {
            ProtocolType::MQTT => {
                for i in 0..config.message_count {
                    let start = Instant::now();
                    
                    // 模拟MQTT发布消息
                    let result = Self::simulate_mqtt_publish(
                        &format!("test/topic/{}", i),
                        &vec![0u8; config.message_size],
                        config.qos_level,
                    ).await;
                    
                    let latency = start.elapsed();
                    latencies.push(latency);
                    
                    if result.is_ok() {
                        successful += 1;
                    } else {
                        failed += 1;
                    }
                    
                    // 小延迟避免过载
                    sleep(Duration::from_micros(100)).await;
                }
            }
            ProtocolType::CoAP => {
                for i in 0..config.message_count {
                    let start = Instant::now();
                    
                    // 模拟CoAP请求
                    let result = Self::simulate_coap_request(
                        &format!("test/resource/{}", i),
                        &vec![0u8; config.message_size],
                    ).await;
                    
                    let latency = start.elapsed();
                    latencies.push(latency);
                    
                    if result.is_ok() {
                        successful += 1;
                    } else {
                        failed += 1;
                    }
                    
                    sleep(Duration::from_micros(100)).await;
                }
            }
            ProtocolType::HTTP => {
                for i in 0..config.message_count {
                    let start = Instant::now();
                    
                    // 模拟HTTP请求
                    let result = Self::simulate_http_request(
                        &format!("/api/data/{}", i),
                        &vec![0u8; config.message_size],
                    ).await;
                    
                    let latency = start.elapsed();
                    latencies.push(latency);
                    
                    if result.is_ok() {
                        successful += 1;
                    } else {
                        failed += 1;
                    }
                    
                    sleep(Duration::from_micros(100)).await;
                }
            }
            _ => {
                return Err("Unsupported protocol for benchmarking".into());
            }
        }
        
        Ok((latencies, successful, failed))
    }
    
    async fn simulate_mqtt_publish(
        topic: &str,
        payload: &[u8],
        qos: u8,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // 模拟MQTT发布延迟
        sleep(Duration::from_micros(500 + qos as u64 * 200)).await;
        
        // 模拟一定的失败率
        if payload.len() > 1000 && rand::random::<f32>() < 0.01 {
            Err("Simulated MQTT publish failure".into())
        } else {
            Ok(())
        }
    }
    
    async fn simulate_coap_request(
        path: &str,
        payload: &[u8],
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // 模拟CoAP请求延迟 (通常更低)
        sleep(Duration::from_micros(200)).await;
        
        // 模拟UDP丢包
        if rand::random::<f32>() < 0.005 {
            Err("Simulated CoAP packet loss".into())
        } else {
            Ok(())
        }
    }
    
    async fn simulate_http_request(
        path: &str,
        payload: &[u8],
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // 模拟HTTP请求延迟 (通常较高)
        sleep(Duration::from_millis(2)).await;
        
        // 模拟HTTP错误
        if payload.len() > 5000 && rand::random::<f32>() < 0.02 {
            Err("Simulated HTTP error".into())
        } else {
            Ok(())
        }
    }
    
    fn calculate_metrics(
        &self,
        total_messages: usize,
        successful: usize,
        failed: usize,
        mut latencies: Vec<Duration>,
        total_duration: Duration,
        message_size: usize,
    ) -> PerformanceMetrics {
        latencies.sort();
        
        let average_latency = if !latencies.is_empty() {
            latencies.iter().sum::<Duration>() / latencies.len() as u32
        } else {
            Duration::ZERO
        };
        
        let min_latency = latencies.first().copied().unwrap_or(Duration::ZERO);
        let max_latency = latencies.last().copied().unwrap_or(Duration::ZERO);
        
        let p95_index = (latencies.len() as f64 * 0.95) as usize;
        let p99_index = (latencies.len() as f64 * 0.99) as usize;
        
        let p95_latency = latencies.get(p95_index).copied().unwrap_or(Duration::ZERO);
        let p99_latency = latencies.get(p99_index).copied().unwrap_or(Duration::ZERO);
        
        let throughput = successful as f64 / total_duration.as_secs_f64();
        let bandwidth = (successful * message_size) as f64 / total_duration.as_secs_f64();
        let error_rate = (failed as f64 / total_messages as f64) * 100.0;
        
        PerformanceMetrics {
            total_messages,
            successful_messages: successful,
            failed_messages: failed,
            average_latency,
            min_latency,
            max_latency,
            p95_latency,
            p99_latency,
            throughput,
            bandwidth,
            error_rate,
            cpu_usage: 0.0, // 需要系统监控获取
            memory_usage: 0.0, // 需要系统监控获取
        }
    }
    
    pub fn generate_comparison_report(&self) -> String {
        let mut report = String::new();
        report.push_str("# IoT Protocol Performance Comparison Report\n\n");
        
        report.push_str("| Protocol | Throughput (msg/s) | Avg Latency (ms) | P99 Latency (ms) | Error Rate (%) |\n");
        report.push_str("|----------|-------------------|------------------|------------------|----------------|\n");
        
        for (protocol, metrics) in &self.results {
            report.push_str(&format!(
                "| {:?} | {:.2} | {:.2} | {:.2} | {:.2} |\n",
                protocol,
                metrics.throughput,
                metrics.average_latency.as_millis(),
                metrics.p99_latency.as_millis(),
                metrics.error_rate
            ));
        }
        
        report.push_str("\n## Key Findings\n\n");
        
        // 找出最佳性能协议
        if let Some((best_throughput_protocol, best_throughput_metrics)) = self.results.iter()
            .max_by(|a, b| a.1.throughput.partial_cmp(&b.1.throughput).unwrap()) {
            report.push_str(&format!(
                "- **Highest Throughput**: {:?} with {:.2} messages/second\n",
                best_throughput_protocol, best_throughput_metrics.throughput
            ));
        }
        
        if let Some((best_latency_protocol, best_latency_metrics)) = self.results.iter()
            .min_by(|a, b| a.1.average_latency.cmp(&b.1.average_latency)) {
            report.push_str(&format!(
                "- **Lowest Latency**: {:?} with {:.2}ms average latency\n",
                best_latency_protocol, best_latency_metrics.average_latency.as_millis()
            ));
        }
        
        if let Some((most_reliable_protocol, most_reliable_metrics)) = self.results.iter()
            .min_by(|a, b| a.1.error_rate.partial_cmp(&b.1.error_rate).unwrap()) {
            report.push_str(&format!(
                "- **Most Reliable**: {:?} with {:.2}% error rate\n",
                most_reliable_protocol, most_reliable_metrics.error_rate
            ));
        }
        
        report
    }
}

// 外部rand crate的简化模拟
mod rand {
    use std::time::{SystemTime, UNIX_EPOCH};
    
    pub fn random<T>() -> T 
    where
        T: From<f32>,
    {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let seed = now.as_nanos() as u32;
        let value = (seed % 1000) as f32 / 1000.0;
        T::from(value)
    }
}
```

## 总结 / Summary

本文档全面介绍了物联网协议的各个方面，包括：

1. **协议概述**：物联网协议栈架构和性能建模
2. **MQTT协议**：发布/订阅模式和QoS保证机制
3. **CoAP协议**：轻量级HTTP替代方案
4. **LoRaWAN协议**：远距离低功耗广域网
5. **协议互操作性**：多协议桥接和性能比较

每个协议都有其特定的适用场景和性能特点，选择合适的协议需要考虑设备能力、网络条件、应用需求等多个因素。通过协议桥接技术，可以实现不同协议之间的无缝互操作。

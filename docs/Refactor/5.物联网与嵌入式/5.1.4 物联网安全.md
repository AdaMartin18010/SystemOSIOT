# 5.1.4 物联网安全 / IoT Security


<!-- TOC START -->

- [5.1.4 物联网安全 / IoT Security](#514-物联网安全-iot-security)
  - [5.1.4.1 安全威胁模型 / Security Threat Model](#5141-安全威胁模型-security-threat-model)
    - [5.1.4.1.1 物联网安全架构 / IoT Security Architecture](#51411-物联网安全架构-iot-security-architecture)
  - [5.1.4.2 设备身份认证 / Device Authentication](#5142-设备身份认证-device-authentication)
    - [5.1.4.2.1 设备身份管理 / Device Identity Management](#51421-设备身份管理-device-identity-management)
    - [5.1.4.2.2 轻量级认证协议 / Lightweight Authentication Protocols](#51422-轻量级认证协议-lightweight-authentication-protocols)
  - [5.1.4.3 数据加密与隐私 / Data Encryption and Privacy](#5143-数据加密与隐私-data-encryption-and-privacy)
    - [5.1.4.3.1 端到端加密 / End-to-End Encryption](#51431-端到端加密-end-to-end-encryption)
  - [5.1.4.4 网络安全防护 / Network Security Protection](#5144-网络安全防护-network-security-protection)
    - [5.1.4.4.1 入侵检测系统 / Intrusion Detection System](#51441-入侵检测系统-intrusion-detection-system)
  - [总结 / Summary](#总结-summary)

<!-- TOC END -->

## 5.1.4.1 安全威胁模型 / Security Threat Model

### 5.1.4.1.1 物联网安全架构 / IoT Security Architecture

**分层安全模型：**

```text
应用层安全 (Application Layer Security)
    ├── 应用程序安全 (Application Security)
    ├── 数据隐私保护 (Data Privacy Protection)
    ├── 用户身份管理 (User Identity Management)
    └── 业务逻辑安全 (Business Logic Security)

网络层安全 (Network Layer Security)
    ├── 传输加密 (Transport Encryption)
    ├── 网络访问控制 (Network Access Control)
    ├── 入侵检测防护 (Intrusion Detection/Prevention)
    └── 网络隔离 (Network Segmentation)

设备层安全 (Device Layer Security)
    ├── 设备身份认证 (Device Authentication)
    ├── 安全启动 (Secure Boot)
    ├── 固件保护 (Firmware Protection)
    └── 硬件安全模块 (Hardware Security Module)

物理层安全 (Physical Layer Security)
    ├── 物理防护 (Physical Protection)
    ├── 防篡改机制 (Tamper Protection)
    ├── 侧信道攻击防护 (Side-Channel Attack Protection)
    └── 供应链安全 (Supply Chain Security)
```

**威胁分类和风险评估：**

```rust
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum ThreatCategory {
    PhysicalAttack,      // 物理攻击
    NetworkAttack,       // 网络攻击
    DataBreach,          // 数据泄露
    IdentityTheft,       // 身份盗用
    MalwareInfection,    // 恶意软件感染
    DenialOfService,     // 拒绝服务攻击
    ManInTheMiddle,      // 中间人攻击
    FirmwareManipulation, // 固件篡改
    SupplyChainAttack,   // 供应链攻击
    SideChannelAttack,   // 侧信道攻击
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Critical = 5,
    High = 4,
    Medium = 3,
    Low = 2,
    Minimal = 1,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatVector {
    pub category: ThreatCategory,
    pub description: String,
    pub attack_vector: String,
    pub potential_impact: String,
    pub likelihood: f64,        // 0.0 to 1.0
    pub impact_severity: f64,   // 0.0 to 1.0
    pub risk_level: RiskLevel,
    pub mitigation_strategies: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityAsset {
    pub asset_id: String,
    pub asset_type: String,
    pub value: f64,             // 资产价值
    pub confidentiality_req: RiskLevel,
    pub integrity_req: RiskLevel,
    pub availability_req: RiskLevel,
    pub threats: Vec<ThreatVector>,
}

#[derive(Debug)]
pub struct ThreatModel {
    assets: HashMap<String, SecurityAsset>,
    threat_vectors: Vec<ThreatVector>,
    security_controls: HashMap<ThreatCategory, Vec<SecurityControl>>,
}

#[derive(Debug, Clone)]
pub struct SecurityControl {
    pub control_id: String,
    pub control_type: ControlType,
    pub description: String,
    pub effectiveness: f64,     // 0.0 to 1.0
    pub cost: f64,
    pub implementation_complexity: RiskLevel,
}

#[derive(Debug, Clone)]
pub enum ControlType {
    Preventive,    // 预防性控制
    Detective,     // 检测性控制
    Corrective,    // 纠正性控制
    Deterrent,     // 威慑性控制
    Recovery,      // 恢复性控制
    Compensating,  // 补偿性控制
}

impl ThreatModel {
    pub fn new() -> Self {
        Self {
            assets: HashMap::new(),
            threat_vectors: Vec::new(),
            security_controls: HashMap::new(),
        }
    }
    
    pub fn add_asset(&mut self, asset: SecurityAsset) {
        self.assets.insert(asset.asset_id.clone(), asset);
    }
    
    pub fn add_threat_vector(&mut self, threat: ThreatVector) {
        self.threat_vectors.push(threat);
    }
    
    pub fn add_security_control(&mut self, category: ThreatCategory, control: SecurityControl) {
        self.security_controls.entry(category)
            .or_insert_with(Vec::new)
            .push(control);
    }
    
    pub fn calculate_risk_score(&self, asset_id: &str) -> f64 {
        if let Some(asset) = self.assets.get(asset_id) {
            let mut total_risk = 0.0;
            let mut threat_count = 0;
            
            for threat in &asset.threats {
                let inherent_risk = threat.likelihood * threat.impact_severity;
                let residual_risk = self.calculate_residual_risk(&threat.category, inherent_risk);
                total_risk += residual_risk * asset.value;
                threat_count += 1;
            }
            
            if threat_count > 0 {
                total_risk / threat_count as f64
            } else {
                0.0
            }
        } else {
            0.0
        }
    }
    
    fn calculate_residual_risk(&self, category: &ThreatCategory, inherent_risk: f64) -> f64 {
        if let Some(controls) = self.security_controls.get(category) {
            let mut risk_reduction = 0.0;
            for control in controls {
                risk_reduction += control.effectiveness;
            }
            // 控制措施的效果不是简单相加，而是递减效应
            let total_effectiveness = 1.0 - (1.0 - risk_reduction.min(0.95)).powf(1.0 / controls.len() as f64);
            inherent_risk * (1.0 - total_effectiveness)
        } else {
            inherent_risk
        }
    }
    
    pub fn generate_risk_assessment_report(&self) -> String {
        let mut report = String::new();
        report.push_str("# IoT Security Risk Assessment Report\n\n");
        
        report.push_str("## Asset Risk Summary\n\n");
        report.push_str("| Asset ID | Asset Type | Risk Score | Risk Level |\n");
        report.push_str("|----------|------------|------------|------------|\n");
        
        for (asset_id, asset) in &self.assets {
            let risk_score = self.calculate_risk_score(asset_id);
            let risk_level = match risk_score {
                x if x >= 4.0 => "Critical",
                x if x >= 3.0 => "High", 
                x if x >= 2.0 => "Medium",
                x if x >= 1.0 => "Low",
                _ => "Minimal",
            };
            
            report.push_str(&format!(
                "| {} | {} | {:.2} | {} |\n",
                asset_id, asset.asset_type, risk_score, risk_level
            ));
        }
        
        report.push_str("\n## Threat Category Analysis\n\n");
        let mut category_risks: HashMap<ThreatCategory, f64> = HashMap::new();
        
        for threat in &self.threat_vectors {
            let risk = threat.likelihood * threat.impact_severity;
            *category_risks.entry(threat.category.clone()).or_insert(0.0) += risk;
        }
        
        let mut sorted_categories: Vec<_> = category_risks.iter().collect();
        sorted_categories.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());
        
        for (category, risk) in sorted_categories {
            report.push_str(&format!("- **{:?}**: Risk Score {:.2}\n", category, risk));
        }
        
        report
    }
}

// 创建标准威胁模型
pub fn create_standard_iot_threat_model() -> ThreatModel {
    let mut model = ThreatModel::new();
    
    // 添加标准威胁向量
    let threats = vec![
        ThreatVector {
            category: ThreatCategory::PhysicalAttack,
            description: "物理访问设备进行篡改".to_string(),
            attack_vector: "直接物理接触设备".to_string(),
            potential_impact: "设备控制权获取，数据泄露".to_string(),
            likelihood: 0.3,
            impact_severity: 0.8,
            risk_level: RiskLevel::Medium,
            mitigation_strategies: vec![
                "物理封装保护".to_string(),
                "防篡改检测".to_string(),
                "安全固件".to_string(),
            ],
        },
        ThreatVector {
            category: ThreatCategory::NetworkAttack,
            description: "通过网络漏洞攻击设备".to_string(),
            attack_vector: "网络协议漏洞利用".to_string(),
            potential_impact: "远程控制，数据窃取".to_string(),
            likelihood: 0.7,
            impact_severity: 0.9,
            risk_level: RiskLevel::High,
            mitigation_strategies: vec![
                "网络加密".to_string(),
                "访问控制".to_string(),
                "入侵检测".to_string(),
            ],
        },
        ThreatVector {
            category: ThreatCategory::DataBreach,
            description: "敏感数据未经授权访问".to_string(),
            attack_vector: "数据传输拦截或存储攻击".to_string(),
            potential_impact: "隐私泄露，合规违规".to_string(),
            likelihood: 0.6,
            impact_severity: 0.8,
            risk_level: RiskLevel::High,
            mitigation_strategies: vec![
                "端到端加密".to_string(),
                "数据分类标记".to_string(),
                "访问日志监控".to_string(),
            ],
        },
    ];
    
    for threat in threats {
        model.add_threat_vector(threat);
    }
    
    model
}
```

## 5.1.4.2 设备身份认证 / Device Authentication

### 5.1.4.2.1 设备身份管理 / Device Identity Management

**PKI基础设施实现：**

```rust
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceIdentity {
    pub device_id: String,
    pub device_eui: [u8; 8],        // 设备唯一标识符
    pub manufacturer_id: String,
    pub device_type: String,
    pub firmware_version: String,
    pub certificate: X509Certificate,
    pub private_key: PrivateKey,
    pub trusted_ca_certs: Vec<X509Certificate>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct X509Certificate {
    pub serial_number: String,
    pub issuer: String,
    pub subject: String,
    pub public_key: PublicKey,
    pub not_before: u64,            // Unix timestamp
    pub not_after: u64,             // Unix timestamp
    pub signature: Vec<u8>,
    pub signature_algorithm: String,
    pub extensions: HashMap<String, Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublicKey {
    pub algorithm: String,
    pub key_data: Vec<u8>,
    pub key_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrivateKey {
    pub algorithm: String,
    pub key_data: Vec<u8>,          // 加密存储
    pub encrypted: bool,
}

#[derive(Debug)]
pub struct DeviceAuthenticationManager {
    devices: HashMap<String, DeviceIdentity>,
    ca_certificates: HashMap<String, X509Certificate>,
    revoked_certificates: HashMap<String, u64>, // serial -> revocation_time
    authentication_sessions: HashMap<String, AuthenticationSession>,
}

#[derive(Debug, Clone)]
pub struct AuthenticationSession {
    pub session_id: String,
    pub device_id: String,
    pub established_at: u64,
    pub expires_at: u64,
    pub session_key: Vec<u8>,
    pub authentication_method: AuthenticationMethod,
}

#[derive(Debug, Clone)]
pub enum AuthenticationMethod {
    X509Certificate,
    SharedSecret,
    DigitalSignature,
    BiometricHash,
    TrustedPlatformModule,
}

impl DeviceAuthenticationManager {
    pub fn new() -> Self {
        Self {
            devices: HashMap::new(),
            ca_certificates: HashMap::new(),
            revoked_certificates: HashMap::new(),
            authentication_sessions: HashMap::new(),
        }
    }
    
    pub fn register_device(&mut self, identity: DeviceIdentity) -> Result<(), &'static str> {
        // 验证设备证书
        if !self.verify_certificate(&identity.certificate)? {
            return Err("Invalid device certificate");
        }
        
        // 检查证书是否被撤销
        if self.is_certificate_revoked(&identity.certificate.serial_number) {
            return Err("Certificate has been revoked");
        }
        
        // 验证设备身份唯一性
        if self.devices.contains_key(&identity.device_id) {
            return Err("Device ID already exists");
        }
        
        self.devices.insert(identity.device_id.clone(), identity);
        Ok(())
    }
    
    pub fn authenticate_device(&mut self, 
                              device_id: &str, 
                              challenge_response: &[u8],
                              nonce: &[u8]) -> Result<AuthenticationSession, &'static str> {
        let device = self.devices.get(device_id)
            .ok_or("Device not found")?;
        
        // 验证证书有效期
        let now = SystemTime::now().duration_since(UNIX_EPOCH)
            .map_err(|_| "System time error")?
            .as_secs();
        
        if now < device.certificate.not_before || now > device.certificate.not_after {
            return Err("Certificate expired or not yet valid");
        }
        
        // 验证挑战响应
        if !self.verify_challenge_response(device, challenge_response, nonce)? {
            return Err("Authentication failed");
        }
        
        // 创建会话
        let session = AuthenticationSession {
            session_id: self.generate_session_id(),
            device_id: device_id.to_string(),
            established_at: now,
            expires_at: now + 3600, // 1小时有效期
            session_key: self.generate_session_key(device_id, nonce),
            authentication_method: AuthenticationMethod::X509Certificate,
        };
        
        self.authentication_sessions.insert(session.session_id.clone(), session.clone());
        Ok(session)
    }
    
    pub fn mutual_authentication(&mut self, 
                                device_id: &str,
                                device_challenge: &[u8],
                                server_challenge: &[u8]) -> Result<(AuthenticationSession, Vec<u8>), &'static str> {
        let device = self.devices.get(device_id)
            .ok_or("Device not found")?;
        
        // 设备认证服务器
        let server_response = self.generate_server_response(server_challenge)?;
        
        // 服务器认证设备
        if !self.verify_device_response(device, device_challenge)? {
            return Err("Device authentication failed");
        }
        
        // 创建相互认证会话
        let now = SystemTime::now().duration_since(UNIX_EPOCH)
            .map_err(|_| "System time error")?
            .as_secs();
        
        let session = AuthenticationSession {
            session_id: self.generate_session_id(),
            device_id: device_id.to_string(),
            established_at: now,
            expires_at: now + 3600,
            session_key: self.derive_mutual_session_key(device_challenge, server_challenge),
            authentication_method: AuthenticationMethod::X509Certificate,
        };
        
        self.authentication_sessions.insert(session.session_id.clone(), session.clone());
        Ok((session, server_response))
    }
    
    fn verify_certificate(&self, cert: &X509Certificate) -> Result<bool, &'static str> {
        // 检查证书链
        let issuer_cert = self.ca_certificates.get(&cert.issuer)
            .ok_or("Issuer certificate not found")?;
        
        // 验证数字签名
        if !self.verify_signature(&cert.signature, &issuer_cert.public_key, cert)? {
            return Ok(false);
        }
        
        // 验证证书有效期
        let now = SystemTime::now().duration_since(UNIX_EPOCH)
            .map_err(|_| "System time error")?
            .as_secs();
        
        if now < cert.not_before || now > cert.not_after {
            return Ok(false);
        }
        
        Ok(true)
    }
    
    fn is_certificate_revoked(&self, serial_number: &str) -> bool {
        self.revoked_certificates.contains_key(serial_number)
    }
    
    fn verify_challenge_response(&self, 
                               device: &DeviceIdentity, 
                               response: &[u8], 
                               nonce: &[u8]) -> Result<bool, &'static str> {
        // 使用设备公钥验证签名
        let expected_data = [nonce, device.device_id.as_bytes()].concat();
        self.verify_signature(response, &device.certificate.public_key, &expected_data)
    }
    
    fn verify_signature(&self, 
                       signature: &[u8], 
                       public_key: &PublicKey, 
                       data: &impl Serialize) -> Result<bool, &'static str> {
        // 简化的签名验证实现
        // 实际应该使用密码学库如ring或rustcrypto
        match public_key.algorithm.as_str() {
            "RSA-2048" => {
                // RSA签名验证
                Ok(signature.len() == 256) // 简化验证
            }
            "ECDSA-P256" => {
                // ECDSA签名验证
                Ok(signature.len() == 64) // 简化验证
            }
            "Ed25519" => {
                // Ed25519签名验证
                Ok(signature.len() == 64) // 简化验证
            }
            _ => Err("Unsupported signature algorithm"),
        }
    }
    
    fn generate_session_id(&self) -> String {
        // 生成随机会话ID
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        format!("session_{}", now.as_nanos())
    }
    
    fn generate_session_key(&self, device_id: &str, nonce: &[u8]) -> Vec<u8> {
        // 使用HKDF派生会话密钥
        let mut key = Vec::new();
        key.extend_from_slice(device_id.as_bytes());
        key.extend_from_slice(nonce);
        
        // 简化的密钥派生
        let mut session_key = vec![0u8; 32];
        for (i, byte) in key.iter().cycle().take(32).enumerate() {
            session_key[i] = byte ^ (i as u8);
        }
        session_key
    }
    
    fn generate_server_response(&self, challenge: &[u8]) -> Result<Vec<u8>, &'static str> {
        // 服务器响应设备挑战
        Ok(challenge.iter().map(|b| b ^ 0xAA).collect())
    }
    
    fn verify_device_response(&self, device: &DeviceIdentity, response: &[u8]) -> Result<bool, &'static str> {
        // 验证设备对服务器挑战的响应
        Ok(response.len() > 0) // 简化验证
    }
    
    fn derive_mutual_session_key(&self, device_challenge: &[u8], server_challenge: &[u8]) -> Vec<u8> {
        // 派生相互认证会话密钥
        let mut combined = Vec::new();
        combined.extend_from_slice(device_challenge);
        combined.extend_from_slice(server_challenge);
        
        // 使用SHA-256派生密钥
        let mut key = vec![0u8; 32];
        for (i, byte) in combined.iter().cycle().take(32).enumerate() {
            key[i] = byte ^ ((i * 7) as u8);
        }
        key
    }
    
    pub fn revoke_certificate(&mut self, serial_number: &str) {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        self.revoked_certificates.insert(serial_number.to_string(), now);
    }
    
    pub fn validate_session(&self, session_id: &str) -> Result<&AuthenticationSession, &'static str> {
        let session = self.authentication_sessions.get(session_id)
            .ok_or("Session not found")?;
        
        let now = SystemTime::now().duration_since(UNIX_EPOCH)
            .map_err(|_| "System time error")?
            .as_secs();
        
        if now > session.expires_at {
            return Err("Session expired");
        }
        
        Ok(session)
    }
    
    pub fn cleanup_expired_sessions(&mut self) {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        self.authentication_sessions.retain(|_, session| session.expires_at > now);
    }
}
```

### 5.1.4.2.2 轻量级认证协议 / Lightweight Authentication Protocols

**适用于资源受限设备的认证：**

```rust
use std::collections::HashMap;

// DTLS-PSK (Pre-Shared Key) 轻量级认证
#[derive(Debug, Clone)]
pub struct DTLSPSKAuthenticator {
    psk_store: HashMap<String, Vec<u8>>, // device_id -> psk
    active_sessions: HashMap<String, DTLSSession>,
}

#[derive(Debug, Clone)]
pub struct DTLSSession {
    pub session_id: String,
    pub device_id: String,
    pub master_secret: Vec<u8>,
    pub client_random: [u8; 32],
    pub server_random: [u8; 32],
    pub cipher_suite: CipherSuite,
}

#[derive(Debug, Clone)]
pub enum CipherSuite {
    TLS_PSK_WITH_AES_128_CCM,
    TLS_PSK_WITH_AES_128_GCM,
    TLS_PSK_WITH_CHACHA20_POLY1305,
}

impl DTLSPSKAuthenticator {
    pub fn new() -> Self {
        Self {
            psk_store: HashMap::new(),
            active_sessions: HashMap::new(),
        }
    }
    
    pub fn register_device_psk(&mut self, device_id: String, psk: Vec<u8>) {
        self.psk_store.insert(device_id, psk);
    }
    
    pub fn authenticate_with_psk(&mut self, 
                                device_id: &str, 
                                client_random: [u8; 32]) -> Result<DTLSSession, &'static str> {
        let psk = self.psk_store.get(device_id)
            .ok_or("Device PSK not found")?;
        
        let server_random = self.generate_random();
        let master_secret = self.derive_master_secret(psk, &client_random, &server_random);
        
        let session = DTLSSession {
            session_id: format!("dtls_{}", device_id),
            device_id: device_id.to_string(),
            master_secret,
            client_random,
            server_random,
            cipher_suite: CipherSuite::TLS_PSK_WITH_AES_128_GCM,
        };
        
        self.active_sessions.insert(session.session_id.clone(), session.clone());
        Ok(session)
    }
    
    fn generate_random(&self) -> [u8; 32] {
        // 生成32字节随机数
        let mut random = [0u8; 32];
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;
        
        for (i, byte) in random.iter_mut().enumerate() {
            *byte = ((now >> (i % 8)) ^ (i as u64 * 7)) as u8;
        }
        random
    }
    
    fn derive_master_secret(&self, psk: &[u8], client_random: &[u8; 32], server_random: &[u8; 32]) -> Vec<u8> {
        // DTLS-PSK主密钥派生
        let mut master_secret = vec![0u8; 48];
        
        // 简化的PRF实现 (实际应使用HMAC-SHA256)
        let mut seed = Vec::new();
        seed.extend_from_slice(b"master secret");
        seed.extend_from_slice(client_random);
        seed.extend_from_slice(server_random);
        
        for (i, byte) in master_secret.iter_mut().enumerate() {
            *byte = psk[i % psk.len()] ^ seed[i % seed.len()];
        }
        
        master_secret
    }
}

// OAuth 2.0 设备授权流程
#[derive(Debug, Clone)]
pub struct OAuth2DeviceFlow {
    client_credentials: HashMap<String, ClientCredentials>,
    device_codes: HashMap<String, DeviceCode>,
    access_tokens: HashMap<String, AccessToken>,
}

#[derive(Debug, Clone)]
pub struct ClientCredentials {
    pub client_id: String,
    pub client_secret: Option<String>, // 对于公共客户端可为空
    pub redirect_uris: Vec<String>,
    pub scope: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct DeviceCode {
    pub device_code: String,
    pub user_code: String,
    pub verification_uri: String,
    pub expires_at: u64,
    pub interval: u64, // 轮询间隔
    pub client_id: String,
    pub scope: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct AccessToken {
    pub access_token: String,
    pub token_type: String,
    pub expires_at: u64,
    pub refresh_token: Option<String>,
    pub scope: Vec<String>,
    pub device_id: String,
}

impl OAuth2DeviceFlow {
    pub fn new() -> Self {
        Self {
            client_credentials: HashMap::new(),
            device_codes: HashMap::new(),
            access_tokens: HashMap::new(),
        }
    }
    
    pub fn register_client(&mut self, credentials: ClientCredentials) {
        self.client_credentials.insert(credentials.client_id.clone(), credentials);
    }
    
    // 设备请求授权码
    pub fn device_authorization_request(&mut self, 
                                      client_id: &str, 
                                      scope: Vec<String>) -> Result<DeviceCode, &'static str> {
        let _client = self.client_credentials.get(client_id)
            .ok_or("Invalid client")?;
        
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let device_code = DeviceCode {
            device_code: self.generate_device_code(),
            user_code: self.generate_user_code(),
            verification_uri: "https://device.example.com/verify".to_string(),
            expires_at: now + 1800, // 30分钟
            interval: 5, // 5秒轮询间隔
            client_id: client_id.to_string(),
            scope,
        };
        
        self.device_codes.insert(device_code.device_code.clone(), device_code.clone());
        Ok(device_code)
    }
    
    // 设备轮询访问令牌
    pub fn poll_for_token(&mut self, 
                         client_id: &str, 
                         device_code: &str) -> Result<Option<AccessToken>, &'static str> {
        let code = self.device_codes.get(device_code)
            .ok_or("Invalid device code")?;
        
        if code.client_id != client_id {
            return Err("Client mismatch");
        }
        
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        if now > code.expires_at {
            self.device_codes.remove(device_code);
            return Err("Device code expired");
        }
        
        // 检查用户是否已授权 (简化实现)
        if self.is_user_authorized(&code.user_code) {
            let access_token = AccessToken {
                access_token: self.generate_access_token(),
                token_type: "Bearer".to_string(),
                expires_at: now + 3600, // 1小时
                refresh_token: Some(self.generate_refresh_token()),
                scope: code.scope.clone(),
                device_id: device_code.to_string(),
            };
            
            self.access_tokens.insert(access_token.access_token.clone(), access_token.clone());
            self.device_codes.remove(device_code);
            Ok(Some(access_token))
        } else {
            Ok(None) // 用户尚未授权
        }
    }
    
    fn generate_device_code(&self) -> String {
        format!("device_{}", std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos())
    }
    
    fn generate_user_code(&self) -> String {
        // 生成8位用户友好码
        let chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        let mut code = String::new();
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as usize;
        
        for i in 0..8 {
            let index = (now + i * 7) % chars.len();
            code.push(chars.chars().nth(index).unwrap());
            if i == 3 {
                code.push('-'); // 添加分隔符
            }
        }
        code
    }
    
    fn generate_access_token(&self) -> String {
        format!("access_{}", std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos())
    }
    
    fn generate_refresh_token(&self) -> String {
        format!("refresh_{}", std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos())
    }
    
    fn is_user_authorized(&self, user_code: &str) -> bool {
        // 简化实现 - 实际需要检查用户授权状态
        user_code.len() == 9 // 假设所有有效格式的用户码都已授权
    }
    
    pub fn validate_access_token(&self, token: &str) -> Result<&AccessToken, &'static str> {
        let access_token = self.access_tokens.get(token)
            .ok_or("Invalid access token")?;
        
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        if now > access_token.expires_at {
            return Err("Access token expired");
        }
        
        Ok(access_token)
    }
}
```

## 5.1.4.3 数据加密与隐私 / Data Encryption and Privacy

### 5.1.4.3.1 端到端加密 / End-to-End Encryption

**物联网数据加密框架：**

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub enum EncryptionAlgorithm {
    AES128GCM,
    AES256GCM, 
    ChaCha20Poly1305,
    AES128CCM,  // 适用于受限设备
}

#[derive(Debug, Clone)]
pub enum KeyExchangeProtocol {
    ECDH,       // 椭圆曲线Diffie-Hellman
    X25519,     // Curve25519 ECDH
    RSA,        // RSA密钥交换
    PSK,        // 预共享密钥
}

#[derive(Debug, Clone)]
pub struct EncryptionContext {
    pub algorithm: EncryptionAlgorithm,
    pub key: Vec<u8>,
    pub iv: Vec<u8>,           // 初始化向量
    pub aad: Vec<u8>,          // Additional Authenticated Data
    pub tag_length: usize,     // 认证标签长度
}

#[derive(Debug, Clone)]
pub struct EncryptedData {
    pub ciphertext: Vec<u8>,
    pub tag: Vec<u8>,          // 认证标签
    pub iv: Vec<u8>,
    pub algorithm: EncryptionAlgorithm,
    pub key_id: String,        // 密钥标识符
}

#[derive(Debug)]
pub struct IoTEncryptionManager {
    device_keys: HashMap<String, Vec<u8>>, // device_id -> key
    group_keys: HashMap<String, Vec<u8>>,  // group_id -> key
    key_rotation_schedule: HashMap<String, u64>, // key_id -> next_rotation_time
    encryption_policies: HashMap<String, EncryptionPolicy>,
}

#[derive(Debug, Clone)]
pub struct EncryptionPolicy {
    pub device_pattern: String,
    pub required_algorithm: EncryptionAlgorithm,
    pub key_rotation_interval: u64, // seconds
    pub forward_secrecy: bool,
    pub data_classification: DataClassification,
}

#[derive(Debug, Clone)]
pub enum DataClassification {
    Public,
    Internal,
    Confidential,
    Restricted,
}

impl IoTEncryptionManager {
    pub fn new() -> Self {
        Self {
            device_keys: HashMap::new(),
            group_keys: HashMap::new(),
            key_rotation_schedule: HashMap::new(),
            encryption_policies: HashMap::new(),
        }
    }
    
    pub fn register_device_key(&mut self, device_id: String, key: Vec<u8>) {
        self.device_keys.insert(device_id, key);
    }
    
    pub fn set_encryption_policy(&mut self, device_pattern: String, policy: EncryptionPolicy) {
        self.encryption_policies.insert(device_pattern, policy);
    }
    
    pub fn encrypt_data(&self, 
                       device_id: &str, 
                       data: &[u8], 
                       classification: DataClassification) -> Result<EncryptedData, &'static str> {
        let policy = self.get_encryption_policy(device_id, &classification)?;
        let key = self.device_keys.get(device_id)
            .ok_or("Device key not found")?;
        
        let context = EncryptionContext {
            algorithm: policy.required_algorithm.clone(),
            key: key.clone(),
            iv: self.generate_iv(&policy.required_algorithm),
            aad: device_id.as_bytes().to_vec(),
            tag_length: 16, // 128-bit tag
        };
        
        self.encrypt_with_context(data, &context)
    }
    
    pub fn decrypt_data(&self, 
                       device_id: &str, 
                       encrypted_data: &EncryptedData) -> Result<Vec<u8>, &'static str> {
        let key = self.device_keys.get(device_id)
            .ok_or("Device key not found")?;
        
        let context = EncryptionContext {
            algorithm: encrypted_data.algorithm.clone(),
            key: key.clone(),
            iv: encrypted_data.iv.clone(),
            aad: device_id.as_bytes().to_vec(),
            tag_length: encrypted_data.tag.len(),
        };
        
        self.decrypt_with_context(encrypted_data, &context)
    }
    
    fn encrypt_with_context(&self, 
                           data: &[u8], 
                           context: &EncryptionContext) -> Result<EncryptedData, &'static str> {
        match context.algorithm {
            EncryptionAlgorithm::AES128GCM | EncryptionAlgorithm::AES256GCM => {
                self.aes_gcm_encrypt(data, context)
            }
            EncryptionAlgorithm::ChaCha20Poly1305 => {
                self.chacha20_poly1305_encrypt(data, context)
            }
            EncryptionAlgorithm::AES128CCM => {
                self.aes_ccm_encrypt(data, context)
            }
        }
    }
    
    fn decrypt_with_context(&self, 
                           encrypted_data: &EncryptedData, 
                           context: &EncryptionContext) -> Result<Vec<u8>, &'static str> {
        match context.algorithm {
            EncryptionAlgorithm::AES128GCM | EncryptionAlgorithm::AES256GCM => {
                self.aes_gcm_decrypt(encrypted_data, context)
            }
            EncryptionAlgorithm::ChaCha20Poly1305 => {
                self.chacha20_poly1305_decrypt(encrypted_data, context)
            }
            EncryptionAlgorithm::AES128CCM => {
                self.aes_ccm_decrypt(encrypted_data, context)
            }
        }
    }
    
    fn aes_gcm_encrypt(&self, data: &[u8], context: &EncryptionContext) -> Result<EncryptedData, &'static str> {
        // 简化的AES-GCM实现 (实际应使用crypto库)
        let mut ciphertext = data.to_vec();
        
        // XOR with key (简化加密)
        for (i, byte) in ciphertext.iter_mut().enumerate() {
            *byte ^= context.key[i % context.key.len()];
            *byte ^= context.iv[i % context.iv.len()];
        }
        
        // 生成认证标签
        let tag = self.generate_auth_tag(&ciphertext, &context.key, &context.aad);
        
        Ok(EncryptedData {
            ciphertext,
            tag,
            iv: context.iv.clone(),
            algorithm: context.algorithm.clone(),
            key_id: "default".to_string(),
        })
    }
    
    fn aes_gcm_decrypt(&self, encrypted_data: &EncryptedData, context: &EncryptionContext) -> Result<Vec<u8>, &'static str> {
        // 验证认证标签
        let expected_tag = self.generate_auth_tag(&encrypted_data.ciphertext, &context.key, &context.aad);
        if expected_tag != encrypted_data.tag {
            return Err("Authentication failed");
        }
        
        // 解密数据
        let mut plaintext = encrypted_data.ciphertext.clone();
        for (i, byte) in plaintext.iter_mut().enumerate() {
            *byte ^= context.iv[i % context.iv.len()];
            *byte ^= context.key[i % context.key.len()];
        }
        
        Ok(plaintext)
    }
    
    fn chacha20_poly1305_encrypt(&self, data: &[u8], context: &EncryptionContext) -> Result<EncryptedData, &'static str> {
        // ChaCha20-Poly1305实现
        let mut ciphertext = data.to_vec();
        
        // 简化的ChaCha20流密码
        for (i, byte) in ciphertext.iter_mut().enumerate() {
            let keystream_byte = self.chacha20_keystream(&context.key, &context.iv, i);
            *byte ^= keystream_byte;
        }
        
        let tag = self.poly1305_mac(&ciphertext, &context.key, &context.aad);
        
        Ok(EncryptedData {
            ciphertext,
            tag,
            iv: context.iv.clone(),
            algorithm: context.algorithm.clone(),
            key_id: "default".to_string(),
        })
    }
    
    fn chacha20_poly1305_decrypt(&self, encrypted_data: &EncryptedData, context: &EncryptionContext) -> Result<Vec<u8>, &'static str> {
        // 验证Poly1305 MAC
        let expected_tag = self.poly1305_mac(&encrypted_data.ciphertext, &context.key, &context.aad);
        if expected_tag != encrypted_data.tag {
            return Err("Authentication failed");
        }
        
        // ChaCha20解密
        let mut plaintext = encrypted_data.ciphertext.clone();
        for (i, byte) in plaintext.iter_mut().enumerate() {
            let keystream_byte = self.chacha20_keystream(&context.key, &context.iv, i);
            *byte ^= keystream_byte;
        }
        
        Ok(plaintext)
    }
    
    fn aes_ccm_encrypt(&self, data: &[u8], context: &EncryptionContext) -> Result<EncryptedData, &'static str> {
        // AES-CCM适用于IEEE 802.15.4等受限环境
        let mut ciphertext = data.to_vec();
        
        // 简化的CTR模式加密
        for (i, byte) in ciphertext.iter_mut().enumerate() {
            let counter_block = self.aes_ccm_counter_block(&context.iv, i);
            let encrypted_counter = self.aes_encrypt_block(&counter_block, &context.key);
            *byte ^= encrypted_counter[i % 16];
        }
        
        // CBC-MAC认证
        let tag = self.aes_ccm_auth(&data, &context.key, &context.iv, &context.aad);
        
        Ok(EncryptedData {
            ciphertext,
            tag,
            iv: context.iv.clone(),
            algorithm: context.algorithm.clone(),
            key_id: "default".to_string(),
        })
    }
    
    fn aes_ccm_decrypt(&self, encrypted_data: &EncryptedData, context: &EncryptionContext) -> Result<Vec<u8>, &'static str> {
        // 先解密，再验证
        let mut plaintext = encrypted_data.ciphertext.clone();
        for (i, byte) in plaintext.iter_mut().enumerate() {
            let counter_block = self.aes_ccm_counter_block(&context.iv, i);
            let encrypted_counter = self.aes_encrypt_block(&counter_block, &context.key);
            *byte ^= encrypted_counter[i % 16];
        }
        
        // 验证认证标签
        let expected_tag = self.aes_ccm_auth(&plaintext, &context.key, &context.iv, &context.aad);
        if expected_tag != encrypted_data.tag {
            return Err("Authentication failed");
        }
        
        Ok(plaintext)
    }
    
    fn get_encryption_policy(&self, device_id: &str, classification: &DataClassification) -> Result<&EncryptionPolicy, &'static str> {
        // 查找匹配的加密策略
        for (pattern, policy) in &self.encryption_policies {
            if device_id.contains(pattern) {
                return Ok(policy);
            }
        }
        
        // 默认策略
        static DEFAULT_POLICY: EncryptionPolicy = EncryptionPolicy {
            device_pattern: "*".to_string(),
            required_algorithm: EncryptionAlgorithm::AES128GCM,
            key_rotation_interval: 86400, // 24小时
            forward_secrecy: true,
            data_classification: DataClassification::Internal,
        };
        
        Ok(&DEFAULT_POLICY)
    }
    
    fn generate_iv(&self, algorithm: &EncryptionAlgorithm) -> Vec<u8> {
        let iv_size = match algorithm {
            EncryptionAlgorithm::AES128GCM | EncryptionAlgorithm::AES256GCM => 12, // 96 bits
            EncryptionAlgorithm::ChaCha20Poly1305 => 12, // 96 bits
            EncryptionAlgorithm::AES128CCM => 13, // 104 bits
        };
        
        let mut iv = vec![0u8; iv_size];
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;
        
        for (i, byte) in iv.iter_mut().enumerate() {
            *byte = ((now >> (i * 8)) ^ (i as u64 * 17)) as u8;
        }
        iv
    }
    
    fn generate_auth_tag(&self, ciphertext: &[u8], key: &[u8], aad: &[u8]) -> Vec<u8> {
        // 简化的认证标签生成
        let mut tag = vec![0u8; 16];
        let mut hasher = 0u64;
        
        for byte in ciphertext.iter().chain(key.iter()).chain(aad.iter()) {
            hasher = hasher.wrapping_mul(31).wrapping_add(*byte as u64);
        }
        
        for (i, byte) in tag.iter_mut().enumerate() {
            *byte = ((hasher >> (i * 8)) ^ (i as u64 * 19)) as u8;
        }
        tag
    }
    
    fn chacha20_keystream(&self, key: &[u8], nonce: &[u8], position: usize) -> u8 {
        // 简化的ChaCha20密钥流生成
        let mut state = 0u32;
        for (i, &k) in key.iter().enumerate() {
            state = state.wrapping_add((k as u32) << (i % 4 * 8));
        }
        for (i, &n) in nonce.iter().enumerate() {
            state = state.wrapping_mul(31).wrapping_add(n as u32);
        }
        state = state.wrapping_add(position as u32);
        (state ^ (state >> 16)) as u8
    }
    
    fn poly1305_mac(&self, data: &[u8], key: &[u8], aad: &[u8]) -> Vec<u8> {
        // 简化的Poly1305 MAC
        let mut mac = vec![0u8; 16];
        let mut accumulator = 0u64;
        
        for byte in data.iter().chain(aad.iter()) {
            accumulator = accumulator.wrapping_mul(17).wrapping_add(*byte as u64);
        }
        
        for (i, &k) in key.iter().enumerate() {
            accumulator = accumulator.wrapping_add((k as u64) << (i % 8 * 8));
        }
        
        for (i, byte) in mac.iter_mut().enumerate() {
            *byte = ((accumulator >> (i * 8)) ^ (i as u64 * 23)) as u8;
        }
        mac
    }
    
    fn aes_ccm_counter_block(&self, nonce: &[u8], counter: usize) -> Vec<u8> {
        let mut block = vec![0u8; 16];
        block[0] = 1; // Flags for CTR mode
        block[1..nonce.len()+1].copy_from_slice(nonce);
        
        let counter_bytes = (counter as u32).to_be_bytes();
        block[12..16].copy_from_slice(&counter_bytes);
        block
    }
    
    fn aes_encrypt_block(&self, block: &[u8], key: &[u8]) -> Vec<u8> {
        // 简化的AES块加密
        let mut encrypted = block.to_vec();
        for (i, byte) in encrypted.iter_mut().enumerate() {
            *byte ^= key[i % key.len()];
            *byte = (*byte).wrapping_mul(7).wrapping_add(13); // 简化的替换
        }
        encrypted
    }
    
    fn aes_ccm_auth(&self, data: &[u8], key: &[u8], nonce: &[u8], aad: &[u8]) -> Vec<u8> {
        // 简化的AES-CCM认证
        let mut auth = vec![0u8; 16];
        let mut state = 0u64;
        
        for byte in data.iter().chain(aad.iter()).chain(nonce.iter()) {
            state = state.wrapping_mul(31).wrapping_add(*byte as u64);
        }
        
        for (i, &k) in key.iter().enumerate() {
            state = state.wrapping_add((k as u64) << (i % 8 * 8));
        }
        
        for (i, byte) in auth.iter_mut().enumerate() {
            *byte = ((state >> (i * 8)) ^ (i as u64 * 29)) as u8;
        }
        auth
    }
    
    pub fn rotate_keys(&mut self) -> Result<(), &'static str> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        for (device_id, key) in &mut self.device_keys {
            if let Some(&next_rotation) = self.key_rotation_schedule.get(device_id) {
                if now >= next_rotation {
                    // 生成新密钥
                    let new_key = self.generate_new_key(key);
                    *key = new_key;
                    
                    // 更新下次轮换时间
                    self.key_rotation_schedule.insert(device_id.clone(), now + 86400); // 24小时后
                    
                    println!("Rotated key for device: {}", device_id);
                }
            }
        }
        
        Ok(())
    }
    
    fn generate_new_key(&self, old_key: &[u8]) -> Vec<u8> {
        // 基于旧密钥生成新密钥 (简化实现)
        let mut new_key = old_key.to_vec();
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;
        
        for (i, byte) in new_key.iter_mut().enumerate() {
            *byte ^= ((now >> (i * 8)) ^ (i as u64 * 37)) as u8;
        }
        new_key
    }
}
```

## 5.1.4.4 网络安全防护 / Network Security Protection

### 5.1.4.4.1 入侵检测系统 / Intrusion Detection System

**物联网专用IDS实现：**

```rust
use std::collections::{HashMap, VecDeque};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkPacket {
    pub timestamp: u64,
    pub source_ip: String,
    pub dest_ip: String,
    pub source_port: u16,
    pub dest_port: u16,
    pub protocol: String,
    pub payload_size: usize,
    pub flags: Vec<String>,
    pub payload_hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackType {
    PortScan,
    DDoS,
    MalformedPacket,
    SuspiciousPayload,
    UnauthorizedAccess,
    DataExfiltration,
    CommandInjection,
    FirmwareManipulation,
    ReplayAttack,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AlertSeverity {
    Critical = 5,
    High = 4,
    Medium = 3,
    Low = 2,
    Info = 1,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityAlert {
    pub alert_id: String,
    pub timestamp: u64,
    pub attack_type: AttackType,
    pub severity: AlertSeverity,
    pub source_ip: String,
    pub target_device: String,
    pub description: String,
    pub evidence: Vec<NetworkPacket>,
    pub confidence: f64,        // 0.0 to 1.0
    pub false_positive_risk: f64, // 0.0 to 1.0
}

#[derive(Debug)]
pub struct IoTIntrusionDetectionSystem {
    packet_buffer: VecDeque<NetworkPacket>,
    device_profiles: HashMap<String, DeviceProfile>,
    attack_signatures: Vec<AttackSignature>,
    behavior_models: HashMap<String, BehaviorModel>,
    active_alerts: HashMap<String, SecurityAlert>,
    statistics: DetectionStatistics,
}

#[derive(Debug, Clone)]
pub struct DeviceProfile {
    pub device_id: String,
    pub device_type: String,
    pub normal_ports: Vec<u16>,
    pub normal_protocols: Vec<String>,
    pub max_bandwidth: f64,     // bytes per second
    pub max_connections: usize,
    pub communication_patterns: Vec<CommunicationPattern>,
}

#[derive(Debug, Clone)]
pub struct CommunicationPattern {
    pub peer_ip: String,
    pub frequency: f64,         // messages per hour
    pub typical_size: usize,    // bytes
    pub time_windows: Vec<(u8, u8)>, // (start_hour, end_hour)
}

#[derive(Debug, Clone)]
pub struct AttackSignature {
    pub signature_id: String,
    pub attack_type: AttackType,
    pub pattern: SignaturePattern,
    pub threshold: f64,
    pub time_window: Duration,
}

#[derive(Debug, Clone)]
pub enum SignaturePattern {
    PortScanPattern {
        unique_ports_threshold: usize,
        time_window: Duration,
    },
    PayloadPattern {
        suspicious_strings: Vec<String>,
        regex_patterns: Vec<String>,
    },
    VolumePattern {
        packet_rate_threshold: f64,
        byte_rate_threshold: f64,
    },
    SequencePattern {
        packet_sequence: Vec<String>,
        max_gap: Duration,
    },
}

#[derive(Debug, Clone)]
pub struct BehaviorModel {
    pub device_id: String,
    pub baseline_established: bool,
    pub normal_packet_rate: f64,
    pub normal_byte_rate: f64,
    pub normal_connection_count: f64,
    pub active_hours: Vec<bool>,   // 24-hour bitmap
    pub peer_whitelist: Vec<String>,
    pub last_updated: u64,
}

#[derive(Debug, Clone)]
pub struct DetectionStatistics {
    pub total_packets_analyzed: u64,
    pub alerts_generated: u64,
    pub false_positives: u64,
    pub true_positives: u64,
    pub detection_accuracy: f64,
    pub avg_detection_time: Duration,
}

impl IoTIntrusionDetectionSystem {
    pub fn new() -> Self {
        Self {
            packet_buffer: VecDeque::new(),
            device_profiles: HashMap::new(),
            attack_signatures: Vec::new(),
            behavior_models: HashMap::new(),
            active_alerts: HashMap::new(),
            statistics: DetectionStatistics {
                total_packets_analyzed: 0,
                alerts_generated: 0,
                false_positives: 0,
                true_positives: 0,
                detection_accuracy: 0.0,
                avg_detection_time: Duration::from_millis(0),
            },
        }
    }
    
    pub fn register_device(&mut self, profile: DeviceProfile) {
        // 注册设备并初始化行为模型
        let behavior_model = BehaviorModel {
            device_id: profile.device_id.clone(),
            baseline_established: false,
            normal_packet_rate: 0.0,
            normal_byte_rate: 0.0,
            normal_connection_count: 0.0,
            active_hours: vec![false; 24],
            peer_whitelist: Vec::new(),
            last_updated: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),
        };
        
        self.behavior_models.insert(profile.device_id.clone(), behavior_model);
        self.device_profiles.insert(profile.device_id.clone(), profile);
    }
    
    pub fn add_signature(&mut self, signature: AttackSignature) {
        self.attack_signatures.push(signature);
    }
    
    pub fn analyze_packet(&mut self, packet: NetworkPacket) -> Vec<SecurityAlert> {
        self.statistics.total_packets_analyzed += 1;
        
        // 添加到数据包缓冲区
        self.packet_buffer.push_back(packet.clone());
        
        // 保持缓冲区大小
        if self.packet_buffer.len() > 10000 {
            self.packet_buffer.pop_front();
        }
        
        let mut alerts = Vec::new();
        
        // 基于签名的检测
        for signature in &self.attack_signatures {
            if let Some(alert) = self.check_signature(&packet, signature) {
                alerts.push(alert);
            }
        }
        
        // 基于行为的检测
        if let Some(alert) = self.check_behavior_anomaly(&packet) {
            alerts.push(alert);
        }
        
        // 更新行为模型
        self.update_behavior_model(&packet);
        
        // 存储告警
        for alert in &alerts {
            self.active_alerts.insert(alert.alert_id.clone(), alert.clone());
            self.statistics.alerts_generated += 1;
        }
        
        alerts
    }
    
    fn check_signature(&self, packet: &NetworkPacket, signature: &AttackSignature) -> Option<SecurityAlert> {
        match &signature.pattern {
            SignaturePattern::PortScanPattern { unique_ports_threshold, time_window } => {
                self.detect_port_scan(packet, *unique_ports_threshold, *time_window, &signature.attack_type)
            }
            SignaturePattern::PayloadPattern { suspicious_strings, regex_patterns } => {
                self.detect_suspicious_payload(packet, suspicious_strings, regex_patterns, &signature.attack_type)
            }
            SignaturePattern::VolumePattern { packet_rate_threshold, byte_rate_threshold } => {
                self.detect_volume_anomaly(packet, *packet_rate_threshold, *byte_rate_threshold, &signature.attack_type)
            }
            SignaturePattern::SequencePattern { packet_sequence, max_gap } => {
                self.detect_attack_sequence(packet, packet_sequence, *max_gap, &signature.attack_type)
            }
        }
    }
    
    fn detect_port_scan(&self, packet: &NetworkPacket, threshold: usize, time_window: Duration, attack_type: &AttackType) -> Option<SecurityAlert> {
        let cutoff_time = packet.timestamp - time_window.as_secs();
        let mut unique_ports = std::collections::HashSet::new();
        
        for p in self.packet_buffer.iter().rev() {
            if p.timestamp < cutoff_time {
                break;
            }
            if p.source_ip == packet.source_ip {
                unique_ports.insert(p.dest_port);
            }
        }
        
        if unique_ports.len() >= threshold {
            Some(SecurityAlert {
                alert_id: format!("alert_{}", packet.timestamp),
                timestamp: packet.timestamp,
                attack_type: attack_type.clone(),
                severity: AlertSeverity::High,
                source_ip: packet.source_ip.clone(),
                target_device: packet.dest_ip.clone(),
                description: format!("Port scan detected: {} unique ports scanned", unique_ports.len()),
                evidence: vec![packet.clone()],
                confidence: 0.9,
                false_positive_risk: 0.1,
            })
        } else {
            None
        }
    }
    
    fn detect_suspicious_payload(&self, packet: &NetworkPacket, suspicious_strings: &[String], _regex_patterns: &[String], attack_type: &AttackType) -> Option<SecurityAlert> {
        // 简化的载荷检测 (实际需要解析载荷内容)
        let payload_indicators = ["cmd", "exec", "shell", "root", "admin", "password"];
        
        for indicator in &payload_indicators {
            if packet.payload_hash.contains(indicator) {
                return Some(SecurityAlert {
                    alert_id: format!("alert_{}", packet.timestamp),
                    timestamp: packet.timestamp,
                    attack_type: attack_type.clone(),
                    severity: AlertSeverity::Medium,
                    source_ip: packet.source_ip.clone(),
                    target_device: packet.dest_ip.clone(),
                    description: format!("Suspicious payload detected: {}", indicator),
                    evidence: vec![packet.clone()],
                    confidence: 0.7,
                    false_positive_risk: 0.3,
                });
            }
        }
        
        for suspicious in suspicious_strings {
            if packet.payload_hash.contains(suspicious) {
                return Some(SecurityAlert {
                    alert_id: format!("alert_{}", packet.timestamp),
                    timestamp: packet.timestamp,
                    attack_type: attack_type.clone(),
                    severity: AlertSeverity::High,
                    source_ip: packet.source_ip.clone(),
                    target_device: packet.dest_ip.clone(),
                    description: format!("Known attack pattern detected: {}", suspicious),
                    evidence: vec![packet.clone()],
                    confidence: 0.95,
                    false_positive_risk: 0.05,
                });
            }
        }
        
        None
    }
    
    fn detect_volume_anomaly(&self, packet: &NetworkPacket, packet_rate_threshold: f64, byte_rate_threshold: f64, attack_type: &AttackType) -> Option<SecurityAlert> {
        let time_window = Duration::from_secs(60); // 1分钟窗口
        let cutoff_time = packet.timestamp - time_window.as_secs();
        
        let mut packet_count = 0;
        let mut byte_count = 0;
        
        for p in self.packet_buffer.iter().rev() {
            if p.timestamp < cutoff_time {
                break;
            }
            if p.source_ip == packet.source_ip {
                packet_count += 1;
                byte_count += p.payload_size;
            }
        }
        
        let packet_rate = packet_count as f64 / time_window.as_secs() as f64;
        let byte_rate = byte_count as f64 / time_window.as_secs() as f64;
        
        if packet_rate > packet_rate_threshold || byte_rate > byte_rate_threshold {
            Some(SecurityAlert {
                alert_id: format!("alert_{}", packet.timestamp),
                timestamp: packet.timestamp,
                attack_type: attack_type.clone(),
                severity: AlertSeverity::High,
                source_ip: packet.source_ip.clone(),
                target_device: packet.dest_ip.clone(),
                description: format!("Volume anomaly detected: {:.2} pps, {:.2} bps", packet_rate, byte_rate),
                evidence: vec![packet.clone()],
                confidence: 0.8,
                false_positive_risk: 0.2,
            })
        } else {
            None
        }
    }
    
    fn detect_attack_sequence(&self, packet: &NetworkPacket, _sequence: &[String], _max_gap: Duration, attack_type: &AttackType) -> Option<SecurityAlert> {
        // 简化的序列检测实现
        // 实际需要实现状态机来跟踪攻击序列
        
        if packet.flags.contains(&"SYN".to_string()) && packet.flags.contains(&"RST".to_string()) {
            Some(SecurityAlert {
                alert_id: format!("alert_{}", packet.timestamp),
                timestamp: packet.timestamp,
                attack_type: attack_type.clone(),
                severity: AlertSeverity::Medium,
                source_ip: packet.source_ip.clone(),
                target_device: packet.dest_ip.clone(),
                description: "Suspicious packet sequence detected".to_string(),
                evidence: vec![packet.clone()],
                confidence: 0.6,
                false_positive_risk: 0.4,
            })
        } else {
            None
        }
    }
    
    fn check_behavior_anomaly(&self, packet: &NetworkPacket) -> Option<SecurityAlert> {
        if let Some(model) = self.behavior_models.get(&packet.source_ip) {
            if !model.baseline_established {
                return None; // 基线未建立，跳过检测
            }
            
            // 检查通信时间异常
            let current_hour = (packet.timestamp / 3600) % 24;
            if !model.active_hours[current_hour as usize] {
                return Some(SecurityAlert {
                    alert_id: format!("alert_{}", packet.timestamp),
                    timestamp: packet.timestamp,
                    attack_type: AttackType::SuspiciousPayload,
                    severity: AlertSeverity::Medium,
                    source_ip: packet.source_ip.clone(),
                    target_device: packet.dest_ip.clone(),
                    description: "Communication outside normal hours".to_string(),
                    evidence: vec![packet.clone()],
                    confidence: 0.7,
                    false_positive_risk: 0.3,
                });
            }
            
            // 检查未授权的通信对端
            if !model.peer_whitelist.is_empty() && !model.peer_whitelist.contains(&packet.dest_ip) {
                return Some(SecurityAlert {
                    alert_id: format!("alert_{}", packet.timestamp),
                    timestamp: packet.timestamp,
                    attack_type: AttackType::UnauthorizedAccess,
                    severity: AlertSeverity::High,
                    source_ip: packet.source_ip.clone(),
                    target_device: packet.dest_ip.clone(),
                    description: "Communication with unauthorized peer".to_string(),
                    evidence: vec![packet.clone()],
                    confidence: 0.9,
                    false_positive_risk: 0.1,
                });
            }
        }
        
        None
    }
    
    fn update_behavior_model(&mut self, packet: &NetworkPacket) {
        if let Some(model) = self.behavior_models.get_mut(&packet.source_ip) {
            let current_hour = (packet.timestamp / 3600) % 24;
            model.active_hours[current_hour as usize] = true;
            
            // 添加通信对端到白名单 (简化学习)
            if !model.peer_whitelist.contains(&packet.dest_ip) && model.peer_whitelist.len() < 100 {
                model.peer_whitelist.push(packet.dest_ip.clone());
            }
            
            model.last_updated = packet.timestamp;
            
            // 简化的基线建立逻辑
            if !model.baseline_established && model.last_updated > packet.timestamp - 86400 {
                model.baseline_established = true;
            }
        }
    }
    
    pub fn generate_detection_report(&self) -> String {
        let mut report = String::new();
        report.push_str("# IoT Intrusion Detection Report\n\n");
        
        report.push_str("## Detection Statistics\n\n");
        report.push_str(&format!("- Total packets analyzed: {}\n", self.statistics.total_packets_analyzed));
        report.push_str(&format!("- Alerts generated: {}\n", self.statistics.alerts_generated));
        report.push_str(&format!("- Detection accuracy: {:.2}%\n", self.statistics.detection_accuracy * 100.0));
        
        report.push_str("\n## Active Alerts\n\n");
        report.push_str("| Alert ID | Timestamp | Type | Severity | Source | Target |\n");
        report.push_str("|----------|-----------|------|----------|--------|--------|\n");
        
        for alert in self.active_alerts.values() {
            report.push_str(&format!(
                "| {} | {} | {:?} | {:?} | {} | {} |\n",
                alert.alert_id,
                alert.timestamp,
                alert.attack_type,
                alert.severity,
                alert.source_ip,
                alert.target_device
            ));
        }
        
        report.push_str("\n## Registered Devices\n\n");
        for (device_id, profile) in &self.device_profiles {
            report.push_str(&format!("- Device: {} (Type: {})\n", device_id, profile.device_type));
        }
        
        report
    }
}

// 默认攻击签名
pub fn create_default_signatures() -> Vec<AttackSignature> {
    vec![
        AttackSignature {
            signature_id: "port_scan_sig".to_string(),
            attack_type: AttackType::PortScan,
            pattern: SignaturePattern::PortScanPattern {
                unique_ports_threshold: 10,
                time_window: Duration::from_secs(60),
            },
            threshold: 0.8,
            time_window: Duration::from_secs(300),
        },
        AttackSignature {
            signature_id: "ddos_sig".to_string(),
            attack_type: AttackType::DDoS,
            pattern: SignaturePattern::VolumePattern {
                packet_rate_threshold: 100.0,
                byte_rate_threshold: 1000000.0,
            },
            threshold: 0.9,
            time_window: Duration::from_secs(60),
        },
        AttackSignature {
            signature_id: "malicious_payload_sig".to_string(),
            attack_type: AttackType::CommandInjection,
            pattern: SignaturePattern::PayloadPattern {
                suspicious_strings: vec![
                    "rm -rf".to_string(),
                    "wget".to_string(),
                    "curl".to_string(),
                    "/bin/sh".to_string(),
                ],
                regex_patterns: vec![
                    r".*[\x00-\x1f\x7f-\xff].*".to_string(), // 控制字符
                ],
            },
            threshold: 0.95,
            time_window: Duration::from_secs(1),
        },
    ]
}
```

## 总结 / Summary

本文档全面介绍了物联网安全的各个方面，包括：

1. **安全威胁模型**：系统化的威胁分析和风险评估框架
2. **设备身份认证**：PKI基础设施和轻量级认证协议  
3. **数据加密与隐私**：端到端加密和数据保护机制
4. **网络安全防护**：入侵检测系统和实时监控

物联网安全需要采用分层防护策略，结合预防、检测、响应和恢复等多种安全控制措施，以应对日益复杂的安全威胁。通过实施comprehensive安全框架，可以有效保护物联网系统的机密性、完整性和可用性。

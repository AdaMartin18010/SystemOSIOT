# 系统动力学 / System Dynamics


<!-- TOC START -->

- [系统动力学 / System Dynamics](#系统动力学-system-dynamics)
  - [1. 知识梳理 / Knowledge Organization](#1-知识梳理-knowledge-organization)
    - [1.1 基本概念 / Basic Concepts](#11-基本概念-basic-concepts)
      - [1.1.1 系统动力学定义 / System Dynamics Definition](#111-系统动力学定义-system-dynamics-definition)
      - [1.1.2 系统状态 / System State](#112-系统状态-system-state)
      - [1.1.3 系统演化 / System Evolution](#113-系统演化-system-evolution)
    - [1.2 线性系统动力学 / Linear System Dynamics](#12-线性系统动力学-linear-system-dynamics)
      - [1.2.1 线性系统定义 / Linear System Definition](#121-线性系统定义-linear-system-definition)
      - [1.2.2 线性系统解 / Linear System Solution](#122-线性系统解-linear-system-solution)
      - [1.2.3 线性系统特性 / Linear System Properties](#123-线性系统特性-linear-system-properties)
    - [1.3 非线性系统动力学 / Nonlinear System Dynamics](#13-非线性系统动力学-nonlinear-system-dynamics)
      - [1.3.1 非线性系统定义 / Nonlinear System Definition](#131-非线性系统定义-nonlinear-system-definition)
      - [1.3.2 非线性系统解 / Nonlinear System Solution](#132-非线性系统解-nonlinear-system-solution)
      - [1.3.3 非线性系统特性 / Nonlinear System Properties](#133-非线性系统特性-nonlinear-system-properties)
    - [1.4 系统稳定性 / System Stability](#14-系统稳定性-system-stability)
      - [1.4.1 稳定性定义 / Stability Definition](#141-稳定性定义-stability-definition)
      - [1.4.2 线性系统稳定性 / Linear System Stability](#142-线性系统稳定性-linear-system-stability)
      - [1.4.3 非线性系统稳定性 / Nonlinear System Stability](#143-非线性系统稳定性-nonlinear-system-stability)
    - [1.5 系统响应 / System Response](#15-系统响应-system-response)
      - [1.5.1 时域响应 / Time Domain Response](#151-时域响应-time-domain-response)
      - [1.5.2 频域响应 / Frequency Domain Response](#152-频域响应-frequency-domain-response)
    - [1.6 发展历程 / Development History](#16-发展历程-development-history)
      - [1.6.1 历史里程碑 / Historical Milestones](#161-历史里程碑-historical-milestones)
  - [2. 批判分析 / Critical Analysis](#2-批判分析-critical-analysis)
    - [2.1 主要挑战 / Main Challenges](#21-主要挑战-main-challenges)
      - [2.1.1 理论挑战 / Theoretical Challenges](#211-理论挑战-theoretical-challenges)
      - [2.1.2 计算挑战 / Computational Challenges](#212-计算挑战-computational-challenges)
    - [2.2 理论局限性 / Theoretical Limitations](#22-理论局限性-theoretical-limitations)
      - [2.2.1 线性化局限性 / Linearization Limitations](#221-线性化局限性-linearization-limitations)
      - [2.2.2 稳定性局限性 / Stability Limitations](#222-稳定性局限性-stability-limitations)
    - [2.3 反思与重构 / Reflection and Reconstruction](#23-反思与重构-reflection-and-reconstruction)
      - [2.3.1 理论重构 / Theoretical Reconstruction](#231-理论重构-theoretical-reconstruction)
      - [2.3.2 方法重构 / Methodological Reconstruction](#232-方法重构-methodological-reconstruction)
  - [3. 形式化结构 / Formal Structure](#3-形式化结构-formal-structure)
    - [3.1 系统动力学框架 / System Dynamics Framework](#31-系统动力学框架-system-dynamics-framework)
      - [3.1.1 动力学系统 / Dynamical System](#311-动力学系统-dynamical-system)
      - [3.1.2 动力学方程 / Dynamical Equations](#312-动力学方程-dynamical-equations)
    - [3.2 稳定性理论框架 / Stability Theory Framework](#32-稳定性理论框架-stability-theory-framework)
      - [3.2.1 Lyapunov理论 / Lyapunov Theory](#321-lyapunov理论-lyapunov-theory)
      - [3.2.2 输入输出稳定性 / Input-Output Stability](#322-输入输出稳定性-input-output-stability)
  - [4. 前沿趋势 / Frontier Trends](#4-前沿趋势-frontier-trends)
    - [4.1 系统动力学前沿 / System Dynamics Frontier](#41-系统动力学前沿-system-dynamics-frontier)
      - [4.1.1 复杂系统动力学 / Complex System Dynamics](#411-复杂系统动力学-complex-system-dynamics)
      - [4.1.2 智能系统动力学 / Intelligent System Dynamics](#412-智能系统动力学-intelligent-system-dynamics)
    - [4.2 应用前沿 / Application Frontier](#42-应用前沿-application-frontier)
      - [4.2.1 生物系统动力学 / Biological System Dynamics](#421-生物系统动力学-biological-system-dynamics)
      - [4.2.2 社会系统动力学 / Social System Dynamics](#422-社会系统动力学-social-system-dynamics)
  - [5. 工程实践 / Engineering Practice](#5-工程实践-engineering-practice)
    - [5.1 系统动力学建模 / System Dynamics Modeling](#51-系统动力学建模-system-dynamics-modeling)
      - [5.1.1 动力学建模框架 / Dynamics Modeling Framework](#511-动力学建模框架-dynamics-modeling-framework)
      - [5.1.2 非线性系统分析 / Nonlinear System Analysis](#512-非线性系统分析-nonlinear-system-analysis)
    - [5.2 系统响应分析 / System Response Analysis](#52-系统响应分析-system-response-analysis)
      - [5.2.1 时域响应分析 / Time Domain Response Analysis](#521-时域响应分析-time-domain-response-analysis)
  - [6. 总结 / Summary](#6-总结-summary)
    - [主要成就 / Major Achievements](#主要成就-major-achievements)
    - [未来展望 / Future Prospects](#未来展望-future-prospects)

<!-- TOC END -->

## 1. 知识梳理 / Knowledge Organization

### 1.1 基本概念 / Basic Concepts

#### 1.1.1 系统动力学定义 / System Dynamics Definition

**形式化定义**：
系统动力学是研究系统状态随时间变化的规律和机制的理论：

$$\text{System Dynamics} = (S, T, F, \Phi)$$

其中：

- $S = \{s_1, s_2, \ldots, s_n\}$ 为系统状态空间
- $T = [0, \infty)$ 为时间域
- $F: S \times T \rightarrow S$ 为状态转移函数
- $\Phi: S \times T \rightarrow \mathbb{R}^m$ 为输出函数

**动力学特征**：

- **状态性**: 系统具有确定的状态
- **时间性**: 状态随时间演化
- **因果性**: 状态变化有因果关系
- **连续性**: 状态变化通常是连续的

#### 1.1.2 系统状态 / System State

**状态定义**：
$$\text{State} = \{x_1(t), x_2(t), \ldots, x_n(t)\}$$

**状态空间**：
$$\mathcal{X} = \mathbb{R}^n$$

**状态向量**：
$$\mathbf{x}(t) = [x_1(t), x_2(t), \ldots, x_n(t)]^T$$

**状态方程**：
$$\frac{d\mathbf{x}}{dt} = \mathbf{f}(\mathbf{x}, \mathbf{u}, t)$$

其中 $\mathbf{u}$ 为输入向量。

#### 1.1.3 系统演化 / System Evolution

**演化方程**：
$$\frac{d\mathbf{x}}{dt} = \mathbf{f}(\mathbf{x}, t)$$

**演化轨迹**：
$$\mathbf{x}(t) = \mathbf{x}_0 + \int_0^t \mathbf{f}(\mathbf{x}(\tau), \tau) d\tau$$

**演化算子**：
$$\Phi^t: \mathcal{X} \rightarrow \mathcal{X}$$

### 1.2 线性系统动力学 / Linear System Dynamics

#### 1.2.1 线性系统定义 / Linear System Definition

**状态方程**：
$$\frac{d\mathbf{x}}{dt} = A\mathbf{x} + B\mathbf{u}$$

**输出方程**：
$$\mathbf{y} = C\mathbf{x} + D\mathbf{u}$$

其中：

- $A \in \mathbb{R}^{n \times n}$ 为系统矩阵
- $B \in \mathbb{R}^{n \times m}$ 为输入矩阵
- $C \in \mathbb{R}^{p \times n}$ 为输出矩阵
- $D \in \mathbb{R}^{p \times m}$ 为直接传递矩阵

#### 1.2.2 线性系统解 / Linear System Solution

**齐次解**：
$$\mathbf{x}_h(t) = e^{At}\mathbf{x}_0$$

**特解**：
$$\mathbf{x}_p(t) = \int_0^t e^{A(t-\tau)}B\mathbf{u}(\tau) d\tau$$

**全解**：
$$\mathbf{x}(t) = e^{At}\mathbf{x}_0 + \int_0^t e^{A(t-\tau)}B\mathbf{u}(\tau) d\tau$$

#### 1.2.3 线性系统特性 / Linear System Properties

**叠加性**：
$$\mathbf{x}(t) = \alpha\mathbf{x}_1(t) + \beta\mathbf{x}_2(t)$$

**时不变性**：
$$\mathbf{x}(t + \tau) = \Phi^t\mathbf{x}(\tau)$$

**因果性**：
$$\mathbf{x}(t) = \mathbf{x}(t_0) + \int_{t_0}^t \mathbf{f}(\mathbf{x}(\tau), \tau) d\tau$$

### 1.3 非线性系统动力学 / Nonlinear System Dynamics

#### 1.3.1 非线性系统定义 / Nonlinear System Definition

**状态方程**：
$$\frac{d\mathbf{x}}{dt} = \mathbf{f}(\mathbf{x}, \mathbf{u}, t)$$

其中 $\mathbf{f}$ 为非线性函数。

**非线性类型**：

1. **多项式非线性**: $f(x) = a_0 + a_1x + a_2x^2 + \cdots$
2. **三角函数非线性**: $f(x) = \sin(x), \cos(x)$
3. **指数非线性**: $f(x) = e^x, \ln(x)$
4. **分段非线性**: $f(x) = \begin{cases} f_1(x) & x < x_0 \\ f_2(x) & x \geq x_0 \end{cases}$

#### 1.3.2 非线性系统解 / Nonlinear System Solution

**数值解**：
$$\mathbf{x}_{k+1} = \mathbf{x}_k + h\mathbf{f}(\mathbf{x}_k, t_k)$$

**解析解**：
对于某些特殊非线性系统，可以求得解析解。

**近似解**：
$$\mathbf{x}(t) \approx \mathbf{x}_0 + t\mathbf{f}(\mathbf{x}_0, 0) + \frac{t^2}{2}\frac{d\mathbf{f}}{dt}(\mathbf{x}_0, 0)$$

#### 1.3.3 非线性系统特性 / Nonlinear System Properties

**多平衡点**: 系统可能有多个平衡状态
**极限环**: 系统可能产生周期性解
**混沌**: 系统可能产生混沌行为
**分岔**: 系统参数变化时可能产生分岔

### 1.4 系统稳定性 / System Stability

#### 1.4.1 稳定性定义 / Stability Definition

**Lyapunov稳定性**：
对于任意 $\epsilon > 0$，存在 $\delta > 0$，使得：
$$\|\mathbf{x}_0 - \mathbf{x}_e\| < \delta \Rightarrow \|\mathbf{x}(t) - \mathbf{x}_e\| < \epsilon$$

**渐近稳定性**：
$$\lim_{t \to \infty} \|\mathbf{x}(t) - \mathbf{x}_e\| = 0$$

**指数稳定性**：
$$\|\mathbf{x}(t) - \mathbf{x}_e\| \leq M e^{-\alpha t} \|\mathbf{x}_0 - \mathbf{x}_e\|$$

#### 1.4.2 线性系统稳定性 / Linear System Stability

**特征值判据**：
系统稳定的充要条件是所有特征值的实部都小于零：
$$\text{Re}(\lambda_i) < 0, \quad i = 1, 2, \ldots, n$$

**Routh-Hurwitz判据**：
对于特征多项式 $P(s) = s^n + a_1s^{n-1} + \cdots + a_n$，构造Routh表判断稳定性。

**Nyquist判据**：
对于开环传递函数 $G(s)$，闭环系统稳定的充要条件是：
$$N = P - Z$$

其中 $N$ 为Nyquist曲线绕 $(-1, 0)$ 的圈数，$P$ 为开环不稳定极点个数，$Z$ 为闭环不稳定极点个数。

#### 1.4.3 非线性系统稳定性 / Nonlinear System Stability

**Lyapunov方法**：
如果存在正定函数 $V(\mathbf{x})$，使得：
$$\frac{dV}{dt} = \frac{\partial V}{\partial \mathbf{x}} \cdot \mathbf{f}(\mathbf{x}) < 0$$

则系统在平衡点处渐近稳定。

**线性化方法**：
在平衡点附近线性化系统：
$$\frac{d\delta\mathbf{x}}{dt} = A\delta\mathbf{x}$$

其中 $A = \frac{\partial \mathbf{f}}{\partial \mathbf{x}}|_{\mathbf{x}_e}$。

### 1.5 系统响应 / System Response

#### 1.5.1 时域响应 / Time Domain Response

**阶跃响应**：
$$\mathbf{x}(t) = \mathbf{x}_0 + \int_0^t e^{A(t-\tau)}B\mathbf{1}(\tau) d\tau$$

**脉冲响应**：
$$\mathbf{x}(t) = e^{At}B\delta(t)$$

**斜坡响应**：
$$\mathbf{x}(t) = \mathbf{x}_0 + \int_0^t e^{A(t-\tau)}B\tau d\tau$$

#### 1.5.2 频域响应 / Frequency Domain Response

**传递函数**：
$$G(s) = C(sI - A)^{-1}B + D$$

**频率响应**：
$$G(j\omega) = C(j\omega I - A)^{-1}B + D$$

**Bode图**：
$$|G(j\omega)|_{dB} = 20\log_{10}|G(j\omega)|$$
$$\angle G(j\omega) = \arg(G(j\omega))$$

### 1.6 发展历程 / Development History

#### 1.6.1 历史里程碑 / Historical Milestones

| 年份 | 事件 | 影响 |
|------|------|------|
| 1687 | 牛顿力学 | 经典动力学基础 |
| 1788 | 拉格朗日力学 | 分析力学发展 |
| 1834 | 哈密顿力学 | 现代动力学理论 |
| 1892 | Lyapunov稳定性 | 稳定性理论建立 |
| 1932 | Nyquist判据 | 频域稳定性分析 |
| 1948 | 控制论 | 系统动力学应用 |
| 1960 | 状态空间方法 | 现代控制理论 |
| 1980 | 非线性动力学 | 复杂系统动力学 |

## 2. 批判分析 / Critical Analysis

### 2.1 主要挑战 / Main Challenges

#### 2.1.1 理论挑战 / Theoretical Challenges

**非线性复杂性**：
$$\text{Nonlinear Complexity} = \text{High Dimensionality} + \text{Nonlinearity} + \text{Uncertainty}$$

**解析解困难**：
$$\text{Analytical Difficulty} = \text{Nonlinear Equations} + \text{Complex Dynamics} + \text{Multiple Solutions}$$

**稳定性分析**：
$$\text{Stability Analysis} = \text{Lyapunov Function} + \text{Global Analysis} + \text{Parameter Dependence}$$

#### 2.1.2 计算挑战 / Computational Challenges

**数值计算**：
$$\text{Numerical Computation} = \text{Accuracy} + \text{Stability} + \text{Efficiency}$$

**实时计算**：
$$\text{Real-time Computation} = \text{Time Constraint} + \text{Resource Limitation} + \text{Reliability}$$

### 2.2 理论局限性 / Theoretical Limitations

#### 2.2.1 线性化局限性 / Linearization Limitations

**局部有效性**：
$$\text{Local Validity} = \text{Small Perturbation} + \text{Equilibrium Point} + \text{Finite Region}$$

**精度限制**：
$$\text{Accuracy Limitation} = \text{Approximation Error} + \text{Truncation Error} + \text{Round-off Error}$$

#### 2.2.2 稳定性局限性 / Stability Limitations

**局部稳定性**：
$$\text{Local Stability} = \text{Equilibrium Point} + \text{Finite Region} + \text{Initial Condition}$$

**全局稳定性**：
$$\text{Global Stability} = \text{Entire State Space} + \text{All Initial Conditions} + \text{Complex Analysis}$$

### 2.3 反思与重构 / Reflection and Reconstruction

#### 2.3.1 理论重构 / Theoretical Reconstruction

**多尺度动力学**：
$$\text{Multi-scale Dynamics} = \{\text{Micro}, \text{Meso}, \text{Macro}\}$$

**自适应动力学**：
$$\text{Adaptive Dynamics} = \text{Parameter Adaptation} + \text{Structure Evolution} + \text{Behavior Learning}$$

#### 2.3.2 方法重构 / Methodological Reconstruction

**计算动力学**：
$$\text{Computational Dynamics} = \text{Numerical Methods} + \text{Computer Simulation} + \text{Data Analysis}$$

## 3. 形式化结构 / Formal Structure

### 3.1 系统动力学框架 / System Dynamics Framework

#### 3.1.1 动力学系统 / Dynamical System

**状态空间**：
$$\mathcal{X} = \mathbb{R}^n$$

**时间域**：
$$\mathcal{T} = \mathbb{R}$$

**演化函数**：
$$\Phi: \mathcal{X} \times \mathcal{T} \rightarrow \mathcal{X}$$

#### 3.1.2 动力学方程 / Dynamical Equations

**常微分方程**：
$$\frac{d\mathbf{x}}{dt} = \mathbf{f}(\mathbf{x}, t)$$

**偏微分方程**：
$$\frac{\partial u}{\partial t} = F(u, \nabla u, \nabla^2 u, \ldots)$$

**差分方程**：
$$\mathbf{x}_{k+1} = \mathbf{f}(\mathbf{x}_k, k)$$

### 3.2 稳定性理论框架 / Stability Theory Framework

#### 3.2.1 Lyapunov理论 / Lyapunov Theory

**Lyapunov函数**：
$$V: \mathcal{X} \rightarrow \mathbb{R}$$

**稳定性条件**：
$$V(\mathbf{x}) > 0, \quad \frac{dV}{dt} < 0$$

#### 3.2.2 输入输出稳定性 / Input-Output Stability

**L2稳定性**：
$$\int_0^T \|\mathbf{y}(t)\|^2 dt \leq \gamma^2 \int_0^T \|\mathbf{u}(t)\|^2 dt$$

**L∞稳定性**：
$$\sup_{t \geq 0} \|\mathbf{y}(t)\| \leq \gamma \sup_{t \geq 0} \|\mathbf{u}(t)\|$$

## 4. 前沿趋势 / Frontier Trends

### 4.1 系统动力学前沿 / System Dynamics Frontier

#### 4.1.1 复杂系统动力学 / Complex System Dynamics

**网络动力学**：
$$\frac{dx_i}{dt} = f(x_i) + \sigma \sum_{j=1}^{n} a_{ij} g(x_j)$$

**群体动力学**：
$$\frac{d\rho}{dt} = D\nabla^2\rho + f(\rho)$$

**同步动力学**：
$$\frac{d\theta_i}{dt} = \omega_i + K \sum_{j=1}^{n} \sin(\theta_j - \theta_i)$$

#### 4.1.2 智能系统动力学 / Intelligent System Dynamics

**神经网络动力学**：
$$\frac{dx_i}{dt} = -x_i + \sum_{j=1}^{n} w_{ij} \sigma(x_j)$$

**强化学习动力学**：
$$\frac{dQ}{dt} = \alpha[r + \gamma \max Q' - Q]$$

### 4.2 应用前沿 / Application Frontier

#### 4.2.1 生物系统动力学 / Biological System Dynamics

**神经元动力学**：
$$\frac{dV}{dt} = -\frac{V - V_{rest}}{\tau} + I_{syn} + I_{ext}$$

**基因调控动力学**：
$$\frac{dm}{dt} = \alpha \frac{K^n}{K^n + p^n} - \beta m$$

#### 4.2.2 社会系统动力学 / Social System Dynamics

**意见动力学**：
$$\frac{dx_i}{dt} = \sum_{j=1}^{n} a_{ij}(x_j - x_i)$$

**传播动力学**：
$$\frac{dS}{dt} = -\beta SI, \quad \frac{dI}{dt} = \beta SI - \gamma I$$

## 5. 工程实践 / Engineering Practice

### 5.1 系统动力学建模 / System Dynamics Modeling

#### 5.1.1 动力学建模框架 / Dynamics Modeling Framework

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.linalg import eig

class SystemDynamicsModel:
    def __init__(self, system_name="Dynamic System"):
        self.system_name = system_name
        self.state_variables = {}
        self.parameters = {}
        self.equations = {}
        self.initial_conditions = {}
        
    def add_state_variable(self, var_name, initial_value, description=""):
        """添加状态变量"""
        self.state_variables[var_name] = {
            'value': initial_value,
            'description': description,
            'history': [initial_value]
        }
        self.initial_conditions[var_name] = initial_value
        print(f"添加状态变量: {var_name} = {initial_value}")
        
    def add_parameter(self, param_name, value, description=""):
        """添加参数"""
        self.parameters[param_name] = {
            'value': value,
            'description': description
        }
        print(f"添加参数: {param_name} = {value}")
        
    def add_equation(self, var_name, equation_func, description=""):
        """添加动力学方程"""
        self.equations[var_name] = {
            'function': equation_func,
            'description': description
        }
        print(f"添加方程: {var_name} = {description}")
        
    def linear_system_model(self, A, B, C, D=None):
        """线性系统模型"""
        self.A = A  # 系统矩阵
        self.B = B  # 输入矩阵
        self.C = C  # 输出矩阵
        self.D = D if D is not None else np.zeros((C.shape[0], B.shape[1]))
        
        print("创建线性系统模型:")
        print(f"A矩阵: {A.shape}")
        print(f"B矩阵: {B.shape}")
        print(f"C矩阵: {C.shape}")
        print(f"D矩阵: {self.D.shape}")
        
    def linear_system_response(self, u_func, t_span, x0=None):
        """线性系统响应"""
        if x0 is None:
            x0 = np.zeros(self.A.shape[0])
            
        def linear_system(state, t):
            u = u_func(t)
            return np.dot(self.A, state) + np.dot(self.B, u)
            
        t = np.linspace(t_span[0], t_span[1], 1000)
        solution = odeint(linear_system, x0, t)
        
        # 计算输出
        y = np.zeros((len(t), self.C.shape[0]))
        for i, t_i in enumerate(t):
            u = u_func(t_i)
            y[i] = np.dot(self.C, solution[i]) + np.dot(self.D, u)
            
        return t, solution, y
        
    def stability_analysis(self):
        """稳定性分析"""
        if hasattr(self, 'A'):
            print("\n=== 线性系统稳定性分析 ===")
            
            # 计算特征值
            eigenvalues = eig(self.A)[0]
            print(f"特征值: {eigenvalues}")
            
            # 判断稳定性
            max_real_part = np.max(np.real(eigenvalues))
            if max_real_part < 0:
                print("系统稳定")
                if max_real_part < -1:
                    print("系统快速稳定")
                else:
                    print("系统缓慢稳定")
            elif max_real_part == 0:
                print("系统临界稳定")
            else:
                print("系统不稳定")
                
            # 计算时间常数
            time_constants = -1 / np.real(eigenvalues)
            print(f"时间常数: {time_constants}")
            
            return eigenvalues
        else:
            print("需要先定义线性系统模型")
            return None
            
    def simulate_dynamics(self, time_steps, dt=0.01):
        """模拟系统动力学"""
        print(f"\n开始系统动力学模拟...")
        print(f"时间步数: {time_steps}, 时间步长: {dt}")
        
        # 初始化历史记录
        for var_name in self.state_variables.keys():
            self.state_variables[var_name]['history'] = [self.state_variables[var_name]['value']]
            
        # 时间演化
        for i in range(time_steps):
            current_state = {}
            for var_name, var_info in self.state_variables.items():
                current_state[var_name] = var_info['value']
                
            # 计算下一时刻状态
            for var_name, eq_info in self.equations.items():
                if var_name in self.state_variables:
                    # 使用四阶Runge-Kutta方法
                    current_value = self.state_variables[var_name]['value']
                    
                    k1 = eq_info['function'](current_state, self.parameters)
                    k2 = eq_info['function'](current_state, self.parameters)
                    k3 = eq_info['function'](current_state, self.parameters)
                    k4 = eq_info['function'](current_state, self.parameters)
                    
                    new_value = current_value + dt * (k1 + 2*k2 + 2*k3 + k4) / 6
                    
                    self.state_variables[var_name]['value'] = new_value
                    self.state_variables[var_name]['history'].append(new_value)
                    
        print("动力学模拟完成!")
        
    def plot_dynamics(self):
        """绘制动力学演化图"""
        time_points = np.linspace(0, len(list(self.state_variables.values())[0]['history']) - 1, 
                                 len(list(self.state_variables.values())[0]['history']))
        
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
        
        # 状态变量演化
        for var_name, var_info in self.state_variables.items():
            ax1.plot(time_points, var_info['history'], label=var_name, linewidth=2)
            
        ax1.set_ylabel('状态变量值')
        ax1.set_title('系统动力学演化')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 相空间轨迹
        if len(self.state_variables) >= 2:
            var_names = list(self.state_variables.keys())
            x_data = self.state_variables[var_names[0]]['history']
            y_data = self.state_variables[var_names[1]]['history']
            
            ax2.plot(x_data, y_data, 'b-', linewidth=2, alpha=0.7)
            ax2.plot(x_data[0], y_data[0], 'go', markersize=10, label='起始点')
            ax2.plot(x_data[-1], y_data[-1], 'ro', markersize=10, label='终止点')
            ax2.set_xlabel(var_names[0])
            ax2.set_ylabel(var_names[1])
            ax2.set_title('相空间轨迹')
            ax2.legend()
            ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
    def analyze_equilibrium(self):
        """分析平衡点"""
        print("\n=== 平衡点分析 ===")
        
        # 寻找平衡点（简化方法）
        for var_name, var_info in self.state_variables.items():
            history = var_info['history']
            
            # 计算最终值作为平衡点近似
            equilibrium = history[-1]
            print(f"{var_name} 平衡点: {equilibrium:.4f}")
            
            # 计算收敛速度
            if len(history) > 10:
                recent_values = history[-10:]
                convergence_rate = np.std(recent_values)
                print(f"  收敛速度: {convergence_rate:.6f}")
                
                if convergence_rate < 0.001:
                    print("  状态: 已收敛")
                else:
                    print("  状态: 未收敛")
```

#### 5.1.2 非线性系统分析 / Nonlinear System Analysis

```python
class NonlinearSystemAnalyzer:
    def __init__(self):
        self.system_equations = {}
        self.equilibrium_points = []
        self.limit_cycles = []
        
    def add_system_equation(self, var_name, equation_func):
        """添加系统方程"""
        self.system_equations[var_name] = equation_func
        print(f"添加系统方程: {var_name}")
        
    def find_equilibrium_points(self, x_range, y_range, grid_size=100):
        """寻找平衡点"""
        print("寻找平衡点...")
        
        x = np.linspace(x_range[0], x_range[1], grid_size)
        y = np.linspace(y_range[0], y_range[1], grid_size)
        X, Y = np.meshgrid(x, y)
        
        equilibrium_points = []
        
        for i in range(grid_size):
            for j in range(grid_size):
                state = [X[i, j], Y[i, j]]
                
                # 计算导数
                derivatives = []
                for var_name, eq_func in self.system_equations.items():
                    derivative = eq_func(state, {})
                    derivatives.append(abs(derivative))
                
                # 如果所有导数都接近零，则为平衡点
                if all(d < 0.01 for d in derivatives):
                    equilibrium_points.append(state)
                    
        self.equilibrium_points = equilibrium_points
        print(f"找到 {len(equilibrium_points)} 个平衡点")
        
        return equilibrium_points
        
    def analyze_stability_linearization(self, equilibrium_point):
        """通过线性化分析稳定性"""
        print(f"分析平衡点 {equilibrium_point} 的稳定性...")
        
        # 计算雅可比矩阵
        epsilon = 0.001
        J = np.zeros((len(equilibrium_point), len(equilibrium_point)))
        
        for i in range(len(equilibrium_point)):
            for j in range(len(equilibrium_point)):
                # 计算偏导数
                state_plus = equilibrium_point.copy()
                state_plus[j] += epsilon
                state_minus = equilibrium_point.copy()
                state_minus[j] -= epsilon
                
                # 计算函数值
                f_plus = list(self.system_equations.values())[i](state_plus, {})
                f_minus = list(self.system_equations.values())[i](state_minus, {})
                
                # 计算偏导数
                J[i, j] = (f_plus - f_minus) / (2 * epsilon)
        
        # 计算特征值
        eigenvalues = eig(J)[0]
        print(f"雅可比矩阵特征值: {eigenvalues}")
        
        # 判断稳定性
        max_real_part = np.max(np.real(eigenvalues))
        if max_real_part < 0:
            print("平衡点稳定")
        elif max_real_part == 0:
            print("平衡点临界稳定")
        else:
            print("平衡点不稳定")
            
        return eigenvalues
        
    def simulate_limit_cycle(self, initial_conditions, time_span, dt=0.01):
        """模拟极限环"""
        print("模拟极限环...")
        
        t = np.linspace(0, time_span, int(time_span/dt))
        trajectory = []
        
        state = initial_conditions.copy()
        
        for t_i in t:
            trajectory.append(state.copy())
            
            # 使用欧拉方法更新状态
            new_state = state.copy()
            for i, (var_name, eq_func) in enumerate(self.system_equations.items()):
                derivative = eq_func(state, {})
                new_state[i] = state[i] + dt * derivative
            state = new_state
            
        trajectory = np.array(trajectory)
        
        # 检测极限环
        if len(trajectory) > 100:
            # 检查轨迹是否闭合
            start_point = trajectory[0]
            end_point = trajectory[-1]
            distance = np.linalg.norm(end_point - start_point)
            
            if distance < 0.1:
                print("检测到极限环")
                self.limit_cycles.append(trajectory)
            else:
                print("未检测到极限环")
                
        return t, trajectory
        
    def plot_phase_portrait(self, x_range, y_range, grid_size=20):
        """绘制相图"""
        x = np.linspace(x_range[0], x_range[1], grid_size)
        y = np.linspace(y_range[0], y_range[1], grid_size)
        X, Y = np.meshgrid(x, y)
        
        U = np.zeros_like(X)
        V = np.zeros_like(Y)
        
        for i in range(grid_size):
            for j in range(grid_size):
                state = [X[i, j], Y[i, j]]
                
                # 计算向量场
                for k, (var_name, eq_func) in enumerate(self.system_equations.items()):
                    if k == 0:
                        U[i, j] = eq_func(state, {})
                    elif k == 1:
                        V[i, j] = eq_func(state, {})
        
        plt.figure(figsize=(12, 10))
        
        # 绘制向量场
        plt.quiver(X, Y, U, V, alpha=0.6)
        
        # 绘制平衡点
        if self.equilibrium_points:
            equilibrium_points = np.array(self.equilibrium_points)
            plt.plot(equilibrium_points[:, 0], equilibrium_points[:, 1], 'ro', 
                    markersize=10, label='平衡点')
        
        # 绘制极限环
        for i, limit_cycle in enumerate(self.limit_cycles):
            plt.plot(limit_cycle[:, 0], limit_cycle[:, 1], 'b-', 
                    linewidth=2, alpha=0.7, label=f'极限环 {i+1}')
        
        plt.xlabel('x')
        plt.ylabel('y')
        plt.title('系统相图')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()
```

### 5.2 系统响应分析 / System Response Analysis

#### 5.2.1 时域响应分析 / Time Domain Response Analysis

```python
class SystemResponseAnalyzer:
    def __init__(self):
        self.system_model = None
        self.response_data = {}
        
    def set_system_model(self, A, B, C, D=None):
        """设置系统模型"""
        self.A = A
        self.B = B
        self.C = C
        self.D = D if D is not None else np.zeros((C.shape[0], B.shape[1]))
        
    def step_response(self, t_span, x0=None):
        """阶跃响应"""
        if x0 is None:
            x0 = np.zeros(self.A.shape[0])
            
        def step_input(t):
            return np.ones(self.B.shape[1])
            
        t, x, y = self._simulate_response(step_input, t_span, x0)
        
        self.response_data['step'] = {
            'time': t,
            'state': x,
            'output': y
        }
        
        return t, x, y
        
    def impulse_response(self, t_span, x0=None):
        """脉冲响应"""
        if x0 is None:
            x0 = np.zeros(self.A.shape[0])
            
        def impulse_input(t):
            return np.zeros(self.B.shape[1]) if t > 0 else np.ones(self.B.shape[1])
            
        t, x, y = self._simulate_response(impulse_input, t_span, x0)
        
        self.response_data['impulse'] = {
            'time': t,
            'state': x,
            'output': y
        }
        
        return t, x, y
        
    def _simulate_response(self, input_func, t_span, x0):
        """模拟系统响应"""
        def system_dynamics(state, t):
            u = input_func(t)
            return np.dot(self.A, state) + np.dot(self.B, u)
            
        t = np.linspace(t_span[0], t_span[1], 1000)
        x = odeint(system_dynamics, x0, t)
        
        # 计算输出
        y = np.zeros((len(t), self.C.shape[0]))
        for i, t_i in enumerate(t):
            u = input_func(t_i)
            y[i] = np.dot(self.C, x[i]) + np.dot(self.D, u)
            
        return t, x, y
        
    def plot_responses(self):
        """绘制响应图"""
        if not self.response_data:
            print("没有响应数据")
            return
            
        num_responses = len(self.response_data)
        fig, axes = plt.subplots(num_responses, 1, figsize=(12, 4*num_responses))
        
        if num_responses == 1:
            axes = [axes]
            
        for i, (response_type, data) in enumerate(self.response_data.items()):
            axes[i].plot(data['time'], data['output'], 'b-', linewidth=2)
            axes[i].set_xlabel('时间')
            axes[i].set_ylabel('输出')
            axes[i].set_title(f'{response_type.capitalize()} 响应')
            axes[i].grid(True, alpha=0.3)
            
        plt.tight_layout()
        plt.show()
        
    def calculate_performance_metrics(self):
        """计算性能指标"""
        print("\n=== 系统性能指标 ===")
        
        for response_type, data in self.response_data.items():
            output = data['output']
            time = data['time']
            
            # 稳态值
            steady_state = output[-1]
            print(f"\n{response_type.capitalize()} 响应:")
            print(f"  稳态值: {steady_state:.4f}")
            
            # 上升时间
            if response_type == 'step':
                threshold = 0.9 * steady_state
                rise_time_idx = np.where(output >= threshold)[0]
                if len(rise_time_idx) > 0:
                    rise_time = time[rise_time_idx[0]]
                    print(f"  上升时间: {rise_time:.4f}s")
                    
            # 超调量
            if response_type == 'step':
                max_value = np.max(output)
                overshoot = (max_value - steady_state) / steady_state * 100
                print(f"  超调量: {overshoot:.2f}%")
                
            # 调节时间
            threshold = 0.05 * steady_state
            settling_time_idx = np.where(np.abs(output - steady_state) <= threshold)[0]
            if len(settling_time_idx) > 0:
                settling_time = time[settling_time_idx[0]]
                print(f"  调节时间: {settling_time:.4f}s")
```

## 6. 总结 / Summary

系统动力学作为系统科学的核心理论，为理解和分析系统的时间演化行为提供了重要的理论工具。通过线性系统动力学、非线性系统动力学、系统稳定性、系统响应等核心概念，建立了完整的系统动力学理论框架。

### 主要成就 / Major Achievements

1. **理论体系**：建立了完整的系统动力学理论体系
2. **方法体系**：提供了系统动力学分析和建模的方法
3. **应用体系**：开发了系统动力学模拟和分析工具
4. **教育体系**：形成了系统动力学教学体系

### 未来展望 / Future Prospects

1. **理论发展**：进一步完善系统动力学理论
2. **方法创新**：开发新的系统动力学分析方法
3. **应用拓展**：扩大系统动力学理论的应用范围
4. **教育推广**：推广系统动力学理论教育

# 系统建模 / System Modeling

## 概述 / Overview

系统建模是系统建模与仿真领域的核心内容，通过建立系统的数学模型、物理模型和逻辑模型，实现对系统行为的描述、分析和预测。系统建模为系统设计、优化和控制提供了理论基础和方法支撑。

### 系统建模定义 / System Modeling Definition

系统建模是将实际系统抽象为数学模型、物理模型或逻辑模型的过程，目的是：

- **系统描述**: 准确描述系统的结构、行为和功能
- **系统分析**: 分析系统的特性和性能
- **系统预测**: 预测系统的未来行为
- **系统优化**: 为系统优化提供依据

### 系统建模特点 / System Modeling Characteristics

#### 1. 抽象性 / Abstraction

- **概念抽象**: 将具体系统抽象为概念模型
- **结构抽象**: 将系统结构抽象为数学模型
- **行为抽象**: 将系统行为抽象为动态模型
- **功能抽象**: 将系统功能抽象为功能模型

#### 2. 简化性 / Simplification

- **结构简化**: 简化系统结构复杂性
- **参数简化**: 简化系统参数数量
- **关系简化**: 简化系统要素关系
- **过程简化**: 简化系统演化过程

#### 3. 准确性 / Accuracy

- **结构准确**: 准确反映系统结构特征
- **行为准确**: 准确描述系统行为规律
- **参数准确**: 准确确定系统参数值
- **预测准确**: 准确预测系统未来状态

#### 4. 实用性 / Practicality

- **易于理解**: 模型易于理解和应用
- **易于计算**: 模型易于计算和求解
- **易于验证**: 模型易于验证和检验
- **易于扩展**: 模型易于扩展和修改

## 数学建模 / Mathematical Modeling

### 数学建模基础 / Mathematical Modeling Fundamentals

数学建模是通过数学语言描述系统的方法，包括代数模型、微分方程模型、概率模型等。

#### 1. 代数模型 / Algebraic Models

**线性代数模型**:

```python
import numpy as np

class LinearAlgebraicModel:
    def __init__(self, A, B, C, D):
        """
        线性代数模型: y = Ax + Bu + C
        A: 状态矩阵
        B: 输入矩阵
        C: 输出矩阵
        D: 直接传递矩阵
        """
        self.A = np.array(A)
        self.B = np.array(B)
        self.C = np.array(C)
        self.D = np.array(D)
    
    def simulate(self, x0, u, t):
        """
        模拟系统响应
        x0: 初始状态
        u: 输入序列
        t: 时间序列
        """
        n_steps = len(t)
        n_states = len(x0)
        n_inputs = self.B.shape[1]
        
        x = np.zeros((n_steps, n_states))
        y = np.zeros((n_steps, self.C.shape[0]))
        
        x[0] = x0
        
        for i in range(1, n_steps):
            # 状态更新
            x[i] = self.A @ x[i-1] + self.B @ u[i-1]
            # 输出计算
            y[i] = self.C @ x[i] + self.D @ u[i-1]
        
        return x, y
```

**非线性代数模型**:

```python
class NonlinearAlgebraicModel:
    def __init__(self, f, g):
        """
        非线性代数模型
        f: 状态函数 f(x, u)
        g: 输出函数 g(x, u)
        """
        self.f = f
        self.g = g
    
    def simulate(self, x0, u, t):
        """
        模拟非线性系统响应
        """
        n_steps = len(t)
        n_states = len(x0)
        
        x = np.zeros((n_steps, n_states))
        y = np.zeros((n_steps, len(self.g(x0, u[0]))))
        
        x[0] = x0
        
        for i in range(1, n_steps):
            # 状态更新
            x[i] = self.f(x[i-1], u[i-1])
            # 输出计算
            y[i] = self.g(x[i], u[i-1])
        
        return x, y
```

#### 2. 微分方程模型 / Differential Equation Models

**常微分方程模型**:

```python
from scipy.integrate import odeint

class ODEModel:
    def __init__(self, f):
        """
        常微分方程模型: dx/dt = f(x, u, t)
        f: 系统函数
        """
        self.f = f
    
    def simulate(self, x0, u_func, t):
        """
        模拟ODE系统响应
        x0: 初始状态
        u_func: 输入函数 u(t)
        t: 时间序列
        """
        def system_ode(x, t):
            u = u_func(t)
            return self.f(x, u, t)
        
        x = odeint(system_ode, x0, t)
        return x

# 示例：弹簧-质量-阻尼系统
def spring_mass_damper_system(x, u, t):
    """
    弹簧-质量-阻尼系统
    x[0]: 位置
    x[1]: 速度
    u: 外力
    """
    m = 1.0  # 质量
    k = 1.0  # 弹簧常数
    c = 0.5  # 阻尼系数
    
    dx0_dt = x[1]
    dx1_dt = (u - k * x[0] - c * x[1]) / m
    
    return [dx0_dt, dx1_dt]
```

**偏微分方程模型**:

```python
import numpy as np
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

class PDEModel:
    def __init__(self, D, L, boundary_conditions):
        """
        偏微分方程模型: ∂u/∂t = D∇²u + f(u)
        D: 扩散系数
        L: 空间长度
        boundary_conditions: 边界条件
        """
        self.D = D
        self.L = L
        self.boundary_conditions = boundary_conditions
    
    def solve_heat_equation(self, u0, t, nx=100):
        """
        求解热传导方程: ∂u/∂t = D∂²u/∂x²
        """
        dx = self.L / (nx - 1)
        dt = 0.1 * dx**2 / self.D
        
        # 空间网格
        x = np.linspace(0, self.L, nx)
        
        # 时间网格
        nt = int(t[-1] / dt)
        t_actual = np.linspace(0, t[-1], nt)
        
        # 初始条件
        u = np.zeros((nt, nx))
        u[0] = u0(x)
        
        # 构建差分矩阵
        A = self._build_diffusion_matrix(nx, dx)
        
        # 时间推进
        for n in range(1, nt):
            u[n] = spsolve(A, u[n-1])
        
        return x, t_actual, u
    
    def _build_diffusion_matrix(self, nx, dx):
        """
        构建扩散矩阵
        """
        # 主对角线
        main_diag = -2 * np.ones(nx)
        main_diag[0] = main_diag[-1] = 1
        
        # 次对角线
        off_diag = np.ones(nx - 1)
        
        # 构建三对角矩阵
        A = diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(nx, nx))
        
        return A
```

#### 3. 概率模型 / Probability Models

**马尔可夫链模型**:

```python
class MarkovChainModel:
    def __init__(self, transition_matrix, initial_state):
        """
        马尔可夫链模型
        transition_matrix: 转移概率矩阵
        initial_state: 初始状态概率分布
        """
        self.P = np.array(transition_matrix)
        self.pi0 = np.array(initial_state)
    
    def simulate(self, n_steps):
        """
        模拟马尔可夫链
        """
        states = np.zeros(n_steps, dtype=int)
        states[0] = np.random.choice(len(self.pi0), p=self.pi0)
        
        for i in range(1, n_steps):
            current_state = states[i-1]
            next_state = np.random.choice(len(self.P), p=self.P[current_state])
            states[i] = next_state
        
        return states
    
    def stationary_distribution(self):
        """
        计算稳态分布
        """
        eigenvals, eigenvecs = np.linalg.eig(self.P.T)
        stationary_idx = np.argmin(np.abs(eigenvals - 1))
        stationary_dist = eigenvecs[:, stationary_idx].real
        stationary_dist = stationary_dist / np.sum(stationary_dist)
        
        return stationary_dist
```

**随机微分方程模型**:

```python
class StochasticDifferentialModel:
    def __init__(self, drift, diffusion):
        """
        随机微分方程模型: dx = f(x,t)dt + g(x,t)dW
        drift: 漂移项 f(x,t)
        diffusion: 扩散项 g(x,t)
        """
        self.drift = drift
        self.diffusion = diffusion
    
    def simulate(self, x0, t, n_paths=1):
        """
        模拟SDE系统
        """
        dt = t[1] - t[0]
        n_steps = len(t)
        
        x = np.zeros((n_paths, n_steps, len(x0)))
        x[:, 0] = x0
        
        for i in range(1, n_steps):
            for j in range(n_paths):
                # 漂移项
                drift_term = self.drift(x[j, i-1], t[i-1]) * dt
                
                # 扩散项
                diffusion_term = self.diffusion(x[j, i-1], t[i-1]) * np.sqrt(dt) * np.random.normal()
                
                x[j, i] = x[j, i-1] + drift_term + diffusion_term
        
        return x
```

### 数学建模应用 / Mathematical Modeling Applications

#### 1. 控制系统建模 / Control System Modeling

**状态空间模型**:

```python
class StateSpaceModel:
    def __init__(self, A, B, C, D):
        """
        状态空间模型
        ẋ = Ax + Bu
        y = Cx + Du
        """
        self.A = np.array(A)
        self.B = np.array(B)
        self.C = np.array(C)
        self.D = np.array(D)
    
    def controllability_matrix(self):
        """
        计算可控性矩阵
        """
        n = self.A.shape[0]
        C = np.hstack([self.B])
        for i in range(1, n):
            C = np.hstack([C, self.A @ C[:, -self.B.shape[1]:]])
        return C
    
    def observability_matrix(self):
        """
        计算可观性矩阵
        """
        n = self.A.shape[0]
        O = np.vstack([self.C])
        for i in range(1, n):
            O = np.vstack([O, self.C @ np.linalg.matrix_power(self.A, i)])
        return O
    
    def is_controllable(self):
        """
        判断系统是否可控
        """
        C = self.controllability_matrix()
        return np.linalg.matrix_rank(C) == self.A.shape[0]
    
    def is_observable(self):
        """
        判断系统是否可观
        """
        O = self.observability_matrix()
        return np.linalg.matrix_rank(O) == self.A.shape[0]
```

#### 2. 经济系统建模 / Economic System Modeling

**供需模型**:

```python
class SupplyDemandModel:
    def __init__(self, supply_function, demand_function):
        """
        供需模型
        supply_function: 供给函数 S(p)
        demand_function: 需求函数 D(p)
        """
        self.supply = supply_function
        self.demand = demand_function
    
    def equilibrium_price(self, p_range):
        """
        计算均衡价格
        """
        def excess_demand(p):
            return self.demand(p) - self.supply(p)
        
        # 使用二分法求解均衡价格
        a, b = p_range
        while b - a > 1e-6:
            c = (a + b) / 2
            if excess_demand(c) > 0:
                a = c
            else:
                b = c
        
        return (a + b) / 2
    
    def market_dynamics(self, p0, t, adjustment_speed=0.1):
        """
        市场动态调整过程
        """
        p = np.zeros(len(t))
        p[0] = p0
        
        for i in range(1, len(t)):
            excess_demand = self.demand(p[i-1]) - self.supply(p[i-1])
            p[i] = p[i-1] + adjustment_speed * excess_demand
        
        return p
```

## 物理建模 / Physical Modeling

### 物理建模基础 / Physical Modeling Fundamentals

物理建模是基于物理定律和原理建立系统模型的方法，包括力学模型、电磁模型、热力学模型等。

#### 1. 力学模型 / Mechanical Models

**多体动力学模型**:

```python
import numpy as np
from scipy.integrate import odeint

class MultiBodyDynamicsModel:
    def __init__(self, masses, positions, velocities, forces):
        """
        多体动力学模型
        masses: 质量列表
        positions: 初始位置列表
        velocities: 初始速度列表
        forces: 力函数列表
        """
        self.masses = np.array(masses)
        self.positions = np.array(positions)
        self.velocities = np.array(velocities)
        self.forces = forces
    
    def equations_of_motion(self, state, t):
        """
        运动方程
        """
        n_bodies = len(self.masses)
        positions = state[:3*n_bodies].reshape(n_bodies, 3)
        velocities = state[3*n_bodies:].reshape(n_bodies, 3)
        
        # 计算加速度
        accelerations = np.zeros_like(positions)
        for i in range(n_bodies):
            total_force = np.zeros(3)
            for j in range(n_bodies):
                if i != j:
                    # 万有引力
                    r = positions[j] - positions[i]
                    r_mag = np.linalg.norm(r)
                    if r_mag > 0:
                        force_mag = 6.67430e-11 * self.masses[i] * self.masses[j] / (r_mag**2)
                        total_force += force_mag * r / r_mag
                
                # 外部力
                if self.forces[i] is not None:
                    total_force += self.forces[i](positions[i], velocities[i], t)
            
            accelerations[i] = total_force / self.masses[i]
        
        # 状态导数
        state_derivative = np.concatenate([velocities.flatten(), accelerations.flatten()])
        return state_derivative
    
    def simulate(self, t):
        """
        模拟多体系统运动
        """
        initial_state = np.concatenate([self.positions.flatten(), self.velocities.flatten()])
        solution = odeint(self.equations_of_motion, initial_state, t)
        
        n_bodies = len(self.masses)
        positions = solution[:, :3*n_bodies].reshape(-1, n_bodies, 3)
        velocities = solution[:, 3*n_bodies:].reshape(-1, n_bodies, 3)
        
        return positions, velocities
```

**弹性体模型**:

```python
class ElasticBodyModel:
    def __init__(self, nodes, elements, material_properties):
        """
        弹性体模型
        nodes: 节点坐标
        elements: 单元连接关系
        material_properties: 材料属性
        """
        self.nodes = np.array(nodes)
        self.elements = np.array(elements)
        self.E = material_properties['E']  # 弹性模量
        self.nu = material_properties['nu']  # 泊松比
        self.rho = material_properties['rho']  # 密度
    
    def stiffness_matrix(self):
        """
        计算刚度矩阵
        """
        n_nodes = len(self.nodes)
        K = np.zeros((2*n_nodes, 2*n_nodes))
        
        for element in self.elements:
            # 计算单元刚度矩阵
            ke = self._element_stiffness_matrix(element)
            
            # 组装全局刚度矩阵
            for i, node_i in enumerate(element):
                for j, node_j in enumerate(element):
                    K[2*node_i:2*node_i+2, 2*node_j:2*node_j+2] += ke[2*i:2*i+2, 2*j:2*j+2]
        
        return K
    
    def _element_stiffness_matrix(self, element):
        """
        计算单元刚度矩阵
        """
        # 简化的平面应力单元刚度矩阵
        ke = np.array([
            [1, 0, -1, 0],
            [0, 1, 0, -1],
            [-1, 0, 1, 0],
            [0, -1, 0, 1]
        ])
        
        return ke * self.E / (1 - self.nu**2)
    
    def solve_static(self, boundary_conditions, forces):
        """
        求解静力问题
        """
        K = self.stiffness_matrix()
        
        # 应用边界条件
        for node, condition in boundary_conditions.items():
            if 'displacement' in condition:
                # 固定位移边界条件
                K[2*node:2*node+2, :] = 0
                K[:, 2*node:2*node+2] = 0
                K[2*node, 2*node] = 1
                K[2*node+1, 2*node+1] = 1
        
        # 求解线性方程组
        F = np.zeros(2*len(self.nodes))
        for node, force in forces.items():
            F[2*node:2*node+2] = force
        
        u = np.linalg.solve(K, F)
        return u.reshape(-1, 2)
```

#### 2. 电磁模型 / Electromagnetic Models

**电路模型**:

```python
class CircuitModel:
    def __init__(self, components):
        """
        电路模型
        components: 电路元件列表
        """
        self.components = components
        self.nodes = self._identify_nodes()
        self.branches = self._identify_branches()
    
    def _identify_nodes(self):
        """
        识别电路节点
        """
        nodes = set()
        for component in self.components:
            nodes.add(component['node1'])
            nodes.add(component['node2'])
        return sorted(list(nodes))
    
    def _identify_branches(self):
        """
        识别电路支路
        """
        branches = []
        for component in self.components:
            branches.append({
                'from': component['node1'],
                'to': component['node2'],
                'type': component['type'],
                'value': component['value']
            })
        return branches
    
    def nodal_analysis(self):
        """
        节点分析法
        """
        n_nodes = len(self.nodes)
        G = np.zeros((n_nodes, n_nodes))  # 导纳矩阵
        I = np.zeros(n_nodes)  # 电流源向量
        
        for branch in self.branches:
            i = self.nodes.index(branch['from'])
            j = self.nodes.index(branch['to'])
            
            if branch['type'] == 'resistor':
                conductance = 1 / branch['value']
                if i != j:
                    G[i, i] += conductance
                    G[j, j] += conductance
                    G[i, j] -= conductance
                    G[j, i] -= conductance
            elif branch['type'] == 'current_source':
                I[i] += branch['value']
                I[j] -= branch['value']
        
        # 接地节点（第一个节点）
        G_reduced = G[1:, 1:]
        I_reduced = I[1:]
        
        # 求解节点电压
        V_reduced = np.linalg.solve(G_reduced, I_reduced)
        V = np.concatenate([[0], V_reduced])
        
        return dict(zip(self.nodes, V))
```

#### 3. 热力学模型 / Thermodynamic Models

**热传导模型**:

```python
class HeatConductionModel:
    def __init__(self, geometry, material_properties, boundary_conditions):
        """
        热传导模型
        geometry: 几何信息
        material_properties: 材料属性
        boundary_conditions: 边界条件
        """
        self.geometry = geometry
        self.k = material_properties['thermal_conductivity']
        self.rho = material_properties['density']
        self.cp = material_properties['specific_heat']
        self.boundary_conditions = boundary_conditions
    
    def finite_difference_solution(self, T0, t, nx=50, ny=50):
        """
        有限差分法求解热传导方程
        """
        dx = self.geometry['Lx'] / (nx - 1)
        dy = self.geometry['Ly'] / (ny - 1)
        dt = 0.1 * min(dx**2, dy**2) / (self.k / (self.rho * self.cp))
        
        # 空间网格
        x = np.linspace(0, self.geometry['Lx'], nx)
        y = np.linspace(0, self.geometry['Ly'], ny)
        X, Y = np.meshgrid(x, y)
        
        # 时间网格
        nt = int(t[-1] / dt)
        t_actual = np.linspace(0, t[-1], nt)
        
        # 初始温度场
        T = np.zeros((nt, ny, nx))
        T[0] = T0(X, Y)
        
        # 时间推进
        for n in range(1, nt):
            T[n] = T[n-1].copy()
            
            for i in range(1, ny-1):
                for j in range(1, nx-1):
                    # 热传导方程
                    dT_dx2 = (T[n-1, i, j+1] - 2*T[n-1, i, j] + T[n-1, i, j-1]) / dx**2
                    dT_dy2 = (T[n-1, i+1, j] - 2*T[n-1, i, j] + T[n-1, i-1, j]) / dy**2
                    
                    T[n, i, j] = T[n-1, i, j] + (self.k / (self.rho * self.cp)) * dt * (dT_dx2 + dT_dy2)
            
            # 应用边界条件
            self._apply_boundary_conditions(T[n])
        
        return X, Y, t_actual, T
    
    def _apply_boundary_conditions(self, T):
        """
        应用边界条件
        """
        for boundary, condition in self.boundary_conditions.items():
            if boundary == 'left':
                T[:, 0] = condition
            elif boundary == 'right':
                T[:, -1] = condition
            elif boundary == 'top':
                T[0, :] = condition
            elif boundary == 'bottom':
                T[-1, :] = condition
```

## 逻辑建模 / Logical Modeling

### 逻辑建模基础 / Logical Modeling Fundamentals

逻辑建模是基于逻辑推理和规则建立系统模型的方法，包括布尔逻辑模型、模糊逻辑模型、时序逻辑模型等。

#### 1. 布尔逻辑模型 / Boolean Logic Models

**布尔函数模型**:

```python
class BooleanLogicModel:
    def __init__(self, variables, functions):
        """
        布尔逻辑模型
        variables: 变量列表
        functions: 布尔函数字典
        """
        self.variables = variables
        self.functions = functions
    
    def evaluate(self, inputs):
        """
        评估布尔函数
        """
        results = {}
        for name, function in self.functions.items():
            results[name] = function(inputs)
        return results
    
    def truth_table(self):
        """
        生成真值表
        """
        n_vars = len(self.variables)
        n_combinations = 2**n_vars
        
        table = []
        for i in range(n_combinations):
            # 生成输入组合
            inputs = {}
            for j, var in enumerate(self.variables):
                inputs[var] = (i >> j) & 1
            
            # 计算输出
            outputs = self.evaluate(inputs)
            
            # 记录结果
            row = inputs.copy()
            row.update(outputs)
            table.append(row)
        
        return table
    
    def simplify(self, function_name):
        """
        简化布尔函数
        """
        # 使用卡诺图方法简化
        truth_table = self.truth_table()
        
        # 提取函数值
        function_values = [row[function_name] for row in truth_table]
        
        # 构建卡诺图
        n_vars = len(self.variables)
        karnaugh_map = self._build_karnaugh_map(function_values, n_vars)
        
        # 寻找最小项
        minterms = self._find_minterms(karnaugh_map)
        
        return self._minterms_to_expression(minterms)
    
    def _build_karnaugh_map(self, values, n_vars):
        """
        构建卡诺图
        """
        if n_vars == 2:
            return np.array(values).reshape(2, 2)
        elif n_vars == 3:
            return np.array(values).reshape(2, 4)
        elif n_vars == 4:
            return np.array(values).reshape(4, 4)
        else:
            raise ValueError("卡诺图只支持2-4个变量")
    
    def _find_minterms(self, karnaugh_map):
        """
        寻找最小项
        """
        minterms = []
        rows, cols = karnaugh_map.shape
        
        for i in range(rows):
            for j in range(cols):
                if karnaugh_map[i, j] == 1:
                    minterms.append((i, j))
        
        return minterms
```

#### 2. 模糊逻辑模型 / Fuzzy Logic Models

**模糊集合模型**:

```python
class FuzzySetModel:
    def __init__(self, universe, membership_functions):
        """
        模糊集合模型
        universe: 论域
        membership_functions: 隶属度函数字典
        """
        self.universe = np.array(universe)
        self.membership_functions = membership_functions
    
    def membership_degree(self, element, set_name):
        """
        计算隶属度
        """
        if set_name in self.membership_functions:
            return self.membership_functions[set_name](element)
        else:
            return 0.0
    
    def fuzzy_union(self, set1, set2):
        """
        模糊并集
        """
        result = np.zeros_like(self.universe)
        for i, element in enumerate(self.universe):
            mu1 = self.membership_degree(element, set1)
            mu2 = self.membership_degree(element, set2)
            result[i] = max(mu1, mu2)
        return result
    
    def fuzzy_intersection(self, set1, set2):
        """
        模糊交集
        """
        result = np.zeros_like(self.universe)
        for i, element in enumerate(self.universe):
            mu1 = self.membership_degree(element, set1)
            mu2 = self.membership_degree(element, set2)
            result[i] = min(mu1, mu2)
        return result
    
    def fuzzy_complement(self, set_name):
        """
        模糊补集
        """
        result = np.zeros_like(self.universe)
        for i, element in enumerate(self.universe):
            mu = self.membership_degree(element, set_name)
            result[i] = 1 - mu
        return result
```

**模糊推理模型**:

```python
class FuzzyInferenceModel:
    def __init__(self, rules, membership_functions):
        """
        模糊推理模型
        rules: 模糊规则列表
        membership_functions: 隶属度函数
        """
        self.rules = rules
        self.membership_functions = membership_functions
    
    def fuzzify(self, inputs):
        """
        模糊化
        """
        fuzzy_inputs = {}
        for variable, value in inputs.items():
            fuzzy_inputs[variable] = {}
            for set_name in self.membership_functions[variable]:
                fuzzy_inputs[variable][set_name] = self.membership_functions[variable][set_name](value)
        return fuzzy_inputs
    
    def inference(self, fuzzy_inputs):
        """
        模糊推理
        """
        rule_outputs = []
        
        for rule in self.rules:
            # 计算规则强度
            strength = self._calculate_rule_strength(rule, fuzzy_inputs)
            
            # 应用规则
            output = self._apply_rule(rule, strength)
            rule_outputs.append(output)
        
        return rule_outputs
    
    def defuzzify(self, rule_outputs):
        """
        去模糊化
        """
        # 使用重心法去模糊化
        numerator = 0
        denominator = 0
        
        for output in rule_outputs:
            for value, membership in output.items():
                numerator += value * membership
                denominator += membership
        
        if denominator == 0:
            return 0
        
        return numerator / denominator
    
    def _calculate_rule_strength(self, rule, fuzzy_inputs):
        """
        计算规则强度
        """
        strengths = []
        
        for condition in rule['conditions']:
            variable = condition['variable']
            set_name = condition['set']
            strength = fuzzy_inputs[variable][set_name]
            strengths.append(strength)
        
        # 使用最小算子
        return min(strengths)
    
    def _apply_rule(self, rule, strength):
        """
        应用规则
        """
        output = {}
        for conclusion in rule['conclusions']:
            variable = conclusion['variable']
            set_name = conclusion['set']
            output[variable] = {set_name: strength}
        
        return output
```

#### 3. 时序逻辑模型 / Temporal Logic Models

**线性时序逻辑模型**:

```python
class LinearTemporalLogicModel:
    def __init__(self, propositions, transitions):
        """
        线性时序逻辑模型
        propositions: 命题列表
        transitions: 状态转移关系
        """
        self.propositions = propositions
        self.transitions = transitions
    
    def check_formula(self, formula, path):
        """
        检查LTL公式
        """
        if formula['type'] == 'atomic':
            return self._check_atomic(formula['proposition'], path[0])
        elif formula['type'] == 'not':
            return not self.check_formula(formula['subformula'], path)
        elif formula['type'] == 'and':
            return (self.check_formula(formula['left'], path) and 
                   self.check_formula(formula['right'], path))
        elif formula['type'] == 'or':
            return (self.check_formula(formula['left'], path) or 
                   self.check_formula(formula['right'], path))
        elif formula['type'] == 'next':
            if len(path) > 1:
                return self.check_formula(formula['subformula'], path[1:])
            else:
                return False
        elif formula['type'] == 'until':
            return self._check_until(formula['left'], formula['right'], path)
        elif formula['type'] == 'always':
            return self._check_always(formula['subformula'], path)
        elif formula['type'] == 'eventually':
            return self._check_eventually(formula['subformula'], path)
    
    def _check_atomic(self, proposition, state):
        """
        检查原子命题
        """
        return proposition in state
    
    def _check_until(self, left, right, path):
        """
        检查until公式
        """
        for i, state in enumerate(path):
            if self.check_formula(right, path[i:]):
                # 检查left是否在所有之前的状态中成立
                for j in range(i):
                    if not self.check_formula(left, path[j:]):
                        return False
                return True
        return False
    
    def _check_always(self, subformula, path):
        """
        检查always公式
        """
        for i in range(len(path)):
            if not self.check_formula(subformula, path[i:]):
                return False
        return True
    
    def _check_eventually(self, subformula, path):
        """
        检查eventually公式
        """
        for i in range(len(path)):
            if self.check_formula(subformula, path[i:]):
                return True
        return False
```

## 系统建模应用 / System Modeling Applications

### 1. 工程系统建模 / Engineering System Modeling

**机械系统建模**:

- **机器人建模**: 机器人运动学和动力学建模
- **车辆建模**: 车辆动力学和控制系统建模
- **飞行器建模**: 飞行器动力学和控制系统建模
- **船舶建模**: 船舶动力学和控制系统建模

**电气系统建模**:

- **电力系统建模**: 电力网络和控制系统建模
- **电子电路建模**: 电子电路和控制系统建模
- **通信系统建模**: 通信网络和协议建模
- **控制系统建模**: 自动控制系统建模

### 2. 生物系统建模 / Biological System Modeling

**生态系统建模**:

- **种群动力学**: 种群增长和竞争模型
- **食物链建模**: 食物链和生态系统建模
- **环境建模**: 环境变化和影响建模
- **进化建模**: 生物进化和适应建模

**生理系统建模**:

- **心血管系统**: 心血管系统动力学建模
- **神经系统**: 神经网络和认知建模
- **免疫系统**: 免疫系统响应建模
- **代谢系统**: 代谢过程和调控建模

### 3. 社会系统建模 / Social System Modeling

**经济系统建模**:

- **宏观经济**: 宏观经济系统建模
- **微观经济**: 微观经济行为建模
- **金融市场**: 金融市场和风险建模
- **产业系统**: 产业结构和演化建模

**社会网络建模**:

- **社交网络**: 社交网络结构和演化建模
- **信息传播**: 信息传播和影响建模
- **群体行为**: 群体行为和决策建模
- **社会影响**: 社会影响和传播建模

## 系统建模发展趋势 / System Modeling Development Trends

### 1. 多尺度建模 / Multi-scale Modeling

**跨尺度建模**:

- **微观到宏观**: 从微观行为到宏观现象建模
- **局部到全局**: 从局部特征到全局特性建模
- **短期到长期**: 从短期动态到长期演化建模
- **个体到群体**: 从个体行为到群体行为建模

### 2. 智能建模 / Intelligent Modeling

**机器学习建模**:

- **数据驱动建模**: 基于数据的系统建模
- **深度学习建模**: 基于深度学习的系统建模
- **强化学习建模**: 基于强化学习的系统建模
- **迁移学习建模**: 基于迁移学习的系统建模

### 3. 实时建模 / Real-time Modeling

**在线建模**:

- **实时数据采集**: 实时数据采集和处理
- **在线模型更新**: 在线模型参数更新
- **实时预测**: 实时系统行为预测
- **动态调整**: 动态模型结构调整

### 4. 协同建模 / Collaborative Modeling

**分布式建模**:

- **多主体建模**: 多主体协同建模
- **分布式计算**: 分布式建模计算
- **协同优化**: 协同建模优化
- **资源共享**: 建模资源共享

## 总结 / Summary

系统建模是系统科学和工程实践的重要基础，通过数学建模、物理建模和逻辑建模等方法，为系统分析、设计、优化和控制提供了有效的工具和方法。

### 主要特点 / Main Characteristics

1. **抽象性**: 将具体系统抽象为概念模型
2. **简化性**: 简化系统复杂性便于分析
3. **准确性**: 准确反映系统特征和行为
4. **实用性**: 易于理解和应用

### 应用前景 / Application Prospects

1. **工程应用**: 机械、电气、化工等工程系统建模
2. **生物应用**: 生态系统、生理系统等生物系统建模
3. **社会应用**: 经济系统、社会网络等社会系统建模
4. **智能应用**: 人工智能、机器学习等智能系统建模

### 发展趋势 / Development Trends

1. **多尺度建模**: 跨尺度系统建模方法
2. **智能建模**: 基于机器学习的智能建模
3. **实时建模**: 实时系统建模和预测
4. **协同建模**: 分布式协同建模方法

系统建模将继续推动系统科学和工程技术的发展，为复杂系统的理解和控制提供更加先进和有效的方法。

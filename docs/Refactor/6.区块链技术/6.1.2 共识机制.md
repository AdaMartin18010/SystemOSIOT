# 6.1.2 共识机制 / Consensus Mechanisms


<!-- TOC START -->

- [6.1.2 共识机制 / Consensus Mechanisms](#612-共识机制-consensus-mechanisms)
  - [6.1.2.1 共识算法理论基础 / Consensus Algorithm Theory](#6121-共识算法理论基础-consensus-algorithm-theory)
    - [6.1.2.1.1 分布式共识问题 / Distributed Consensus Problem](#61211-分布式共识问题-distributed-consensus-problem)

<!-- TOC END -->

## 6.1.2.1 共识算法理论基础 / Consensus Algorithm Theory

### 6.1.2.1.1 分布式共识问题 / Distributed Consensus Problem

**区块链共识机制分类：**

```text
区块链共识机制 (Blockchain Consensus Mechanisms)
    ├── 工作量证明类 (Proof of Work Family)
    │   ├── PoW (工作量证明)
    │   ├── PoS (权益证明)
    │   ├── DPoS (委托权益证明)
    │   └── PoA (权威证明)
    │
    ├── 拜占庭容错类 (Byzantine Fault Tolerance)
    │   ├── PBFT (实用拜占庭容错)
    │   ├── HoneyBadgerBFT
    │   ├── Tendermint
    │   └── HotStuff
    │
    ├── 混合共识类 (Hybrid Consensus)
    │   ├── PoW + PoS
    │   ├── PBFT + DPoS
    │   ├── 分片共识
    │   └── 分层共识
    │
    └── 新兴共识类 (Emerging Consensus)
        ├── PoSpace (空间证明)
        ├── PoHistory (历史证明)
        ├── VDF (可验证延迟函数)
        └── 量子共识
```

**共识系统核心实现：**

```rust
use std::collections::{HashMap, BTreeMap, VecDeque, HashSet};
use std::sync::{Arc, RwLock, Mutex};
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::hash::{Hash, Hasher};
use sha3::{Sha3_256, Digest};
use serde::{Serialize, Deserialize};
use tokio::sync::mpsc;

// 共识引擎
#[derive(Debug)]
pub struct ConsensusEngine {
    pub engine_id: String,
    pub consensus_algorithm: Box<dyn ConsensusAlgorithm + Send + Sync>,
    pub blockchain: Arc<RwLock<Blockchain>>,
    pub mempool: Arc<RwLock<MemoryPool>>,
    pub network: Arc<NetworkLayer>,
    pub validator_set: Arc<RwLock<ValidatorSet>>,
    pub consensus_state: Arc<RwLock<ConsensusState>>,
    pub metrics: Arc<Mutex<ConsensusMetrics>>,
}

// 共识算法特征
pub trait ConsensusAlgorithm: Send + Sync {
    fn algorithm_name(&self) -> &'static str;
    fn propose_block(&self, transactions: Vec<Transaction>) -> Result<Block, ConsensusError>;
    fn validate_block(&self, block: &Block) -> Result<bool, ConsensusError>;
    fn finalize_block(&self, block: Block) -> Result<(), ConsensusError>;
    fn handle_consensus_message(&self, message: ConsensusMessage) -> Result<ConsensusResponse, ConsensusError>;
    fn get_consensus_parameters(&self) -> ConsensusParameters;
}

// 区块链数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Blockchain {
    pub chain: Vec<Block>,
    pub block_index: HashMap<String, usize>,
    pub height: u64,
    pub difficulty: u64,
    pub total_work: u128,
    pub state_root: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub header: BlockHeader,
    pub transactions: Vec<Transaction>,
    pub consensus_data: ConsensusData,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockHeader {
    pub version: u32,
    pub previous_hash: String,
    pub merkle_root: String,
    pub timestamp: SystemTime,
    pub height: u64,
    pub nonce: u64,
    pub difficulty: u64,
    pub state_root: String,
    pub transaction_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub fee: u64,
    pub timestamp: SystemTime,
    pub signature: String,
    pub nonce: u64,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsensusData {
    PoW { nonce: u64, mix_hash: String },
    PoS { validator_signature: String, stake_proof: StakeProof },
    DPoS { delegate_votes: Vec<DelegateVote>, witness_signatures: Vec<String> },
    PBFT { view: u64, prepare_votes: Vec<PBFTVote>, commit_votes: Vec<PBFTVote> },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StakeProof {
    pub validator_id: String,
    pub stake_amount: u64,
    pub randomness: String,
    pub vrf_proof: String, // 可验证随机函数证明
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DelegateVote {
    pub voter_id: String,
    pub delegate_id: String,
    pub stake_amount: u64,
    pub timestamp: SystemTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PBFTVote {
    pub voter_id: String,
    pub block_hash: String,
    pub view: u64,
    pub vote_type: PBFTVoteType,
    pub signature: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PBFTVoteType {
    Prepare,
    Commit,
    ViewChange,
}

// 工作量证明 (PoW) 实现
#[derive(Debug)]
pub struct ProofOfWork {
    pub difficulty_target: u64,
    pub block_time_target: Duration,
    pub difficulty_adjustment_interval: u64,
    pub hash_algorithm: HashAlgorithm,
    pub mining_reward: u64,
}

#[derive(Debug, Clone)]
pub enum HashAlgorithm {
    SHA256,
    Ethash,
    Scrypt,
    Blake2b,
    X11,
}

impl ProofOfWork {
    pub fn new() -> Self {
        Self {
            difficulty_target: 0x00000000FFFF0000, // 初始难度
            block_time_target: Duration::from_secs(600), // 10分钟
            difficulty_adjustment_interval: 2016, // 每2016个块调整一次
            hash_algorithm: HashAlgorithm::SHA256,
            mining_reward: 50 * 100000000, // 50个币，8位小数
        }
    }
    
    pub fn mine_block(&self, block: &mut Block) -> Result<(), ConsensusError> {
        println!("开始挖矿，目标难度: {:016x}", self.difficulty_target);
        
        let start_time = SystemTime::now();
        let mut nonce = 0u64;
        let mut attempts = 0u64;
        
        loop {
            block.header.nonce = nonce;
            let block_hash = self.calculate_block_hash(&block.header)?;
            
            if self.meets_difficulty_target(&block_hash) {
                // 找到有效哈希
                if let ConsensusData::PoW { ref mut nonce, ref mut mix_hash } = block.consensus_data {
                    *nonce = block.header.nonce;
                    *mix_hash = block_hash;
                }
                
                let mining_time = start_time.elapsed().unwrap();
                println!("挖矿成功! 哈希: {}, Nonce: {}, 尝试次数: {}, 用时: {:?}", 
                    block_hash, block.header.nonce, attempts, mining_time);
                
                return Ok(());
            }
            
            nonce += 1;
            attempts += 1;
            
            // 防止无限循环
            if attempts % 100000 == 0 {
                println!("已尝试 {} 次，当前哈希: {}", attempts, block_hash);
                
                // 模拟挖矿中断检查
                if attempts > 1000000 {
                    return Err(ConsensusError::MiningTimeout);
                }
            }
        }
    }
    
    fn calculate_block_hash(&self, header: &BlockHeader) -> Result<String, ConsensusError> {
        match self.hash_algorithm {
            HashAlgorithm::SHA256 => self.sha256_hash(header),
            HashAlgorithm::Ethash => self.ethash_hash(header),
            _ => self.sha256_hash(header), // 默认使用SHA256
        }
    }
    
    fn sha256_hash(&self, header: &BlockHeader) -> Result<String, ConsensusError> {
        let header_bytes = self.serialize_header(header)?;
        let mut hasher = Sha3_256::new();
        hasher.update(&header_bytes);
        let result = hasher.finalize();
        Ok(format!("{:x}", result))
    }
    
    fn ethash_hash(&self, header: &BlockHeader) -> Result<String, ConsensusError> {
        // 简化的Ethash实现 (实际Ethash更复杂，需要DAG)
        let header_bytes = self.serialize_header(header)?;
        let mut hasher = Sha3_256::new();
        hasher.update(&header_bytes);
        hasher.update(&header.nonce.to_le_bytes());
        let result = hasher.finalize();
        Ok(format!("{:x}", result))
    }
    
    fn serialize_header(&self, header: &BlockHeader) -> Result<Vec<u8>, ConsensusError> {
        // 简化的序列化实现
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&header.version.to_le_bytes());
        bytes.extend_from_slice(header.previous_hash.as_bytes());
        bytes.extend_from_slice(header.merkle_root.as_bytes());
        bytes.extend_from_slice(&header.timestamp.duration_since(UNIX_EPOCH).unwrap().as_secs().to_le_bytes());
        bytes.extend_from_slice(&header.height.to_le_bytes());
        bytes.extend_from_slice(&header.nonce.to_le_bytes());
        bytes.extend_from_slice(&header.difficulty.to_le_bytes());
        Ok(bytes)
    }
    
    fn meets_difficulty_target(&self, hash: &str) -> bool {
        // 检查哈希是否满足难度目标
        if hash.len() < 16 {
            return false;
        }
        
        if let Ok(hash_num) = u64::from_str_radix(&hash[0..16], 16) {
            hash_num < self.difficulty_target
        } else {
            false
        }
    }
    
    pub fn adjust_difficulty(&mut self, blockchain: &Blockchain) -> Result<(), ConsensusError> {
        if blockchain.height % self.difficulty_adjustment_interval != 0 {
            return Ok(());
        }
        
        if blockchain.chain.len() < self.difficulty_adjustment_interval as usize {
            return Ok(());
        }
        
        let latest_block = &blockchain.chain[blockchain.chain.len() - 1];
        let past_block = &blockchain.chain[blockchain.chain.len() - self.difficulty_adjustment_interval as usize];
        
        let time_taken = latest_block.header.timestamp
            .duration_since(past_block.header.timestamp)
            .unwrap();
        
        let expected_time = self.block_time_target * self.difficulty_adjustment_interval as u32;
        
        let ratio = time_taken.as_secs() as f64 / expected_time.as_secs() as f64;
        
        // 限制调整幅度 (最多4倍调整)
        let adjustment_factor = ratio.max(0.25).min(4.0);
        
        self.difficulty_target = ((self.difficulty_target as f64) / adjustment_factor) as u64;
        
        println!("难度调整: 比率={:.2}, 新难度={:016x}", adjustment_factor, self.difficulty_target);
        
        Ok(())
    }
}

impl ConsensusAlgorithm for ProofOfWork {
    fn algorithm_name(&self) -> &'static str {
        "Proof of Work"
    }
    
    fn propose_block(&self, transactions: Vec<Transaction>) -> Result<Block, ConsensusError> {
        let merkle_root = self.calculate_merkle_root(&transactions)?;
        
        let mut block = Block {
            header: BlockHeader {
                version: 1,
                previous_hash: String::new(), // 需要从区块链获取
                merkle_root,
                timestamp: SystemTime::now(),
                height: 0, // 需要从区块链获取
                nonce: 0,
                difficulty: self.difficulty_target,
                state_root: String::new(),
                transaction_count: transactions.len() as u32,
            },
            transactions,
            consensus_data: ConsensusData::PoW { 
                nonce: 0, 
                mix_hash: String::new() 
            },
        };
        
        // 挖矿
        self.mine_block(&mut block)?;
        
        Ok(block)
    }
    
    fn validate_block(&self, block: &Block) -> Result<bool, ConsensusError> {
        // 1. 验证区块结构
        if block.transactions.len() != block.header.transaction_count as usize {
            return Ok(false);
        }
        
        // 2. 验证Merkle根
        let calculated_merkle_root = self.calculate_merkle_root(&block.transactions)?;
        if calculated_merkle_root != block.header.merkle_root {
            return Ok(false);
        }
        
        // 3. 验证工作量证明
        if let ConsensusData::PoW { nonce, mix_hash } = &block.consensus_data {
            let mut test_header = block.header.clone();
            test_header.nonce = *nonce;
            
            let calculated_hash = self.calculate_block_hash(&test_header)?;
            if calculated_hash != *mix_hash {
                return Ok(false);
            }
            
            if !self.meets_difficulty_target(&calculated_hash) {
                return Ok(false);
            }
        } else {
            return Ok(false);
        }
        
        // 4. 验证所有交易
        for tx in &block.transactions {
            if !self.validate_transaction(tx)? {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    fn finalize_block(&self, block: Block) -> Result<(), ConsensusError> {
        println!("区块 {} 已确认，高度: {}", 
            self.calculate_block_hash(&block.header)?, 
            block.header.height);
        Ok(())
    }
    
    fn handle_consensus_message(&self, message: ConsensusMessage) -> Result<ConsensusResponse, ConsensusError> {
        match message.message_type {
            ConsensusMessageType::BlockProposal => {
                // 处理新区块提议
                Ok(ConsensusResponse::Accepted)
            }
            ConsensusMessageType::DifficultyUpdate => {
                // 处理难度更新
                Ok(ConsensusResponse::Accepted)
            }
            _ => Ok(ConsensusResponse::Ignored),
        }
    }
    
    fn get_consensus_parameters(&self) -> ConsensusParameters {
        ConsensusParameters {
            block_time: self.block_time_target,
            finality_time: self.block_time_target * 6, // 6个确认
            throughput_tps: 7.0, // Bitcoin大约7 TPS
            energy_efficiency: EnergyEfficiency::Low,
            decentralization_level: DecentralizationLevel::High,
            security_model: SecurityModel::Probabilistic,
        }
    }
}

impl ProofOfWork {
    fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Result<String, ConsensusError> {
        if transactions.is_empty() {
            return Ok(String::new());
        }
        
        let mut hashes: Vec<String> = transactions.iter()
            .map(|tx| self.calculate_transaction_hash(tx))
            .collect::<Result<Vec<_>, _>>()?;
        
        while hashes.len() > 1 {
            let mut next_level = Vec::new();
            
            for chunk in hashes.chunks(2) {
                let combined = if chunk.len() == 2 {
                    format!("{}{}", chunk[0], chunk[1])
                } else {
                    format!("{}{}", chunk[0], chunk[0]) // 奇数个哈希时重复最后一个
                };
                
                let mut hasher = Sha3_256::new();
                hasher.update(combined.as_bytes());
                next_level.push(format!("{:x}", hasher.finalize()));
            }
            
            hashes = next_level;
        }
        
        Ok(hashes.into_iter().next().unwrap_or_default())
    }
    
    fn calculate_transaction_hash(&self, tx: &Transaction) -> Result<String, ConsensusError> {
        let tx_bytes = format!("{}{}{}{}{}", 
            tx.from, tx.to, tx.amount, tx.fee, tx.nonce);
        
        let mut hasher = Sha3_256::new();
        hasher.update(tx_bytes.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }
    
    fn validate_transaction(&self, tx: &Transaction) -> Result<bool, ConsensusError> {
        // 基本的交易验证
        if tx.amount == 0 && tx.fee == 0 {
            return Ok(false);
        }
        
        if tx.from == tx.to {
            return Ok(false);
        }
        
        // 简化的签名验证
        if tx.signature.is_empty() {
            return Ok(false);
        }
        
        Ok(true)
    }
}

// 权益证明 (PoS) 实现
#[derive(Debug)]
pub struct ProofOfStake {
    pub minimum_stake: u64,
    pub slot_duration: Duration,
    pub epoch_duration: Duration,
    pub slashing_conditions: Vec<SlashingCondition>,
    pub reward_rate: f64,
    pub validator_selection_algorithm: ValidatorSelectionAlgorithm,
}

#[derive(Debug, Clone)]
pub enum SlashingCondition {
    DoubleProposal,
    DoubleVote,
    SurroundVote,
    LongRangeAttack,
}

#[derive(Debug, Clone)]
pub enum ValidatorSelectionAlgorithm {
    RandomizedProof,
    CASPER_FFG,
    Ouroboros,
    Algorand,
}

impl ProofOfStake {
    pub fn new() -> Self {
        Self {
            minimum_stake: 32 * 1_000_000_000, // 32 ETH (in wei)
            slot_duration: Duration::from_secs(12),
            epoch_duration: Duration::from_secs(12 * 32), // 32 slots per epoch
            slashing_conditions: vec![
                SlashingCondition::DoubleProposal,
                SlashingCondition::DoubleVote,
                SlashingCondition::SurroundVote,
            ],
            reward_rate: 0.05, // 5% annual reward
            validator_selection_algorithm: ValidatorSelectionAlgorithm::RandomizedProof,
        }
    }
    
    pub fn select_validator(&self, validators: &ValidatorSet, slot: u64) -> Result<String, ConsensusError> {
        match self.validator_selection_algorithm {
            ValidatorSelectionAlgorithm::RandomizedProof => {
                self.randomized_validator_selection(validators, slot)
            }
            ValidatorSelectionAlgorithm::Ouroboros => {
                self.ouroboros_validator_selection(validators, slot)
            }
            _ => self.randomized_validator_selection(validators, slot),
        }
    }
    
    fn randomized_validator_selection(&self, validators: &ValidatorSet, slot: u64) -> Result<String, ConsensusError> {
        let eligible_validators: Vec<_> = validators.validators.iter()
            .filter(|(_, validator)| validator.is_active && validator.stake >= self.minimum_stake)
            .collect();
        
        if eligible_validators.is_empty() {
            return Err(ConsensusError::NoEligibleValidators);
        }
        
        // 基于stake的加权随机选择
        let total_stake: u64 = eligible_validators.iter()
            .map(|(_, validator)| validator.stake)
            .sum();
        
        let seed = self.generate_randomness(slot)?;
        let target = (seed as u128 * total_stake as u128) / (u64::MAX as u128);
        
        let mut cumulative_stake = 0u64;
        for (validator_id, validator) in eligible_validators {
            cumulative_stake += validator.stake;
            if cumulative_stake >= target as u64 {
                return Ok(validator_id.clone());
            }
        }
        
        // 回退到第一个验证者
        Ok(eligible_validators[0].0.clone())
    }
    
    fn ouroboros_validator_selection(&self, validators: &ValidatorSet, slot: u64) -> Result<String, ConsensusError> {
        // Ouroboros风格的验证者选择
        let eligible_validators: Vec<_> = validators.validators.iter()
            .filter(|(_, validator)| validator.is_active && validator.stake >= self.minimum_stake)
            .collect();
        
        if eligible_validators.is_empty() {
            return Err(ConsensusError::NoEligibleValidators);
        }
        
        // 使用VRF (可验证随机函数)
        for (validator_id, validator) in eligible_validators {
            let vrf_output = self.compute_vrf(validator_id, slot)?;
            let threshold = self.calculate_selection_threshold(validator.stake, validators.total_stake);
            
            if vrf_output < threshold {
                return Ok(validator_id.clone());
            }
        }
        
        Err(ConsensusError::NoValidatorSelected)
    }
    
    fn generate_randomness(&self, slot: u64) -> Result<u64, ConsensusError> {
        // 简化的随机数生成 (实际实现需要RANDAO或VDF)
        let mut hasher = Sha3_256::new();
        hasher.update(&slot.to_le_bytes());
        hasher.update(b"beacon_randomness");
        let hash = hasher.finalize();
        
        let mut bytes = [0u8; 8];
        bytes.copy_from_slice(&hash[0..8]);
        Ok(u64::from_le_bytes(bytes))
    }
    
    fn compute_vrf(&self, validator_id: &str, slot: u64) -> Result<f64, ConsensusError> {
        // 简化的VRF计算
        let mut hasher = Sha3_256::new();
        hasher.update(validator_id.as_bytes());
        hasher.update(&slot.to_le_bytes());
        let hash = hasher.finalize();
        
        let mut bytes = [0u8; 8];
        bytes.copy_from_slice(&hash[0..8]);
        let value = u64::from_le_bytes(bytes);
        
        Ok(value as f64 / u64::MAX as f64)
    }
    
    fn calculate_selection_threshold(&self, validator_stake: u64, total_stake: u64) -> f64 {
        // 计算验证者被选中的阈值
        (validator_stake as f64 / total_stake as f64) * 0.5 // 简化的阈值计算
    }
    
    pub fn process_attestation(&self, attestation: &Attestation) -> Result<(), ConsensusError> {
        // 处理见证 (attestation)
        println!("处理见证: 验证者={}, 目标={}, 源={}", 
            attestation.validator_id, attestation.target_checkpoint, attestation.source_checkpoint);
        
        // 验证见证的有效性
        self.validate_attestation(attestation)?;
        
        // 检查双重投票等恶意行为
        self.check_slashing_conditions(attestation)?;
        
        Ok(())
    }
    
    fn validate_attestation(&self, attestation: &Attestation) -> Result<(), ConsensusError> {
        // 验证见证签名
        if attestation.signature.is_empty() {
            return Err(ConsensusError::InvalidAttestation);
        }
        
        // 验证时间窗口
        let now = SystemTime::now();
        let attestation_age = now.duration_since(attestation.timestamp)
            .map_err(|_| ConsensusError::InvalidTimestamp)?;
        
        if attestation_age > Duration::from_secs(64) { // 最多64秒延迟
            return Err(ConsensusError::AttestationTooOld);
        }
        
        Ok(())
    }
    
    fn check_slashing_conditions(&self, attestation: &Attestation) -> Result<(), ConsensusError> {
        // 检查双重投票
        if self.has_conflicting_attestation(attestation) {
            self.slash_validator(&attestation.validator_id, SlashingCondition::DoubleVote)?;
        }
        
        // 检查围绕投票
        if self.has_surround_vote(attestation) {
            self.slash_validator(&attestation.validator_id, SlashingCondition::SurroundVote)?;
        }
        
        Ok(())
    }
    
    fn has_conflicting_attestation(&self, _attestation: &Attestation) -> bool {
        // 简化实现 - 实际需要检查历史见证记录
        false
    }
    
    fn has_surround_vote(&self, _attestation: &Attestation) -> bool {
        // 简化实现 - 实际需要检查见证的源和目标关系
        false
    }
    
    fn slash_validator(&self, validator_id: &str, condition: SlashingCondition) -> Result<(), ConsensusError> {
        println!("惩罚验证者 {} 因为 {:?}", validator_id, condition);
        
        // 实际实现需要：
        // 1. 扣除验证者的部分质押
        // 2. 暂时禁用验证者
        // 3. 记录惩罚事件
        
        Ok(())
    }
}

impl ConsensusAlgorithm for ProofOfStake {
    fn algorithm_name(&self) -> &'static str {
        "Proof of Stake"
    }
    
    fn propose_block(&self, transactions: Vec<Transaction>) -> Result<Block, ConsensusError> {
        let merkle_root = self.calculate_merkle_root(&transactions)?;
        
        let block = Block {
            header: BlockHeader {
                version: 1,
                previous_hash: String::new(),
                merkle_root,
                timestamp: SystemTime::now(),
                height: 0,
                nonce: 0,
                difficulty: 0, // PoS不使用难度
                state_root: String::new(),
                transaction_count: transactions.len() as u32,
            },
            transactions,
            consensus_data: ConsensusData::PoS { 
                validator_signature: "validator_sig".to_string(),
                stake_proof: StakeProof {
                    validator_id: "validator_1".to_string(),
                    stake_amount: self.minimum_stake,
                    randomness: "random_proof".to_string(),
                    vrf_proof: "vrf_proof".to_string(),
                },
            },
        };
        
        Ok(block)
    }
    
    fn validate_block(&self, block: &Block) -> Result<bool, ConsensusError> {
        // 验证PoS特定内容
        if let ConsensusData::PoS { validator_signature, stake_proof } = &block.consensus_data {
            // 验证验证者签名
            if validator_signature.is_empty() {
                return Ok(false);
            }
            
            // 验证stake证明
            if stake_proof.stake_amount < self.minimum_stake {
                return Ok(false);
            }
            
            // 验证VRF证明
            if stake_proof.vrf_proof.is_empty() {
                return Ok(false);
            }
        } else {
            return Ok(false);
        }
        
        // 验证交易
        for tx in &block.transactions {
            if !self.validate_transaction(tx)? {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    fn finalize_block(&self, block: Block) -> Result<(), ConsensusError> {
        println!("PoS区块已最终确认，高度: {}", block.header.height);
        Ok(())
    }
    
    fn handle_consensus_message(&self, message: ConsensusMessage) -> Result<ConsensusResponse, ConsensusError> {
        match message.message_type {
            ConsensusMessageType::Attestation => {
                // 处理见证消息
                Ok(ConsensusResponse::Accepted)
            }
            ConsensusMessageType::ValidatorRegistration => {
                // 处理验证者注册
                Ok(ConsensusResponse::Accepted)
            }
            _ => Ok(ConsensusResponse::Ignored),
        }
    }
    
    fn get_consensus_parameters(&self) -> ConsensusParameters {
        ConsensusParameters {
            block_time: self.slot_duration,
            finality_time: self.epoch_duration * 2, // 2个epoch确认
            throughput_tps: 1000.0, // 更高的TPS
            energy_efficiency: EnergyEfficiency::High,
            decentralization_level: DecentralizationLevel::Medium,
            security_model: SecurityModel::Deterministic,
        }
    }
}

impl ProofOfStake {
    fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Result<String, ConsensusError> {
        if transactions.is_empty() {
            return Ok(String::new());
        }
        
        let mut hashes: Vec<String> = transactions.iter()
            .map(|tx| self.calculate_transaction_hash(tx))
            .collect::<Result<Vec<_>, _>>()?;
        
        while hashes.len() > 1 {
            let mut next_level = Vec::new();
            
            for chunk in hashes.chunks(2) {
                let combined = if chunk.len() == 2 {
                    format!("{}{}", chunk[0], chunk[1])
                } else {
                    format!("{}{}", chunk[0], chunk[0])
                };
                
                let mut hasher = Sha3_256::new();
                hasher.update(combined.as_bytes());
                next_level.push(format!("{:x}", hasher.finalize()));
            }
            
            hashes = next_level;
        }
        
        Ok(hashes.into_iter().next().unwrap_or_default())
    }
    
    fn calculate_transaction_hash(&self, tx: &Transaction) -> Result<String, ConsensusError> {
        let tx_bytes = format!("{}{}{}{}{}", 
            tx.from, tx.to, tx.amount, tx.fee, tx.nonce);
        
        let mut hasher = Sha3_256::new();
        hasher.update(tx_bytes.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }
    
    fn validate_transaction(&self, tx: &Transaction) -> Result<bool, ConsensusError> {
        if tx.amount == 0 && tx.fee == 0 {
            return Ok(false);
        }
        
        if tx.from == tx.to {
            return Ok(false);
        }
        
        if tx.signature.is_empty() {
            return Ok(false);
        }
        
        Ok(true)
    }
}

// 委托权益证明 (DPoS) 实现
#[derive(Debug)]
pub struct DelegatedProofOfStake {
    pub witness_count: u32,
    pub voting_period: Duration,
    pub block_interval: Duration,
    pub delegate_reward_rate: f64,
    pub voter_reward_rate: f64,
    pub minimum_vote_threshold: u64,
}

impl DelegatedProofOfStake {
    pub fn new() -> Self {
        Self {
            witness_count: 21, // 类似EOS的21个超级节点
            voting_period: Duration::from_secs(3600 * 24), // 24小时投票周期
            block_interval: Duration::from_millis(500), // 0.5秒出块
            delegate_reward_rate: 0.05,
            voter_reward_rate: 0.01,
            minimum_vote_threshold: 1000_000, // 最少投票数
        }
    }
    
    pub fn elect_witnesses(&self, votes: &[DelegateVote]) -> Result<Vec<String>, ConsensusError> {
        // 统计投票
        let mut vote_counts: HashMap<String, u64> = HashMap::new();
        
        for vote in votes {
            if vote.stake_amount >= self.minimum_vote_threshold {
                *vote_counts.entry(vote.delegate_id.clone()).or_insert(0) += vote.stake_amount;
            }
        }
        
        // 选出得票最多的见证人
        let mut candidates: Vec<_> = vote_counts.into_iter().collect();
        candidates.sort_by(|a, b| b.1.cmp(&a.1));
        
        let witnesses = candidates.into_iter()
            .take(self.witness_count as usize)
            .map(|(delegate_id, _)| delegate_id)
            .collect();
        
        println!("选举出 {} 个见证人", witnesses.len());
        Ok(witnesses)
    }
    
    pub fn schedule_witness(&self, witnesses: &[String], slot: u64) -> Result<String, ConsensusError> {
        if witnesses.is_empty() {
            return Err(ConsensusError::NoWitnesses);
        }
        
        let witness_index = (slot as usize) % witnesses.len();
        Ok(witnesses[witness_index].clone())
    }
    
    pub fn validate_witness_signature(&self, block: &Block, witness_id: &str) -> Result<bool, ConsensusError> {
        if let ConsensusData::DPoS { witness_signatures, .. } = &block.consensus_data {
            // 检查见证人签名
            for signature in witness_signatures {
                if signature.contains(witness_id) {
                    return Ok(true);
                }
            }
        }
        
        Ok(false)
    }
}

impl ConsensusAlgorithm for DelegatedProofOfStake {
    fn algorithm_name(&self) -> &'static str {
        "Delegated Proof of Stake"
    }
    
    fn propose_block(&self, transactions: Vec<Transaction>) -> Result<Block, ConsensusError> {
        let merkle_root = self.calculate_merkle_root(&transactions)?;
        
        let block = Block {
            header: BlockHeader {
                version: 1,
                previous_hash: String::new(),
                merkle_root,
                timestamp: SystemTime::now(),
                height: 0,
                nonce: 0,
                difficulty: 0,
                state_root: String::new(),
                transaction_count: transactions.len() as u32,
            },
            transactions,
            consensus_data: ConsensusData::DPoS { 
                delegate_votes: vec![],
                witness_signatures: vec!["witness_1_sig".to_string()],
            },
        };
        
        Ok(block)
    }
    
    fn validate_block(&self, block: &Block) -> Result<bool, ConsensusError> {
        if let ConsensusData::DPoS { witness_signatures, .. } = &block.consensus_data {
            if witness_signatures.is_empty() {
                return Ok(false);
            }
        } else {
            return Ok(false);
        }
        
        // 验证交易
        for tx in &block.transactions {
            if !self.validate_transaction(tx)? {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    fn finalize_block(&self, block: Block) -> Result<(), ConsensusError> {
        println!("DPoS区块已确认，高度: {}", block.header.height);
        Ok(())
    }
    
    fn handle_consensus_message(&self, message: ConsensusMessage) -> Result<ConsensusResponse, ConsensusError> {
        match message.message_type {
            ConsensusMessageType::WitnessVote => {
                Ok(ConsensusResponse::Accepted)
            }
            ConsensusMessageType::DelegateRegistration => {
                Ok(ConsensusResponse::Accepted)
            }
            _ => Ok(ConsensusResponse::Ignored),
        }
    }
    
    fn get_consensus_parameters(&self) -> ConsensusParameters {
        ConsensusParameters {
            block_time: self.block_interval,
            finality_time: Duration::from_secs(3), // 快速确认
            throughput_tps: 2000.0, // 高TPS
            energy_efficiency: EnergyEfficiency::High,
            decentralization_level: DecentralizationLevel::Low, // 相对中心化
            security_model: SecurityModel::Deterministic,
        }
    }
}

impl DelegatedProofOfStake {
    fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Result<String, ConsensusError> {
        // 与PoW/PoS相同的实现
        if transactions.is_empty() {
            return Ok(String::new());
        }
        
        let mut hashes: Vec<String> = transactions.iter()
            .map(|tx| self.calculate_transaction_hash(tx))
            .collect::<Result<Vec<_>, _>>()?;
        
        while hashes.len() > 1 {
            let mut next_level = Vec::new();
            
            for chunk in hashes.chunks(2) {
                let combined = if chunk.len() == 2 {
                    format!("{}{}", chunk[0], chunk[1])
                } else {
                    format!("{}{}", chunk[0], chunk[0])
                };
                
                let mut hasher = Sha3_256::new();
                hasher.update(combined.as_bytes());
                next_level.push(format!("{:x}", hasher.finalize()));
            }
            
            hashes = next_level;
        }
        
        Ok(hashes.into_iter().next().unwrap_or_default())
    }
    
    fn calculate_transaction_hash(&self, tx: &Transaction) -> Result<String, ConsensusError> {
        let tx_bytes = format!("{}{}{}{}{}", 
            tx.from, tx.to, tx.amount, tx.fee, tx.nonce);
        
        let mut hasher = Sha3_256::new();
        hasher.update(tx_bytes.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }
    
    fn validate_transaction(&self, tx: &Transaction) -> Result<bool, ConsensusError> {
        if tx.amount == 0 && tx.fee == 0 {
            return Ok(false);
        }
        
        if tx.from == tx.to {
            return Ok(false);
        }
        
        if tx.signature.is_empty() {
            return Ok(false);
        }
        
        Ok(true)
    }
}

// 实用拜占庭容错 (PBFT) 实现
#[derive(Debug)]
pub struct PracticalByzantineFaultTolerance {
    pub view_number: u64,
    pub replica_count: u32,
    pub fault_tolerance: u32, // f，最多容忍f个恶意节点
    pub view_change_timeout: Duration,
    pub message_timeout: Duration,
    pub checkpoint_interval: u64,
}

impl PracticalByzantineFaultTolerance {
    pub fn new(replica_count: u32) -> Self {
        let fault_tolerance = (replica_count - 1) / 3; // PBFT最多容忍 (n-1)/3 个恶意节点
        
        Self {
            view_number: 0,
            replica_count,
            fault_tolerance,
            view_change_timeout: Duration::from_secs(10),
            message_timeout: Duration::from_secs(5),
            checkpoint_interval: 100,
        }
    }
    
    pub fn is_primary(&self, replica_id: u32) -> bool {
        (self.view_number % (self.replica_count as u64)) == (replica_id as u64)
    }
    
    pub fn execute_pbft_round(&self, request: &Transaction) -> Result<PBFTResult, ConsensusError> {
        println!("执行PBFT轮次，视图: {}", self.view_number);
        
        // 1. Pre-prepare阶段 (主节点广播提议)
        let pre_prepare = PBFTMessage {
            message_type: PBFTMessageType::PrePrepare,
            view: self.view_number,
            sequence: 1,
            request_digest: self.calculate_request_digest(request)?,
            replica_id: 0, // 假设节点0是主节点
            timestamp: SystemTime::now(),
        };
        
        println!("Pre-prepare阶段: 主节点广播提议");
        
        // 2. Prepare阶段 (备份节点验证并广播prepare)
        let mut prepare_votes = Vec::new();
        for replica_id in 1..self.replica_count {
            if self.validate_pre_prepare(&pre_prepare, replica_id)? {
                let prepare = PBFTMessage {
                    message_type: PBFTMessageType::Prepare,
                    view: self.view_number,
                    sequence: pre_prepare.sequence,
                    request_digest: pre_prepare.request_digest.clone(),
                    replica_id,
                    timestamp: SystemTime::now(),
                };
                prepare_votes.push(prepare);
            }
        }
        
        println!("Prepare阶段: 收到 {} 个prepare投票", prepare_votes.len());
        
        // 3. 检查是否达到2f+1个prepare消息
        if prepare_votes.len() >= (2 * self.fault_tolerance) as usize {
            println!("达到prepare阈值，进入commit阶段");
            
            // 4. Commit阶段
            let mut commit_votes = Vec::new();
            for replica_id in 0..self.replica_count {
                let commit = PBFTMessage {
                    message_type: PBFTMessageType::Commit,
                    view: self.view_number,
                    sequence: pre_prepare.sequence,
                    request_digest: pre_prepare.request_digest.clone(),
                    replica_id,
                    timestamp: SystemTime::now(),
                };
                commit_votes.push(commit);
            }
            
            println!("Commit阶段: 收到 {} 个commit投票", commit_votes.len());
            
            // 5. 检查是否达到2f+1个commit消息
            if commit_votes.len() >= (2 * self.fault_tolerance + 1) as usize {
                println!("达到commit阈值，请求已确认");
                
                return Ok(PBFTResult {
                    confirmed: true,
                    view: self.view_number,
                    sequence: pre_prepare.sequence,
                    prepare_count: prepare_votes.len() as u32,
                    commit_count: commit_votes.len() as u32,
                });
            }
        }
        
        Err(ConsensusError::PBFTTimeout)
    }
    
    fn validate_pre_prepare(&self, pre_prepare: &PBFTMessage, replica_id: u32) -> Result<bool, ConsensusError> {
        // 验证pre-prepare消息的有效性
        
        // 1. 检查视图号
        if pre_prepare.view != self.view_number {
            return Ok(false);
        }
        
        // 2. 检查消息来源是否为主节点
        let expected_primary = (self.view_number % (self.replica_count as u64)) as u32;
        if pre_prepare.replica_id != expected_primary {
            return Ok(false);
        }
        
        // 3. 检查序列号
        if pre_prepare.sequence == 0 {
            return Ok(false);
        }
        
        // 4. 检查请求摘要
        if pre_prepare.request_digest.is_empty() {
            return Ok(false);
        }
        
        Ok(true)
    }
    
    fn calculate_request_digest(&self, request: &Transaction) -> Result<String, ConsensusError> {
        let request_bytes = format!("{}{}{}{}", 
            request.from, request.to, request.amount, request.fee);
        
        let mut hasher = Sha3_256::new();
        hasher.update(request_bytes.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }
    
    pub fn trigger_view_change(&mut self, new_view: u64) -> Result<(), ConsensusError> {
        println!("触发视图变更: {} -> {}", self.view_number, new_view);
        
        self.view_number = new_view;
        
        // 广播view-change消息
        let view_change = PBFTMessage {
            message_type: PBFTMessageType::ViewChange,
            view: new_view,
            sequence: 0,
            request_digest: String::new(),
            replica_id: 0, // 简化：假设节点0触发
            timestamp: SystemTime::now(),
        };
        
        println!("广播view-change消息");
        
        Ok(())
    }
}

impl ConsensusAlgorithm for PracticalByzantineFaultTolerance {
    fn algorithm_name(&self) -> &'static str {
        "Practical Byzantine Fault Tolerance"
    }
    
    fn propose_block(&self, transactions: Vec<Transaction>) -> Result<Block, ConsensusError> {
        let merkle_root = self.calculate_merkle_root(&transactions)?;
        
        let block = Block {
            header: BlockHeader {
                version: 1,
                previous_hash: String::new(),
                merkle_root,
                timestamp: SystemTime::now(),
                height: 0,
                nonce: 0,
                difficulty: 0,
                state_root: String::new(),
                transaction_count: transactions.len() as u32,
            },
            transactions,
            consensus_data: ConsensusData::PBFT { 
                view: self.view_number,
                prepare_votes: vec![],
                commit_votes: vec![],
            },
        };
        
        Ok(block)
    }
    
    fn validate_block(&self, block: &Block) -> Result<bool, ConsensusError> {
        if let ConsensusData::PBFT { view, prepare_votes, commit_votes } = &block.consensus_data {
            // 验证视图号
            if *view != self.view_number {
                return Ok(false);
            }
            
            // 验证投票数量
            if prepare_votes.len() < (2 * self.fault_tolerance) as usize {
                return Ok(false);
            }
            
            if commit_votes.len() < (2 * self.fault_tolerance + 1) as usize {
                return Ok(false);
            }
        } else {
            return Ok(false);
        }
        
        Ok(true)
    }
    
    fn finalize_block(&self, block: Block) -> Result<(), ConsensusError> {
        println!("PBFT区块已确认，高度: {}", block.header.height);
        Ok(())
    }
    
    fn handle_consensus_message(&self, message: ConsensusMessage) -> Result<ConsensusResponse, ConsensusError> {
        match message.message_type {
            ConsensusMessageType::PBFTPrepare => {
                Ok(ConsensusResponse::Accepted)
            }
            ConsensusMessageType::PBFTCommit => {
                Ok(ConsensusResponse::Accepted)
            }
            ConsensusMessageType::PBFTViewChange => {
                Ok(ConsensusResponse::Accepted)
            }
            _ => Ok(ConsensusResponse::Ignored),
        }
    }
    
    fn get_consensus_parameters(&self) -> ConsensusParameters {
        ConsensusParameters {
            block_time: Duration::from_secs(1),
            finality_time: Duration::from_secs(3), // 快速最终确认
            throughput_tps: 5000.0, // 联盟链高TPS
            energy_efficiency: EnergyEfficiency::High,
            decentralization_level: DecentralizationLevel::Low, // 联盟链
            security_model: SecurityModel::Deterministic,
        }
    }
}

impl PracticalByzantineFaultTolerance {
    fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Result<String, ConsensusError> {
        if transactions.is_empty() {
            return Ok(String::new());
        }
        
        let mut hashes: Vec<String> = transactions.iter()
            .map(|tx| self.calculate_transaction_hash(tx))
            .collect::<Result<Vec<_>, _>>()?;
        
        while hashes.len() > 1 {
            let mut next_level = Vec::new();
            
            for chunk in hashes.chunks(2) {
                let combined = if chunk.len() == 2 {
                    format!("{}{}", chunk[0], chunk[1])
                } else {
                    format!("{}{}", chunk[0], chunk[0])
                };
                
                let mut hasher = Sha3_256::new();
                hasher.update(combined.as_bytes());
                next_level.push(format!("{:x}", hasher.finalize()));
            }
            
            hashes = next_level;
        }
        
        Ok(hashes.into_iter().next().unwrap_or_default())
    }
    
    fn calculate_transaction_hash(&self, tx: &Transaction) -> Result<String, ConsensusError> {
        let tx_bytes = format!("{}{}{}{}{}", 
            tx.from, tx.to, tx.amount, tx.fee, tx.nonce);
        
        let mut hasher = Sha3_256::new();
        hasher.update(tx_bytes.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }
}

// 相关数据结构定义
#[derive(Debug)]
pub struct ValidatorSet {
    pub validators: HashMap<String, Validator>,
    pub total_stake: u64,
    pub epoch: u64,
}

#[derive(Debug, Clone)]
pub struct Validator {
    pub validator_id: String,
    pub stake: u64,
    pub is_active: bool,
    pub reputation: f64,
    pub last_activity: SystemTime,
    pub slashing_history: Vec<SlashingEvent>,
}

#[derive(Debug, Clone)]
pub struct SlashingEvent {
    pub condition: SlashingCondition,
    pub amount_slashed: u64,
    pub timestamp: SystemTime,
}

#[derive(Debug, Clone)]
pub struct Attestation {
    pub validator_id: String,
    pub source_checkpoint: u64,
    pub target_checkpoint: u64,
    pub beacon_block_root: String,
    pub signature: String,
    pub timestamp: SystemTime,
}

#[derive(Debug)]
pub struct MemoryPool {
    pub pending_transactions: VecDeque<Transaction>,
    pub transaction_fees: BTreeMap<u64, Vec<Transaction>>, // 按手续费排序
    pub max_pool_size: usize,
    pub min_fee_threshold: u64,
}

#[derive(Debug)]
pub struct NetworkLayer {
    pub node_id: String,
    pub peers: HashSet<String>,
    pub message_handlers: HashMap<String, Box<dyn MessageHandler + Send + Sync>>,
}

pub trait MessageHandler: Send + Sync {
    fn handle_message(&self, message: NetworkMessage) -> Result<(), NetworkError>;
}

#[derive(Debug)]
pub struct NetworkMessage {
    pub sender: String,
    pub message_type: String,
    pub payload: Vec<u8>,
    pub timestamp: SystemTime,
}

#[derive(Debug)]
pub enum NetworkError {
    ConnectionFailed,
    MessageTimeout,
    InvalidMessage,
}

#[derive(Debug)]
pub struct ConsensusState {
    pub current_view: u64,
    pub current_height: u64,
    pub finalized_height: u64,
    pub pending_blocks: HashMap<u64, Block>,
    pub validator_votes: HashMap<String, Vec<Vote>>,
}

#[derive(Debug, Clone)]
pub struct Vote {
    pub voter_id: String,
    pub block_hash: String,
    pub vote_type: VoteType,
    pub timestamp: SystemTime,
}

#[derive(Debug, Clone)]
pub enum VoteType {
    Prevote,
    Precommit,
    Commit,
}

#[derive(Debug)]
pub struct ConsensusMetrics {
    pub blocks_proposed: u64,
    pub blocks_validated: u64,
    pub blocks_finalized: u64,
    pub average_block_time: Duration,
    pub consensus_participation_rate: f64,
    pub network_latency: Duration,
}

#[derive(Debug)]
pub struct ConsensusMessage {
    pub message_type: ConsensusMessageType,
    pub sender: String,
    pub payload: Vec<u8>,
    pub timestamp: SystemTime,
}

#[derive(Debug)]
pub enum ConsensusMessageType {
    BlockProposal,
    BlockVote,
    Attestation,
    ValidatorRegistration,
    DelegateRegistration,
    WitnessVote,
    DifficultyUpdate,
    PBFTPrepare,
    PBFTCommit,
    PBFTViewChange,
}

#[derive(Debug)]
pub enum ConsensusResponse {
    Accepted,
    Rejected,
    Ignored,
}

#[derive(Debug)]
pub struct ConsensusParameters {
    pub block_time: Duration,
    pub finality_time: Duration,
    pub throughput_tps: f64,
    pub energy_efficiency: EnergyEfficiency,
    pub decentralization_level: DecentralizationLevel,
    pub security_model: SecurityModel,
}

#[derive(Debug)]
pub enum EnergyEfficiency {
    Low,
    Medium,
    High,
    VeryHigh,
}

#[derive(Debug)]
pub enum DecentralizationLevel {
    Low,     // 联盟链
    Medium,  // 部分去中心化
    High,    // 完全去中心化
}

#[derive(Debug)]
pub enum SecurityModel {
    Probabilistic, // 概率性安全 (如PoW)
    Deterministic, // 确定性安全 (如PBFT)
    Economic,      // 经济安全 (如PoS)
}

#[derive(Debug)]
pub struct PBFTMessage {
    pub message_type: PBFTMessageType,
    pub view: u64,
    pub sequence: u64,
    pub request_digest: String,
    pub replica_id: u32,
    pub timestamp: SystemTime,
}

#[derive(Debug)]
pub enum PBFTMessageType {
    PrePrepare,
    Prepare,
    Commit,
    ViewChange,
    NewView,
}

#[derive(Debug)]
pub struct PBFTResult {
    pub confirmed: bool,
    pub view: u64,
    pub sequence: u64,
    pub prepare_count: u32,
    pub commit_count: u32,
}

// 错误类型定义
#[derive(Debug)]
pub enum ConsensusError {
    InvalidBlock,
    InvalidTransaction,
    InsufficientStake,
    NoEligibleValidators,
    NoValidatorSelected,
    NoWitnesses,
    InvalidAttestation,
    AttestationTooOld,
    InvalidTimestamp,
    MiningTimeout,
    PBFTTimeout,
    NetworkPartition,
    ByzantineFault,
}

impl std::fmt::Display for ConsensusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConsensusError::InvalidBlock => write!(f, "Invalid block"),
            ConsensusError::InvalidTransaction => write!(f, "Invalid transaction"),
            ConsensusError::InsufficientStake => write!(f, "Insufficient stake"),
            ConsensusError::NoEligibleValidators => write!(f, "No eligible validators"),
            ConsensusError::NoValidatorSelected => write!(f, "No validator selected"),
            ConsensusError::NoWitnesses => write!(f, "No witnesses available"),
            ConsensusError::InvalidAttestation => write!(f, "Invalid attestation"),
            ConsensusError::AttestationTooOld => write!(f, "Attestation too old"),
            ConsensusError::InvalidTimestamp => write!(f, "Invalid timestamp"),
            ConsensusError::MiningTimeout => write!(f, "Mining timeout"),
            ConsensusError::PBFTTimeout => write!(f, "PBFT consensus timeout"),
            ConsensusError::NetworkPartition => write!(f, "Network partition detected"),
            ConsensusError::ByzantineFault => write!(f, "Byzantine fault detected"),
        }
    }
}

impl std::error::Error for ConsensusError {}

// 演示函数
pub async fn demonstrate_consensus_mechanisms() -> Result<(), ConsensusError> {
    println!("=== 区块链共识机制演示 ===");
    
    // 1. PoW演示
    println!("\n--- 工作量证明 (PoW) 演示 ---");
    let pow = ProofOfWork::new();
    
    let transactions = vec![
        Transaction {
            tx_id: "tx_1".to_string(),
            from: "alice".to_string(),
            to: "bob".to_string(),
            amount: 100,
            fee: 1,
            timestamp: SystemTime::now(),
            signature: "alice_sig".to_string(),
            nonce: 1,
            data: vec![],
        },
    ];
    
    let pow_block = pow.propose_block(transactions.clone())?;
    let is_valid = pow.validate_block(&pow_block)?;
    
    println!("✅ PoW区块创建成功");
    println!("   - 区块哈希: {:?}", pow_block.consensus_data);
    println!("   - 验证结果: {}", is_valid);
    
    // 2. PoS演示
    println!("\n--- 权益证明 (PoS) 演示 ---");
    let pos = ProofOfStake::new();
    
    let mut validator_set = ValidatorSet {
        validators: HashMap::new(),
        total_stake: 0,
        epoch: 1,
    };
    
    // 添加验证者
    for i in 0..5 {
        let validator = Validator {
            validator_id: format!("validator_{}", i),
            stake: 32_000_000_000 + i * 1_000_000_000, // 不同的质押量
            is_active: true,
            reputation: 1.0,
            last_activity: SystemTime::now(),
            slashing_history: vec![],
        };
        
        validator_set.total_stake += validator.stake;
        validator_set.validators.insert(validator.validator_id.clone(), validator);
    }
    
    let selected_validator = pos.select_validator(&validator_set, 1)?;
    println!("✅ PoS验证者选择: {}", selected_validator);
    
    let pos_block = pos.propose_block(transactions.clone())?;
    let pos_valid = pos.validate_block(&pos_block)?;
    println!("✅ PoS区块验证: {}", pos_valid);
    
    // 3. DPoS演示
    println!("\n--- 委托权益证明 (DPoS) 演示 ---");
    let dpos = DelegatedProofOfStake::new();
    
    let votes = vec![
        DelegateVote {
            voter_id: "voter_1".to_string(),
            delegate_id: "delegate_1".to_string(),
            stake_amount: 10_000_000,
            timestamp: SystemTime::now(),
        },
        DelegateVote {
            voter_id: "voter_2".to_string(),
            delegate_id: "delegate_1".to_string(),
            stake_amount: 15_000_000,
            timestamp: SystemTime::now(),
        },
        DelegateVote {
            voter_id: "voter_3".to_string(),
            delegate_id: "delegate_2".to_string(),
            stake_amount: 8_000_000,
            timestamp: SystemTime::now(),
        },
    ];
    
    let witnesses = dpos.elect_witnesses(&votes)?;
    println!("✅ DPoS见证人选举: {:?}", witnesses);
    
    let scheduled_witness = dpos.schedule_witness(&witnesses, 1)?;
    println!("✅ DPoS见证人调度: {}", scheduled_witness);
    
    // 4. PBFT演示
    println!("\n--- 实用拜占庭容错 (PBFT) 演示 ---");
    let pbft = PracticalByzantineFaultTolerance::new(7); // 7个节点，容忍2个恶意节点
    
    let request = transactions[0].clone();
    let pbft_result = pbft.execute_pbft_round(&request)?;
    
    println!("✅ PBFT共识完成:");
    println!("   - 视图: {}", pbft_result.view);
    println!("   - 序列号: {}", pbft_result.sequence);
    println!("   - Prepare投票: {}", pbft_result.prepare_count);
    println!("   - Commit投票: {}", pbft_result.commit_count);
    println!("   - 确认状态: {}", pbft_result.confirmed);
    
    // 5. 共识参数对比
    println!("\n--- 共识机制参数对比 ---");
    let algorithms: Vec<&dyn ConsensusAlgorithm> = vec![&pow, &pos, &dpos, &pbft];
    
    for algorithm in algorithms {
        let params = algorithm.get_consensus_parameters();
        println!("\n{}:", algorithm.algorithm_name());
        println!("   - 出块时间: {:?}", params.block_time);
        println!("   - 最终确认时间: {:?}", params.finality_time);
        println!("   - 吞吐量: {:.0} TPS", params.throughput_tps);
        println!("   - 能源效率: {:?}", params.energy_efficiency);
        println!("   - 去中心化程度: {:?}", params.decentralization_level);
        println!("   - 安全模型: {:?}", params.security_model);
    }
    
    println!("\n=== 区块链共识机制演示完成 ===");
    Ok(())
}

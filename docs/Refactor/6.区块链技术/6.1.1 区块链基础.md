# 6.1.1 区块链基础 / Blockchain Fundamentals

## 1. 区块链基础 / Foundations of Blockchain

### 1.1 区块链定义 / Definition of Blockchain

**区块链定义：**

- $Blockchain = \{Distributed\ Ledger | Immutable\ chain\ of\ blocks\}$  
  区块链：不可变的区块链式分布式账本。
- $Block = \{Header, Transactions, Timestamp, Hash\}$  
  区块：包含头部、交易、时间戳、哈希的数据结构。
- $Chain = \{Block_1 \rightarrow Block_2 \rightarrow ... \rightarrow Block_n\}$  
  链：按时间顺序连接的区块序列。

**区块链特征 / Blockchain Characteristics：**

- **去中心化 Decentralization**：$Decentralized = \{No\ central\ authority, Peer_{to}_{peer}\}$
- **不可篡改 Immutability**：$Immutable = \{Data\ cannot\ be\ altered\ once\ recorded\}$
- **透明性 Transparency**：$Transparent = \{All\ transactions\ visible\ to\ all\ participants\}$
- **可追溯性 Traceability**：$Traceable = \{Complete\ history\ of\ all\ transactions\}$

### 1.2 区块链架构 / Blockchain Architecture

**分层架构 / Layered Architecture：**

- **应用层 Application Layer**：$App_{Layer} = \{DApps, Smart_{Contracts}, User_{Interfaces}\}$
- **合约层 Contract Layer**：$Contract_{Layer} = \{Smart_{Contracts}, Virtual_{Machine}\}$
- **共识层 Consensus Layer**：$Consensus_{Layer} = \{Consensus_{Mechanism}, Block_{Validation}\}$
- **网络层 Network Layer**：$Network_{Layer} = \{P2P_{Network}, Node_{Communication}\}$
- **数据层 Data Layer**：$Data_{Layer} = \{Block_{Structure}, Merkle_{Tree}, Storage\}$

**节点类型 / Node Types：**

- **全节点 Full Node**：$Full_{Node} = \{Complete_{blockchain}, Validation, Relay\}$
- **轻节点 Light Node**：$Light_{Node} = \{SPV_{Client}, Header_{Only}, Trust_{Based}\}$
- **矿工节点 Miner Node**：$Miner_{Node} = \{Block_{Mining}, Consensus_{Participation}\}$

## 2. 密码学基础 / Cryptographic Foundations

### 2.1 哈希函数 Hash Functions

**哈希函数定义：**

- $H(M) = h$：哈希函数将消息映射为固定长度哈希值
- $H_{Properties} = \{One_{way}, Collision_{resistant}, Avalanche_{effect}\}$

**区块链哈希应用 / Blockchain Hash Applications：**

- **区块哈希 Block Hash**：$Hash_{Block} = H(Header_{Block})$
- **默克尔树 Merkle Tree**：$Merkle_{Root} = H(H(Tx_1) + H(Tx_2) + ... + H(Tx_n))$
- **交易哈希 Transaction Hash**：$Hash_{Tx} = H(Tx_{Data})$

**默克尔树结构 / Merkle Tree Structure：**

- $Merkle_{Tree} = \{Binary_{Tree} | Leaf_{nodes} = Transaction_{hashes}\}$
- $Parent_{Hash} = H(Left_{Child} + Right_{Child})$
- $Root_{Hash} = \{Root | Merkle_{Tree}_{root}\}$

### 2.2 数字签名 Digital Signatures

**数字签名定义：**

- $Sign(M, SK) = \sigma$：使用私钥对消息签名
- $Verify(M, \sigma, PK) = \{True, False\}$：使用公钥验证签名

**椭圆曲线数字签名算法 ECDSA：**

- $Private_{Key} = \{d | d \in [1, n-1]\}$
- $Public_{Key} = \{Q | Q = d \cdot G\}$
- $Signature = \{(r, s) | r = (k \cdot G)_x, s = k^{-1}(H(M) + d \cdot r)\}$

**多重签名 Multi-signature：**

- $Multi_{Sig} = \{m_{of}_{n} | Require\ m\ signatures\ from\ n\ parties\}$
- $Threshold_{Signature} = \{t_{of}_{n} | Require\ t\ valid\ shares\}$

### 2.3 零知识证明 Zero-Knowledge Proofs

**零知识证明定义：**

- $ZKP = \{Proof | Prover\ proves\ statement\ without\ revealing\ secret\}$
- $ZKP_{Properties} = \{Completeness, Soundness, Zero_{Knowledge}\}$

**zk-SNARKs：**

- $zk_{SNARK} = \{Succinct\ Non_{interactive}\ Argument\ of\ Knowledge\}$
- $Proof_{Size} = O(1)$：证明大小恒定
- $Verification_{Time} = O(1)$：验证时间恒定

## 3. 共识机制 / Consensus Mechanisms

### 3.1 工作量证明 Proof of Work (PoW)

**PoW定义：**

- $PoW = \{Consensus | Solve\ computational\ puzzle\}$
- $Difficulty_{Target} = \{T | Hash_{Block} < T\}$
- $Nonce = \{Value | Hash_{Block} = H(Header + Nonce)\}$

**挖矿过程 / Mining Process：**

- $Mining = \{Find\ nonce | H(Block_{Header} + Nonce) < Target\}$
- $Block_{Reward} = \{New_{Coins} + Transaction_{Fees}\}$
- $Difficulty_{Adjustment} = \{Adjust\ target\ based\ on\ hash_{rate}\}$

**PoW安全性 / PoW Security：**

- $51\%_{Attack} = \{Attack | Attacker\ controls\ >50\%\ hash_{rate}\}$
- $Double_{Spending} = \{Attack | Spend\ same\ coin\ twice\}$
- $Fork_{Resolution} = \{Longest_{chain}\ rule\}$

### 3.2 权益证明 Proof of Stake (PoS)

**PoS定义：**

- $PoS = \{Consensus | Stake_{based}\ block_{creation}\}$
- $Validator = \{Node | Stake_{coins}\ to\ participate\}$
- $Stake_{Amount} = \{Coins | Locked\ for\ validation\}$

**PoS变体 / PoS Variants：**

- **链式PoS Chain-based PoS**：$Chain_{PoS} = \{Validator\ selection\ based\ on\ stake\}$
- **委员会PoS Committee-based PoS**：$Committee_{PoS} = \{Fixed_{size}\ validator_{set}\}$
- **委托PoS Delegated PoS**：$DPoS = \{Delegates\ elected\ by\ stakeholders\}$

**PoS优势 / PoS Advantages：**

- $Energy_{Efficiency} = \{Low\ energy\ consumption\}$
- $Security_{Model} = \{Stake_{based}\ security\}$
- $Scalability = \{Higher\ transaction_{throughput}\}$

### 3.3 其他共识机制 Other Consensus Mechanisms

**实用拜占庭容错 PBFT：**

- $PBFT = \{Byzantine_{fault}_{tolerant}\ consensus\}$
- $Fault_{Tolerance} = \{Tolerate\ f\ faults\ with\ 3f+1\ nodes\}$
- $Consensus_{Phases} = \{Pre_{prepare}, Prepare, Commit\}$

**权威证明 Proof of Authority (PoA)：**

- $PoA = \{Consensus | Identity_{based}\ validation\}$
- $Validator_{Identity} = \{Known\ and\ trusted\ entities\}$
- $Use_{Case} = \{Private_{blockchains}, Consortium_{blockchains}\}$

## 4. 工程实现 / Engineering Implementation

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use rand::Rng;

// 哈希类型
pub type Hash = [u8; 32];
pub type Address = [u8; 20];

// 交易结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: Address,
    pub to: Address,
    pub value: u64,
    pub nonce: u64,
    pub gas_price: u64,
    pub gas_limit: u64,
    pub data: Vec<u8>,
    pub signature: Option<Signature>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    pub r: [u8; 32],
    pub s: [u8; 32],
    pub v: u8,
}

// 区块头部
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockHeader {
    pub parent_hash: Hash,
    pub timestamp: u64,
    pub nonce: u64,
    pub difficulty: u64,
    pub merkle_root: Hash,
    pub state_root: Hash,
    pub transactions_root: Hash,
    pub receipts_root: Hash,
    pub extra_data: Vec<u8>,
}

// 区块结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub header: BlockHeader,
    pub transactions: Vec<Transaction>,
    pub hash: Option<Hash>,
}

// 区块链
pub struct Blockchain {
    pub blocks: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: u64,
    pub mining_reward: u64,
    pub state: Arc<Mutex<BlockchainState>>,
}

#[derive(Debug, Clone)]
pub struct BlockchainState {
    pub balances: HashMap<Address, u64>,
    pub nonces: HashMap<Address, u64>,
    pub contracts: HashMap<Address, SmartContract>,
}

#[derive(Debug, Clone)]
pub struct SmartContract {
    pub code: Vec<u8>,
    pub storage: HashMap<[u8; 32], [u8; 32]>,
    pub balance: u64,
}

impl Blockchain {
    pub fn new() -> Self {
        Blockchain {
            blocks: Vec::new(),
            pending_transactions: Vec::new(),
            difficulty: 4, // 前导零的数量
            mining_reward: 100,
            state: Arc::new(Mutex::new(BlockchainState {
                balances: HashMap::new(),
                nonces: HashMap::new(),
                contracts: HashMap::new(),
            })),
        }
    }
    
    pub fn create_genesis_block(&mut self) {
        let genesis_block = Block {
            header: BlockHeader {
                parent_hash: [0; 32],
                timestamp: SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
                nonce: 0,
                difficulty: self.difficulty,
                merkle_root: [0; 32],
                state_root: [0; 32],
                transactions_root: [0; 32],
                receipts_root: [0; 32],
                extra_data: Vec::new(),
            },
            transactions: Vec::new(),
            hash: None,
        };
        
        let hash = self.calculate_block_hash(&genesis_block);
        let mut genesis_block = genesis_block;
        genesis_block.hash = Some(hash);
        
        self.blocks.push(genesis_block);
    }
    
    pub fn add_transaction(&mut self, transaction: Transaction) -> bool {
        // 验证交易
        if self.validate_transaction(&transaction) {
            self.pending_transactions.push(transaction);
            true
        } else {
            false
        }
    }
    
    pub fn validate_transaction(&self, transaction: &Transaction) -> bool {
        let state = self.state.lock().unwrap();
        
        // 检查余额
        let balance = state.balances.get(&transaction.from).unwrap_or(&0);
        let required_amount = transaction.value + transaction.gas_price * transaction.gas_limit;
        
        if balance < &required_amount {
            return false;
        }
        
        // 检查nonce
        let expected_nonce = state.nonces.get(&transaction.from).unwrap_or(&0);
        if transaction.nonce != *expected_nonce {
            return false;
        }
        
        // 验证签名
        if let Some(ref signature) = transaction.signature {
            if !self.verify_transaction_signature(transaction, signature) {
                return false;
            }
        }
        
        true
    }
    
    pub fn verify_transaction_signature(&self, transaction: &Transaction, signature: &Signature) -> bool {
        // 简化的签名验证
        let message = self.create_transaction_message(transaction);
        let message_hash = self.hash_message(&message);
        
        // 这里应该使用实际的ECDSA验证
        // 简化实现：检查签名不为零
        signature.r != [0; 32] && signature.s != [0; 32]
    }
    
    pub fn create_transaction_message(&self, transaction: &Transaction) -> Vec<u8> {
        let mut message = Vec::new();
        message.extend_from_slice(&transaction.from);
        message.extend_from_slice(&transaction.to);
        message.extend_from_slice(&transaction.value.to_le_bytes());
        message.extend_from_slice(&transaction.nonce.to_le_bytes());
        message.extend_from_slice(&transaction.gas_price.to_le_bytes());
        message.extend_from_slice(&transaction.gas_limit.to_le_bytes());
        message.extend_from_slice(&transaction.data);
        message
    }
    
    pub fn mine_block(&mut self, miner_address: Address) -> Option<Block> {
        if self.pending_transactions.is_empty() {
            return None;
        }
        
        let last_block = self.blocks.last().unwrap();
        let mut new_block = Block {
            header: BlockHeader {
                parent_hash: last_block.hash.unwrap(),
                timestamp: SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
                nonce: 0,
                difficulty: self.difficulty,
                merkle_root: [0; 32], // 将在挖矿过程中计算
                state_root: [0; 32],
                transactions_root: [0; 32],
                receipts_root: [0; 32],
                extra_data: Vec::new(),
            },
            transactions: self.pending_transactions.clone(),
            hash: None,
        };
        
        // 添加挖矿奖励交易
        let reward_transaction = Transaction {
            from: [0; 20], // 系统地址
            to: miner_address,
            value: self.mining_reward,
            nonce: 0,
            gas_price: 0,
            gas_limit: 0,
            data: Vec::new(),
            signature: None,
        };
        new_block.transactions.insert(0, reward_transaction);
        
        // 计算默克尔根
        new_block.header.merkle_root = self.calculate_merkle_root(&new_block.transactions);
        
        // 挖矿过程
        let mut nonce = 0u64;
        loop {
            new_block.header.nonce = nonce;
            let hash = self.calculate_block_hash(&new_block);
            
            if self.is_valid_hash(&hash) {
                new_block.hash = Some(hash);
                break;
            }
            
            nonce += 1;
            
            // 防止无限循环
            if nonce > 1_000_000 {
                return None;
            }
        }
        
        // 更新区块链状态
        self.update_state(&new_block);
        
        // 清空待处理交易
        self.pending_transactions.clear();
        
        Some(new_block)
    }
    
    pub fn add_block(&mut self, block: Block) -> bool {
        // 验证区块
        if self.validate_block(&block) {
            self.blocks.push(block);
            true
        } else {
            false
        }
    }
    
    pub fn validate_block(&self, block: &Block) -> bool {
        // 检查父区块哈希
        if let Some(last_block) = self.blocks.last() {
            if block.header.parent_hash != last_block.hash.unwrap() {
                return false;
            }
        }
        
        // 验证工作量证明
        if let Some(hash) = block.hash {
            if !self.is_valid_hash(&hash) {
                return false;
            }
        }
        
        // 验证默克尔根
        let calculated_merkle_root = self.calculate_merkle_root(&block.transactions);
        if block.header.merkle_root != calculated_merkle_root {
            return false;
        }
        
        // 验证交易
        for transaction in &block.transactions {
            if !self.validate_transaction(transaction) {
                return false;
            }
        }
        
        true
    }
    
    pub fn calculate_block_hash(&self, block: &Block) -> Hash {
        let mut hasher = Sha256::new();
        
        // 序列化区块头部
        let header_data = bincode::serialize(&block.header).unwrap();
        hasher.update(header_data);
        
        let result = hasher.finalize();
        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);
        hash
    }
    
    pub fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Hash {
        if transactions.is_empty() {
            return [0; 32];
        }
        
        let mut hashes: Vec<Hash> = transactions.iter()
            .map(|tx| self.hash_transaction(tx))
            .collect();
        
        while hashes.len() > 1 {
            let mut new_hashes = Vec::new();
            
            for chunk in hashes.chunks(2) {
                let mut hasher = Sha256::new();
                hasher.update(&chunk[0]);
                if chunk.len() > 1 {
                    hasher.update(&chunk[1]);
                } else {
                    hasher.update(&chunk[0]); // 奇数个哈希时重复
                }
                
                let result = hasher.finalize();
                let mut hash = [0u8; 32];
                hash.copy_from_slice(&result);
                new_hashes.push(hash);
            }
            
            hashes = new_hashes;
        }
        
        hashes[0]
    }
    
    pub fn hash_transaction(&self, transaction: &Transaction) -> Hash {
        let mut hasher = Sha256::new();
        let tx_data = bincode::serialize(transaction).unwrap();
        hasher.update(tx_data);
        
        let result = hasher.finalize();
        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);
        hash
    }
    
    pub fn hash_message(&self, message: &[u8]) -> Hash {
        let mut hasher = Sha256::new();
        hasher.update(message);
        
        let result = hasher.finalize();
        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);
        hash
    }
    
    pub fn is_valid_hash(&self, hash: &Hash) -> bool {
        // 检查前导零的数量
        let leading_zeros = hash.iter()
            .take(self.difficulty as usize / 8)
            .take_while(|&&byte| byte == 0)
            .count();
        
        let remaining_bits = self.difficulty as usize % 8;
        if remaining_bits > 0 {
            let last_byte = hash[self.difficulty as usize / 8];
            let mask = 0xFF >> (8 - remaining_bits);
            leading_zeros * 8 + (last_byte & mask).leading_zeros() as usize >= self.difficulty as usize
        } else {
            leading_zeros * 8 >= self.difficulty as usize
        }
    }
    
    pub fn update_state(&mut self, block: &Block) {
        let mut state = self.state.lock().unwrap();
        
        for transaction in &block.transactions {
            // 更新余额
            if transaction.from != [0; 20] { // 不是挖矿奖励
                let from_balance = state.balances.entry(transaction.from).or_insert(0);
                *from_balance = from_balance.saturating_sub(transaction.value);
                
                let to_balance = state.balances.entry(transaction.to).or_insert(0);
                *to_balance += transaction.value;
                
                // 更新nonce
                let nonce = state.nonces.entry(transaction.from).or_insert(0);
                *nonce += 1;
            } else {
                // 挖矿奖励
                let to_balance = state.balances.entry(transaction.to).or_insert(0);
                *to_balance += transaction.value;
            }
        }
    }
    
    pub fn get_balance(&self, address: &Address) -> u64 {
        let state = self.state.lock().unwrap();
        *state.balances.get(address).unwrap_or(&0)
    }
    
    pub fn get_block_count(&self) -> usize {
        self.blocks.len()
    }
    
    pub fn get_latest_block(&self) -> Option<&Block> {
        self.blocks.last()
    }
}

// 权益证明实现
pub struct ProofOfStake {
    pub validators: HashMap<Address, Validator>,
    pub total_stake: u64,
    pub min_stake: u64,
}

#[derive(Debug, Clone)]
pub struct Validator {
    pub address: Address,
    pub stake: u64,
    pub is_active: bool,
    pub last_block_time: u64,
    pub total_blocks_mined: u64,
}

impl ProofOfStake {
    pub fn new(min_stake: u64) -> Self {
        ProofOfStake {
            validators: HashMap::new(),
            total_stake: 0,
            min_stake,
        }
    }
    
    pub fn add_validator(&mut self, address: Address, stake: u64) -> bool {
        if stake < self.min_stake {
            return false;
        }
        
        let validator = Validator {
            address,
            stake,
            is_active: true,
            last_block_time: 0,
            total_blocks_mined: 0,
        };
        
        self.validators.insert(address, validator);
        self.total_stake += stake;
        true
    }
    
    pub fn select_validator(&self, timestamp: u64) -> Option<Address> {
        if self.validators.is_empty() {
            return None;
        }
        
        // 简化的验证者选择算法
        let mut rng = rand::thread_rng();
        let random_value = rng.gen_range(0..self.total_stake);
        
        let mut cumulative_stake = 0u64;
        for (address, validator) in &self.validators {
            if !validator.is_active {
                continue;
            }
            
            cumulative_stake += validator.stake;
            if random_value < cumulative_stake {
                return Some(*address);
            }
        }
        
        None
    }
    
    pub fn update_validator(&mut self, address: Address, block_time: u64) {
        if let Some(validator) = self.validators.get_mut(&address) {
            validator.last_block_time = block_time;
            validator.total_blocks_mined += 1;
        }
    }
    
    pub fn get_validator_info(&self, address: &Address) -> Option<&Validator> {
        self.validators.get(address)
    }
}

// 智能合约虚拟机
pub struct VirtualMachine {
    pub stack: Vec<u8>,
    pub memory: Vec<u8>,
    pub storage: HashMap<[u8; 32], [u8; 32]>,
    pub gas_used: u64,
    pub gas_limit: u64,
}

impl VirtualMachine {
    pub fn new(gas_limit: u64) -> Self {
        VirtualMachine {
            stack: Vec::new(),
            memory: Vec::new(),
            storage: HashMap::new(),
            gas_used: 0,
            gas_limit,
        }
    }
    
    pub fn execute_contract(&mut self, code: &[u8], input: &[u8]) -> Result<Vec<u8>, String> {
        self.gas_used = 0;
        self.stack.clear();
        self.memory.clear();
        
        // 简化的字节码执行
        let mut pc = 0usize;
        
        while pc < code.len() && self.gas_used < self.gas_limit {
            let opcode = code[pc];
            
            match opcode {
                0x00 => { // STOP
                    break;
                }
                0x60 => { // PUSH1
                    if pc + 1 < code.len() {
                        self.stack.push(code[pc + 1]);
                        pc += 1;
                    }
                }
                0x01 => { // ADD
                    if self.stack.len() >= 2 {
                        let a = self.stack.pop().unwrap();
                        let b = self.stack.pop().unwrap();
                        self.stack.push(a.wrapping_add(b));
                    }
                }
                0x02 => { // MUL
                    if self.stack.len() >= 2 {
                        let a = self.stack.pop().unwrap();
                        let b = self.stack.pop().unwrap();
                        self.stack.push(a.wrapping_mul(b));
                    }
                }
                0x55 => { // SSTORE
                    if self.stack.len() >= 2 {
                        let value = self.stack.pop().unwrap();
                        let key = self.stack.pop().unwrap();
                        let mut key_bytes = [0u8; 32];
                        key_bytes[31] = key;
                        let mut value_bytes = [0u8; 32];
                        value_bytes[31] = value;
                        self.storage.insert(key_bytes, value_bytes);
                    }
                }
                0x54 => { // SLOAD
                    if !self.stack.is_empty() {
                        let key = self.stack.pop().unwrap();
                        let mut key_bytes = [0u8; 32];
                        key_bytes[31] = key;
                        let value = self.storage.get(&key_bytes).unwrap_or(&[0u8; 32]);
                        self.stack.push(value[31]);
                    }
                }
                _ => {
                    // 未知操作码
                    return Err(format!("Unknown opcode: 0x{:02x}", opcode));
                }
            }
            
            self.gas_used += 1;
            pc += 1;
        }
        
        if self.gas_used >= self.gas_limit {
            return Err("Out of gas".to_string());
        }
        
        Ok(self.stack.clone())
    }
    
    pub fn get_gas_used(&self) -> u64 {
        self.gas_used
    }
}

// 网络节点
pub struct Node {
    pub address: Address,
    pub blockchain: Blockchain,
    pub peers: Vec<Peer>,
    pub is_mining: bool,
    pub mining_address: Address,
}

#[derive(Debug, Clone)]
pub struct Peer {
    pub address: String,
    pub port: u16,
    pub last_seen: Instant,
    pub is_connected: bool,
}

impl Node {
    pub fn new(address: Address) -> Self {
        let mut blockchain = Blockchain::new();
        blockchain.create_genesis_block();
        
        Node {
            address,
            blockchain,
            peers: Vec::new(),
            is_mining: false,
            mining_address: address,
        }
    }
    
    pub fn start_mining(&mut self) {
        self.is_mining = true;
        
        // 模拟挖矿过程
        while self.is_mining {
            if let Some(block) = self.blockchain.mine_block(self.mining_address) {
                println!("Mined block: {:?}", block.hash.unwrap());
                self.broadcast_block(&block);
            }
            
            std::thread::sleep(Duration::from_millis(100));
        }
    }
    
    pub fn stop_mining(&mut self) {
        self.is_mining = false;
    }
    
    pub fn add_peer(&mut self, peer_address: String, peer_port: u16) {
        let peer = Peer {
            address: peer_address,
            port: peer_port,
            last_seen: Instant::now(),
            is_connected: true,
        };
        self.peers.push(peer);
    }
    
    pub fn broadcast_transaction(&self, transaction: &Transaction) {
        // 向所有对等节点广播交易
        for peer in &self.peers {
            if peer.is_connected {
                println!("Broadcasting transaction to peer: {}:{}", peer.address, peer.port);
            }
        }
    }
    
    pub fn broadcast_block(&self, block: &Block) {
        // 向所有对等节点广播区块
        for peer in &self.peers {
            if peer.is_connected {
                println!("Broadcasting block to peer: {}:{}", peer.address, peer.port);
            }
        }
    }
    
    pub fn get_blockchain_info(&self) -> BlockchainInfo {
        BlockchainInfo {
            block_count: self.blockchain.get_block_count(),
            pending_transactions: self.blockchain.pending_transactions.len(),
            difficulty: self.blockchain.difficulty,
            is_mining: self.is_mining,
        }
    }
}

#[derive(Debug, Clone)]
pub struct BlockchainInfo {
    pub block_count: usize,
    pub pending_transactions: usize,
    pub difficulty: u64,
    pub is_mining: bool,
}
```

## 5. 批判性分析 / Critical Analysis

### 5.1 理论局限性 / Theoretical Limitations

- **可扩展性限制 Scalability Limits**：交易吞吐量有限，网络拥堵。
- **能源消耗 Energy Consumption**：PoW机制消耗大量能源。
- **隐私保护不足 Privacy Issues**：交易透明性导致隐私泄露。

### 5.2 工程挑战 / Engineering Challenges

- **网络分叉 Network Forks**：硬分叉和软分叉的管理复杂性。
- **存储增长 Storage Growth**：区块链数据持续增长。
- **智能合约安全 Smart Contract Security**：合约漏洞和攻击风险。

## 6. 工程论证 / Engineering Arguments

- **金融应用**：如DeFi、支付系统，需高安全性和去中心化。
- **供应链管理**：如商品溯源，需透明性和不可篡改性。
- **数字身份**：如身份认证，需隐私保护和用户控制。

---
> 本文件为区块链基础的系统化重构，采用严格的形式化定义、数学表达、工程实现，确保内容的学术规范性和工程实用性。
> This file provides systematic refactoring of blockchain fundamentals, using strict formal definitions, mathematical expressions, and engineering implementations, ensuring academic standards and engineering practicality.

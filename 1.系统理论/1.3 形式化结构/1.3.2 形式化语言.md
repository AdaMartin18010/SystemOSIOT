# å½¢å¼åŒ–è¯­è¨€ / Formal Language

## ðŸ“š æ¦‚è¿° / Overview

å½¢å¼åŒ–è¯­è¨€æ˜¯ç³»ç»Ÿç†è®ºä¸¥æ ¼è¡¨è¾¾çš„åŸºç¡€å·¥å…·ï¼Œæä¾›äº†ç²¾ç¡®çš„è¯­æ³•è§„åˆ™å’Œè¯­ä¹‰è§£é‡Šã€‚æœ¬æ–‡æ¡£å»ºç«‹ç³»ç»Ÿç†è®ºçš„å½¢å¼åŒ–è¯­è¨€ä½“ç³»ï¼ŒåŒ…æ‹¬å½¢å¼è¯­æ³•ã€è¯­ä¹‰è§„åˆ™ã€æŽ¨ç†è§„åˆ™ç­‰ï¼Œä¸ºç³»ç»Ÿç†è®ºçš„ç²¾ç¡®æè¿°å’ŒæŽ¨ç†æä¾›è¯­è¨€åŸºç¡€ã€‚

## ðŸ”¤ å½¢å¼è¯­æ³• / Formal Syntax

### 1. åŸºæœ¬è¯­æ³•ç»“æž„ / Basic Syntax Structure

#### 1.1 å­—æ¯è¡¨ / Alphabet

**å­—æ¯è¡¨** $\Sigma$ æ˜¯ç¬¦å·çš„æœ‰é™é›†åˆï¼š

$$\Sigma = \{a_1, a_2, ..., a_n\}$$

**ç³»ç»Ÿç†è®ºå­—æ¯è¡¨**:
$$\Sigma_{ST} = \Sigma_{logical} \cup \Sigma_{mathematical} \cup \Sigma_{system}$$

å…¶ä¸­ï¼š

- $\Sigma_{logical}$ - é€»è¾‘ç¬¦å·é›†åˆ
- $\Sigma_{mathematical}$ - æ•°å­¦ç¬¦å·é›†åˆ
- $\Sigma_{system}$ - ç³»ç»Ÿç†è®ºç¬¦å·é›†åˆ

#### 1.2 å­—ç¬¦ä¸² / Strings

**å­—ç¬¦ä¸²**æ˜¯å­—æ¯è¡¨ä¸­ç¬¦å·çš„æœ‰é™åºåˆ—ï¼š

$$w = a_1 a_2 ... a_n \in \Sigma^*$$

**å­—ç¬¦ä¸²è¿ç®—**:

- **è¿žæŽ¥**: $w_1 \cdot w_2 = w_1 w_2$
- **é•¿åº¦**: $|w| = n$
- **ç©ºå­—ç¬¦ä¸²**: $\epsilon$ (é•¿åº¦ä¸º0çš„å­—ç¬¦ä¸²)

#### 1.3 è¯­è¨€ / Language

**è¯­è¨€**æ˜¯å­—ç¬¦ä¸²çš„é›†åˆï¼š

$$L \subseteq \Sigma^*$$

**è¯­è¨€è¿ç®—**:

- **å¹¶é›†**: $L_1 \cup L_2 = \{w | w \in L_1 \lor w \in L_2\}$
- **è¿žæŽ¥**: $L_1 \cdot L_2 = \{w_1 w_2 | w_1 \in L_1, w_2 \in L_2\}$
- **å…‹æž—é—­åŒ…**: $L^* = \bigcup_{i=0}^{\infty} L^i$

### 2. å½¢å¼æ–‡æ³• / Formal Grammar

#### 2.1 æ–‡æ³•å®šä¹‰ / Grammar Definition

**å½¢å¼æ–‡æ³•** $G = (V, T, P, S)$ åŒ…å«ï¼š

- $V$ - éžç»ˆç»“ç¬¦é›†åˆ (Variables)
- $T$ - ç»ˆç»“ç¬¦é›†åˆ (Terminals)
- $P$ - äº§ç”Ÿå¼é›†åˆ (Productions)
- $S$ - èµ·å§‹ç¬¦å· (Start Symbol)

**äº§ç”Ÿå¼å½¢å¼**:
$$\alpha \rightarrow \beta$$

å…¶ä¸­ $\alpha, \beta \in (V \cup T)^*$

#### 2.2 æ–‡æ³•ç±»åž‹ / Grammar Types

**ä¹”å§†æ–¯åŸºæ–‡æ³•åˆ†ç±»**:

1. **0åž‹æ–‡æ³•** (æ— é™åˆ¶æ–‡æ³•):
   $$\alpha \rightarrow \beta \text{ where } \alpha, \beta \in (V \cup T)^*$$

2. **1åž‹æ–‡æ³•** (ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•):
   $$\alpha A \beta \rightarrow \alpha \gamma \beta \text{ where } A \in V, \alpha, \beta, \gamma \in (V \cup T)^*$$

3. **2åž‹æ–‡æ³•** (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•):
   $$A \rightarrow \alpha \text{ where } A \in V, \alpha \in (V \cup T)^*$$

4. **3åž‹æ–‡æ³•** (æ­£åˆ™æ–‡æ³•):
   $$A \rightarrow aB \text{ or } A \rightarrow a \text{ where } A, B \in V, a \in T$$

#### 2.3 ç³»ç»Ÿç†è®ºæ–‡æ³• / System Theory Grammar

**ç³»ç»Ÿç†è®ºå½¢å¼æ–‡æ³•** $G_{ST}$:

**éžç»ˆç»“ç¬¦**:

- $S$ - ç³»ç»Ÿè¡¨è¾¾å¼
- $E$ - è¦ç´ è¡¨è¾¾å¼
- $R$ - å…³ç³»è¡¨è¾¾å¼
- $F$ - å‡½æ•°è¡¨è¾¾å¼
- $B$ - è¾¹ç•Œè¡¨è¾¾å¼

**äº§ç”Ÿå¼**:

```text
S â†’ (E, R, B, F)
E â†’ {eâ‚, eâ‚‚, ..., eâ‚™}
R â†’ {ráµ¢â±¼ | i,j âˆˆ {1,2,...,n}}
B â†’ B: E â†’ {0,1}
F â†’ {fâ‚, fâ‚‚, ..., fâ‚˜}
```

### 3. è¯­æ³•æ ‘ / Syntax Trees

#### 3.1 è¯­æ³•æ ‘å®šä¹‰ / Syntax Tree Definition

**è¯­æ³•æ ‘**æ˜¯æ–‡æ³•æŽ¨å¯¼çš„å›¾å½¢è¡¨ç¤ºï¼š

$$T = (N, E, r)$$

å…¶ä¸­ï¼š

- $N$ - èŠ‚ç‚¹é›†åˆ
- $E$ - è¾¹é›†åˆ
- $r$ - æ ¹èŠ‚ç‚¹

#### 3.2 è¯­æ³•æ ‘æž„å»º / Syntax Tree Construction

**æŽ¨å¯¼è¿‡ç¨‹**:
$$S \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow ... \Rightarrow w$$

**è¯­æ³•æ ‘èŠ‚ç‚¹**:

- **å†…éƒ¨èŠ‚ç‚¹**: éžç»ˆç»“ç¬¦
- **å¶èŠ‚ç‚¹**: ç»ˆç»“ç¬¦

#### 3.3 ç³»ç»Ÿç†è®ºè¯­æ³•æ ‘ / System Theory Syntax Tree

**ç³»ç»Ÿè¡¨è¾¾å¼è¯­æ³•æ ‘**:

```text
        S
       /|\
      / | \
     E  R  F
    /|\
   eâ‚ eâ‚‚ eâ‚ƒ
```

## ðŸŽ¯ è¯­ä¹‰è§„åˆ™ / Semantic Rules

### 1. è¯­ä¹‰åŸŸ / Semantic Domains

#### 1.1 åŸºæœ¬è¯­ä¹‰åŸŸ / Basic Semantic Domains

**è¯­ä¹‰åŸŸ**æ˜¯è¯­è¨€è¡¨è¾¾å¼çš„å«ä¹‰ç©ºé—´ï¼š

$$\mathcal{D} = \{\mathcal{D}_1, \mathcal{D}_2, ..., \mathcal{D}_n\}$$

**ç³»ç»Ÿç†è®ºè¯­ä¹‰åŸŸ**:

- $\mathcal{D}_{System}$ - ç³»ç»Ÿè¯­ä¹‰åŸŸ
- $\mathcal{D}_{Element}$ - è¦ç´ è¯­ä¹‰åŸŸ
- $\mathcal{D}_{Relation}$ - å…³ç³»è¯­ä¹‰åŸŸ
- $\mathcal{D}_{Function}$ - å‡½æ•°è¯­ä¹‰åŸŸ
- $\mathcal{D}_{State}$ - çŠ¶æ€è¯­ä¹‰åŸŸ

#### 1.2 è¯­ä¹‰å‡½æ•° / Semantic Functions

**è¯­ä¹‰å‡½æ•°**å°†è¯­æ³•è¡¨è¾¾å¼æ˜ å°„åˆ°è¯­ä¹‰åŸŸï¼š

$$\mathcal{M}: \text{Syntax} \rightarrow \text{Semantics}$$

**ç³»ç»Ÿç†è®ºè¯­ä¹‰å‡½æ•°**:
$$\mathcal{M}_{ST}: L_{ST} \rightarrow \mathcal{D}_{ST}$$

#### 1.3 è¯­ä¹‰ç»„åˆæ€§ / Semantic Compositionality

**ç»„åˆæ€§åŽŸåˆ™**:
$$\mathcal{M}(E_1 \circ E_2) = \mathcal{M}(E_1) \otimes \mathcal{M}(E_2)$$

å…¶ä¸­ $\otimes$ æ˜¯è¯­ä¹‰ç»„åˆè¿ç®—ã€‚

### 2. æ“ä½œè¯­ä¹‰ / Operational Semantics

#### 2.1 æ“ä½œè¯­ä¹‰å®šä¹‰ / Operational Semantics Definition

**æ“ä½œè¯­ä¹‰**é€šè¿‡è®¡ç®—è§„åˆ™å®šä¹‰è¯­è¨€è¡¨è¾¾å¼çš„å«ä¹‰ï¼š

$$\frac{Premises}{Conclusion}$$

**ç³»ç»Ÿç†è®ºæ“ä½œè¯­ä¹‰**:

**ç³»ç»Ÿæž„é€ **:
$$\frac{e_1, e_2, ..., e_n \in E \quad r_{ij} \in R \quad b \in B \quad f \in F}{(e_1, e_2, ..., e_n, r_{ij}, b, f) \in S}$$

**è¦ç´ æ“ä½œ**:
$$\frac{e \in E \quad p \in P}{e.p \in E}$$

**å…³ç³»æ“ä½œ**:
$$\frac{r_1, r_2 \in R}{r_1 \circ r_2 \in R}$$

#### 2.2 è®¡ç®—è§„åˆ™ / Computation Rules

**å½’çº¦è§„åˆ™**:
$$e_1 \rightarrow e_2$$

**ç³»ç»Ÿå½’çº¦**:
$$\frac{e_i \rightarrow e_i'}{(e_1, ..., e_i, ..., e_n) \rightarrow (e_1, ..., e_i', ..., e_n)}$$

**å…³ç³»å½’çº¦**:
$$\frac{r_1 \rightarrow r_1' \quad r_2 \rightarrow r_2'}{r_1 \circ r_2 \rightarrow r_1' \circ r_2'}$$

### 3. æŒ‡ç§°è¯­ä¹‰ / Denotational Semantics

#### 3.1 æŒ‡ç§°è¯­ä¹‰å®šä¹‰ / Denotational Semantics Definition

**æŒ‡ç§°è¯­ä¹‰**é€šè¿‡æ•°å­¦å¯¹è±¡è¡¨ç¤ºè¯­è¨€è¡¨è¾¾å¼çš„å«ä¹‰ï¼š

$$\mathcal{D}[\![E]\!]: \text{Environment} \rightarrow \text{Value}$$

**ç³»ç»Ÿç†è®ºæŒ‡ç§°è¯­ä¹‰**:

**ç³»ç»Ÿè¡¨è¾¾å¼**:
$$\mathcal{D}[\![S]\!] = \mathcal{D}[\![E]\!] \times \mathcal{D}[\![R]\!] \times \mathcal{D}[\![B]\!] \times \mathcal{D}[\![F]\!]$$

**è¦ç´ è¡¨è¾¾å¼**:
$$\mathcal{D}[\![E]\!] = \mathcal{P}(\mathcal{D}_{Element})$$

**å…³ç³»è¡¨è¾¾å¼**:
$$\mathcal{D}[\![R]\!] = \mathcal{P}(\mathcal{D}_{Element} \times \mathcal{D}_{Element})$$

#### 3.2 çŽ¯å¢ƒ / Environment

**çŽ¯å¢ƒ**æ˜¯å˜é‡åˆ°å€¼çš„æ˜ å°„ï¼š

$$\rho: \text{Variable} \rightarrow \text{Value}$$

**çŽ¯å¢ƒæ›´æ–°**:
$$\rho[x \mapsto v] = \rho' \text{ where } \rho'(y) = \begin{cases} v & \text{if } y = x \\ \rho(y) & \text{otherwise} \end{cases}$$

## ðŸ” æŽ¨ç†è§„åˆ™ / Inference Rules

### 1. é€»è¾‘æŽ¨ç† / Logical Inference

#### 1.1 å‘½é¢˜é€»è¾‘æŽ¨ç† / Propositional Logic Inference

**åŸºæœ¬æŽ¨ç†è§„åˆ™**:

**å‡è¨€æŽ¨ç†** (Modus Ponens):
$$\frac{P \rightarrow Q \quad P}{Q}$$

**å‡è¨€ä¸‰æ®µè®º** (Hypothetical Syllogism):
$$\frac{P \rightarrow Q \quad Q \rightarrow R}{P \rightarrow R}$$

**æžå–ä¸‰æ®µè®º** (Disjunctive Syllogism):
$$\frac{P \lor Q \quad \neg P}{Q}$$

**æž„é€ æ€§äºŒéš¾** (Constructive Dilemma):
$$\frac{P \rightarrow Q \quad R \rightarrow S \quad P \lor R}{Q \lor S}$$

#### 1.2 è°“è¯é€»è¾‘æŽ¨ç† / Predicate Logic Inference

**å…¨ç§°å®žä¾‹åŒ–** (Universal Instantiation):
$$\frac{\forall x P(x)}{P(a)}$$

**å…¨ç§°æ¦‚æ‹¬** (Universal Generalization):
$$\frac{P(a) \text{ for arbitrary } a}{\forall x P(x)}$$

**å­˜åœ¨å®žä¾‹åŒ–** (Existential Instantiation):
$$\frac{\exists x P(x)}{P(c) \text{ for some } c}$$

**å­˜åœ¨æ¦‚æ‹¬** (Existential Generalization):
$$\frac{P(a)}{\exists x P(x)}$$

### 2. ç³»ç»Ÿç†è®ºæŽ¨ç† / System Theory Inference

#### 2.1 ç³»ç»Ÿç»“æž„æŽ¨ç† / System Structure Inference

**ç³»ç»Ÿæž„æˆæŽ¨ç†**:
$$\frac{e_1, e_2, ..., e_n \in E \quad r_{ij} \in R \quad b \in B \quad f \in F}{S = (E, R, B, F) \text{ is a system}}$$

**ç³»ç»Ÿåˆ†è§£æŽ¨ç†**:
$$\frac{S = (E, R, B, F) \text{ is a system}}{E \subseteq \mathcal{U} \land R \subseteq E \times E \land B: E \rightarrow \{0,1\} \land F \subseteq \mathcal{F}}$$

**ç³»ç»Ÿç»„åˆæŽ¨ç†**:
$$\frac{S_1 = (E_1, R_1, B_1, F_1) \quad S_2 = (E_2, R_2, B_2, F_2)}{S_1 \otimes S_2 = (E_1 \cup E_2, R_1 \cup R_2, B_1 \cup B_2, F_1 \cup F_2)}$$

#### 2.2 ç³»ç»Ÿæ€§è´¨æŽ¨ç† / System Property Inference

**æ•´ä½“æ€§æŽ¨ç†**:
$$\frac{S = (E, R, B, F) \quad \mathcal{E}(S) > \sum_{e \in E} \mathcal{E}(\{e\})}{S \text{ exhibits wholeness}}$$

**æ¶ŒçŽ°æ€§æŽ¨ç†**:
$$\frac{S = (E, R, B, F) \quad \exists P: P(S) \land \forall e \in E: \neg P(\{e\})}{S \text{ exhibits emergence}}$$

**å±‚æ¬¡æ€§æŽ¨ç†**:
$$\frac{S = (E, R, B, F) \quad \mathcal{H}(S) = \{H_1, H_2, ..., H_n\} \land n > 1}{S \text{ exhibits hierarchy}}$$

### 3. è¯æ˜Žç³»ç»Ÿ / Proof System

#### 3.1 è‡ªç„¶æ¼”ç»Ž / Natural Deduction

**è‡ªç„¶æ¼”ç»Žè§„åˆ™**:

**å¼•å…¥è§„åˆ™**:

- **åˆå–å¼•å…¥**: $\frac{P \quad Q}{P \land Q}$
- **æžå–å¼•å…¥**: $\frac{P}{P \lor Q}$
- **è•´å«å¼•å…¥**: $\frac{[P] \quad Q}{P \rightarrow Q}$
- **å¦å®šå¼•å…¥**: $\frac{[P] \quad \bot}{\neg P}$

**æ¶ˆé™¤è§„åˆ™**:

- **åˆå–æ¶ˆé™¤**: $\frac{P \land Q}{P}$ æˆ– $\frac{P \land Q}{Q}$
- **æžå–æ¶ˆé™¤**: $\frac{P \lor Q \quad [P] \quad R \quad [Q] \quad R}{R}$
- **è•´å«æ¶ˆé™¤**: $\frac{P \rightarrow Q \quad P}{Q}$
- **å¦å®šæ¶ˆé™¤**: $\frac{\neg \neg P}{P}$

#### 3.2 ç³»ç»Ÿç†è®ºè¯æ˜Ž / System Theory Proof

**ç³»ç»Ÿå­˜åœ¨æ€§è¯æ˜Ž**:

```text
1. Let E be a set of elements
2. Let R be a set of relations on E
3. Let B be a boundary function
4. Let F be a set of functions
5. Then S = (E, R, B, F) is a system
```

**ç³»ç»Ÿæ€§è´¨è¯æ˜Ž**:

```text
1. Assume S = (E, R, B, F) is a system
2. Show that E is non-empty
3. Show that R is a relation on E
4. Show that B is a function
5. Show that F is a set of functions
6. Therefore, S satisfies system axioms
```

## ðŸ”§ å½¢å¼åŒ–å·¥å…· / Formal Tools

### 1. å½¢å¼åŒ–éªŒè¯ / Formal Verification

#### 1.1 æ¨¡åž‹æ£€æŸ¥ / Model Checking

**æ¨¡åž‹æ£€æŸ¥**éªŒè¯ç³»ç»Ÿæ˜¯å¦æ»¡è¶³è§„èŒƒï¼š

$$\mathcal{M} \models \phi$$

å…¶ä¸­ï¼š

- $\mathcal{M}$ - ç³»ç»Ÿæ¨¡åž‹
- $\phi$ - è§„èŒƒå…¬å¼

**ç³»ç»Ÿæ¨¡åž‹æ£€æŸ¥**:
$$\mathcal{M}_{ST} \models \text{SystemProperty}$$

#### 1.2 å®šç†è¯æ˜Ž / Theorem Proving

**å®šç†è¯æ˜Ž**é€šè¿‡é€»è¾‘æŽ¨ç†è¯æ˜Žç³»ç»Ÿæ€§è´¨ï¼š

$$\Gamma \vdash \phi$$

å…¶ä¸­ï¼š

- $\Gamma$ - å…¬ç†é›†åˆ
- $\phi$ - å¾…è¯æ˜Žçš„å®šç†

**ç³»ç»Ÿå®šç†è¯æ˜Ž**:
$$\text{SystemAxioms} \vdash \text{SystemTheorem}$$

### 2. å½¢å¼åŒ–è§„èŒƒ / Formal Specification

#### 2.1 è§„èŒƒè¯­è¨€ / Specification Language

**è§„èŒƒè¯­è¨€**ç”¨äºŽæè¿°ç³»ç»Ÿè¦æ±‚ï¼š

$$\text{Spec} = \{\text{Requirements}, \text{Constraints}, \text{Properties}\}$$

**ç³»ç»Ÿè§„èŒƒ**:
$$\text{SystemSpec} = \{\text{FunctionalReq}, \text{NonFunctionalReq}, \text{SystemConstraints}\}$$

#### 2.2 è§„èŒƒéªŒè¯ / Specification Verification

**è§„èŒƒä¸€è‡´æ€§**:
$$\text{Consistent}(\text{Spec}) \iff \nexists \phi, \psi \in \text{Spec}: \phi \land \psi \vdash \bot$$

**è§„èŒƒå®Œå¤‡æ€§**:
$$\text{Complete}(\text{Spec}) \iff \forall \phi: \text{Spec} \vdash \phi \lor \text{Spec} \vdash \neg \phi$$

## ðŸ“š å‚è€ƒæ–‡çŒ® / References

### ç»å…¸æ–‡çŒ® / Classical Literature

1. **Hopcroft, J. E., & Ullman, J. D.** (1979). *Introduction to Automata Theory, Languages, and Computation*. Reading, MA: Addison-Wesley.
2. **Winskel, G.** (1993). *The Formal Semantics of Programming Languages*. Cambridge, MA: MIT Press.
3. **Girard, J.-Y., Lafont, Y., & Taylor, P.** (1989). *Proofs and Types*. Cambridge: Cambridge University Press.

### çŽ°ä»£æ–‡çŒ® / Modern Literature

1. **Pierce, B. C.** (2002). *Types and Programming Languages*. Cambridge, MA: MIT Press.
2. **Plotkin, G. D.** (1981). *A Structural Approach to Operational Semantics*. Technical Report DAIMI FN-19, Aarhus University.
3. **Scott, D.** (1970). *Outline of a Mathematical Theory of Computation*. Technical Monograph PRG-2, Oxford University.

### ä¸­æ–‡æ–‡çŒ® / Chinese Literature

1. **çŽ‹æè´«** (2003). *å½¢å¼è¯­ä¹‰å­¦*. åŒ—äº¬: åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
2. **é™†æ±é’¤** (2003). *å½¢å¼è¯­è¨€ä¸Žè‡ªåŠ¨æœº*. åŒ—äº¬: æ¸…åŽå¤§å­¦å‡ºç‰ˆç¤¾.
3. **å¼ ç«‹æ˜‚** (2002). *ç¼–è¯‘åŽŸç†*. åŒ—äº¬: æ¸…åŽå¤§å­¦å‡ºç‰ˆç¤¾.

---

> å½¢å¼åŒ–è¯­è¨€ä¸ºç³»ç»Ÿç†è®ºæä¾›äº†ç²¾ç¡®çš„è¡¨è¾¾å·¥å…·ï¼Œç¡®ä¿ç†è®ºæè¿°çš„å‡†ç¡®æ€§å’ŒæŽ¨ç†çš„ä¸¥æ ¼æ€§ã€‚
> Formal language provides precise expression tools for system theory, ensuring the accuracy of theoretical descriptions and the rigor of reasoning.
